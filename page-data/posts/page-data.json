{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"d06da570-e4c7-536d-a2df-576540fe90dd","excerpt":"나는 나이많은 비전공자 개발자이기 때문에 항상 어떻게 해야 더 빨리 더 효율적으로 좋은 개발자가 될 지 고민하고 있다. 개발자는 평생 공부해야 하는 직업이기 때문에 입사 전 월요일에는 뭐 공부하고 주말에는 뭐 공부하자라는 식으로 세세한 계획을 세웠었다. 현실은 출퇴근 여행자라 긴 출퇴근 시간에 완벽하게 적응하지 못했고 퇴근하면 4시간 정도후에 잠들어야 한다. (워라벨 붕괴) 또한 출퇴근 길에 공부를 하려고 했으나, 지하철 소음에 적응하지 못해 공부에 집중이 되지 않고 있어 공부에 진척이 없어 초초한 마음이 생겼다. 😨 (이건 익숙해지면 시간이 해결해 줄 거라고 믿는다.)  스타트업 개발자로 일하면서 개발만 잘하는 것이 아닌 사람과 사람사이의 커뮤니케이션이 중요하다는 것을 다시 한번 깨닫게 되었다. 우리 회사 대표님왈) 개발팀 PM님은 개발도 잘하지만 타 부서의 일에 대한 지식도 높아 커뮤니케이션 능력이 뛰어나고 공감능력도 좋아 두루두루 잘 어울리는 사람이라고 하셨다.  PM님은 어…","fields":{"slug":"/diary/2022-06-12/"},"frontmatter":{"categories":"diary","title":"[diary] 성장하는 개발자","date":"June 12, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/web/2022-04-25-url-web/"}},"previous":null},{"node":{"id":"821a88dd-caf7-531d-92c5-7cd47f4cd5ca","excerpt":"주소창에 URL을 입력하면, DNS 서버 검색 \r\n브라우저는 DNS(Domain Name System)를 운영하는 서버를 통해 서버의 실제 주소인 IP 주소를 요청한다. 매핑되는 IP 주소가 있다면 사용자가 입력한 URL 정보와 함께 전달한다. 브라우저는 IP 주소를 이용해서 서버에 요청을 보낸다. \r\n페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다. 서버는 요청에 대한 응답을 보내준다. \r\n검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다. 브라우저는…","fields":{"slug":"/web/2022-04-25-url-web/"},"frontmatter":{"categories":"web","title":"[web] 브라우저에 URL을 입력했을 때 발생하는 일들","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/react/2022-04-25-hooks/"}},"previous":{"fields":{"slug":"/diary/2022-06-12/"}}},{"node":{"id":"0d5b2121-aff7-57bb-b4c6-36a8b8f7bb15","excerpt":"Hooks란? 리액트 16.8 이전 버전에서는 function 컴포넌트에서는 상태(state)를 관리할 수가 없었다. 16.8 버전에서 Hooks 라는 기능이 도입되면서 function 컴포넌트에서도 상태를 관리할 수 있게 되었다. function 컴포넌트의 Hooks를 사용하면 class 컴포넌트에서만 사용할 수 있었던 라이프사이클을 사용할 수 있으며 React의 여러 기능을 함수형 프로그래밍으로 사용할 수 있게 해준다. useState 리액트는 state나 props의 값이 변경되면 이를 감지하고 리렌더링을 한다. state는 화면을 바꿔주기위해 사용되는 트리거역할을 하는 값이며 는 state의 값을 변경해주는 Hook이다. const [state, setState] = useState(기본값); useEffect 는 컴포넌트가 마운트 됐을 때 (처음 나타났을 때), 언마운트 됐을 때 (사라질 때), 그리고 업데이트 될 때 (특정 props가 바뀔 때) 특정 작업을 처리할 수 …","fields":{"slug":"/react/2022-04-25-hooks/"},"frontmatter":{"categories":"react","title":"[react] React Hooks (리액트 훅스)","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/react/2022-04-25-virtual-dom/"}},"previous":{"fields":{"slug":"/web/2022-04-25-url-web/"}}},{"node":{"id":"4dfe4d80-a057-5c8c-99fe-bcbdb5e7d196","excerpt":"브라우저 workflow \r\n\r\n이미지 출처 : 브라우저는 어떻게 동작하는가? DOM Tree 생성 브라우저가 서버에서 HTML을 전달받으면, 렌더링 엔진이 HTML을 파싱하고, DOM의 Node로 이루어진 트리를 만든다. (Node는 html 엘리먼트와 연관)  Render Tree 생성 css파일과 각 엘리먼트의 inline 스타일을 파싱하고 CSSOM을 생성한다. (노드의 스타일을 처리하는 과정 : 어테치먼트) \r\n→ DOM Tree와 CSSOM을 결합하여 새로운 Render Tree를 생성한다. Layout (=Reflow) 생성된 렌더트리의 각 노드들이 스크린상의 좌표가 주어지고, 어느 공간에 위치해야 하는지가 결정된다. \r\n(position이나 size 등이 여기서 계산된다) Painting 구성된 레이아웃을 화면에 그리는 과정이 진행된다. 트리의 각 노드들을 거쳐가면서 화면이 스크린에 나타난다. \r\nDOM을 임의적으로 조작을 하면 이 과정들이 반복된다.  Virtual…","fields":{"slug":"/react/2022-04-25-virtual-dom/"},"frontmatter":{"categories":"react","title":"[react] Virtual Dom (가상 돔)","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/js/2022-04-25-promise/"}},"previous":{"fields":{"slug":"/react/2022-04-25-hooks/"}}},{"node":{"id":"913f25a7-18ee-5605-bc86-ab7ed6937c0e","excerpt":"자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 비동기에서 사용되던 콜백 패턴은 계속되는 콜백으로 인해 콜백 지옥(Callback Hell)에 빠질 확률이 높다. 콜백 지옥에 빠지면 코드의 가독성이 떨어지고 비동기 처리 중 발생한 에러를 처리하는데 많은 노력이 필요하며 여러 개의 비동기 처리를 한번에 처리하는 데도 한계가 있다. \r\nEs6에서는 비동기 처리를 위한 패턴으로 프로미스(Promise)를 도입했다. 프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있어 비동기 처리가 간결하다는 장점이 있다.\r\n또한 프로미스는 HTTP 요청 전송이 가능한 Web API인 fetch함수를 지원한다. 이 포스팅에서는 Promise 뿐만 아니라 콜백과 fetch에 관해서도 간단하게 다룬다.  콜백 함수(Callback Function)란? 콜백 함수란 파라미터(인자)에 함수를 전달받아 해당 함수의 내부에서 실행하는 함수…","fields":{"slug":"/js/2022-04-25-promise/"},"frontmatter":{"categories":"js","title":"[js] Promise","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/js/2022-04-25-throttle-debounce/"}},"previous":{"fields":{"slug":"/react/2022-04-25-virtual-dom/"}}},{"node":{"id":"61fae59e-fba6-56d3-b1ae-eff80f5c3b60","excerpt":"scroll 이벤트를 사용하면 스크롤을 올리거나 내리는 짧은 시간동안 많은 이벤트가 발생한다. 복잡한 작업의 scroll 이벤트를 처리한다면 빈번하게 실행되는 이벤트 때문에 성능이 저하되고 렉이 걸릴 확률이 높아진다. \r\n이처럼 짧은 시간 간격으로 연속해서 발생하는 이벤트의 과도한 이벤트 핸들러 호출을 방지하기 위해 스로틀과 디바운스를 사용하면 성능향상에 도움이 된다. 스로틀 (throttle) 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 한다. 즉, 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그릅화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.  *실무에서는 Underscore의 throttle 함수나 Lodash의 throttle 함수를 사용하는것을 권장한다. 디바운스 (debounce) 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이…","fields":{"slug":"/js/2022-04-25-throttle-debounce/"},"frontmatter":{"categories":"js","title":"[js] throttling과 debouncing","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/js/2022-04-25-async-await/"}},"previous":{"fields":{"slug":"/js/2022-04-25-promise/"}}},{"node":{"id":"7352b72d-fc7e-508f-bf2c-3d0858067295","excerpt":"async/await는 ES8에서 채택되었으며 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기처럼 동작하도록 구현할 수 있다. \r\n프로미스를 기반으로 동작하며 프로미스의 then/catch/finally 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.  제너레이터 (Generator) Es6에서 도입된 제너레이터는 코드 블록의 실행을 일시 중지시켰다가 필요한 시점에 재개할 수 있는 특수한 함수다. \r\n제너레이터는 이터레이터를 발생시키는 함수로 사용되면 function* 키워드로 선언한다. \r\n제너레이터 함수는 화살표 함수로 정의하 수없으며 new 연산자와 함께 생성자 함수로 호출할 수 없다. \r\n*이터레이터(iterator)? {value, done} 객체를 리턴하는 next()를 가진 값  *제너레이터 vs 일반함수 제너레이터 함수는 함수 호출자에게 함수 실행의 제어…","fields":{"slug":"/js/2022-04-25-async-await/"},"frontmatter":{"categories":"js","title":"[js] Async await","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/js/2022-04-25-js-runtime/"}},"previous":{"fields":{"slug":"/js/2022-04-25-throttle-debounce/"}}},{"node":{"id":"039691d1-1c37-58e4-99dc-cc15527486b8","excerpt":"자바스크립트는 싱글 스레드로 한번에 한개의 작업만을 다룰 수 있는 동기식 언어이다. \r\n  *싱글 스레드 : 하나의 프로그램에서 하나의 코드만 실행할 수 있다는 뜻이다. 하나의 작업이 끝나야 다음 작업을 시작할 수 있다. 자바스크립트 런타임이란? 런타임이란 프로그래밍 언어가 구동되는 환경을 말한다. 자바스크립트 런타임은 자바스크립트가 구동되는 환경 종류 : 웹 브라우저 (크롬, 파이어폭스 등), Node.js 런타임 환경 : Memory heap, call stack, web Apis(setTimeout, DOM, AJAX), callback queue, event loop 구글의 v8 자바스크립트 엔진 영역 콜 스택(call stack) : 소스코드 (전역, 함수 등) 평가 과정에서 생성된 실행 컨텍스트가 추가 및 제거되는 곳이다. 힙(heap) : 객체가 저장되는 메모리 공간. 콜 스택의 실행 컨텍스트는 여기에 저장된 객체를 참조한다.\r\n 브라우저 환경 및 Node.js 제공 …","fields":{"slug":"/js/2022-04-25-js-runtime/"},"frontmatter":{"categories":"js","title":"[js] 자바스크립트 런타임","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/redux/2022-04-25-redux-saga/"}},"previous":{"fields":{"slug":"/js/2022-04-25-async-await/"}}},{"node":{"id":"fe6d23ba-1610-5bce-aaf1-0a33d8df7ff7","excerpt":"Redux의 미들웨어 라이브러리 중 한 개로 Redux-thunk, Redux-toolkit 등 다양한 라이브러리가 존재하지만 Redux-saga를 사용하는 기업이 많다. \r\nRedux-saga는 다른 라이브러리에 비해 더 복잡한 비동기 처리를 할 수 있다는 장점이 있다. \r\n단점은 러닝커브가 높고 제네레이터라는 문법에 익숙하지 않다면 어색하게 느껴 질 수 있다. 또한 코드가 길어져 복잡해질 수 있다. \r\n(최근엔 toolkit도 많이 쓰이며 saga의 기능을 설치하여 연동 가능하다고 하니 toolkit도 공부하면 좋을 것 같다.)\r\n 선수지식 - 제너레이터 (Generator) 함수에 *를 붙이고, yield라는 문법을 사용 next()를 이용하여 다음 yield를 호출 Redux-saga 주요 Effects 1. fork 는 함수의 비동기적인 호출을 할 때 사용하며 순서 상관없이 실행할 때 사용한다. 2. call 은 동기 실행을 보장하며 순서대로 함수를 실행해야하는 API 요…","fields":{"slug":"/redux/2022-04-25-redux-saga/"},"frontmatter":{"categories":"redux","title":"[redux] Redux Saga","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/web/2022-04-25-browsers-repository/"}},"previous":{"fields":{"slug":"/js/2022-04-25-js-runtime/"}}},{"node":{"id":"d6f9de53-d38b-5f86-a4c2-429d2d6cc789","excerpt":"브라우저 저장소 (Web Storage) 웹의 데이터를 클라이언트에 저장할 수 있는 자료구조다.\r\nHTML5에서는 웹 사이트의 데이터를 클라이언트에 저장할 수 있는 새로운 자료구조인 Web Storage 스펙이 포함되어있다.\r\n 쌍으로 데이터를 저장하고 를 기반으로 데이터를 조회하는 패턴이다. \r\n내부적으로는 영구저장소(LocalStorage)와 임시저장소(SessionStorage)가 분리되어 데이터 지속성에 따라 구분할 수 있어 응용 환경에 맞는 선택이 가능하다. \r\nWeb Storage는 Local Storage와 Session Storage 두 가지 방식이 있다. Web Storage의 특징 서버 전송이 없다 : 데이터를 서버로 전송하지 않기 때문에 트래픽 비용을 아낄 수 있다. 브라우저별 용량제한이 다르다. 영구적으로 저장이 가능하다 : 만료기간 없이 영구적으로 데이터를 저장할 수도 있다.\r\n(Local Storage = 만료기한 없음, Session Storage = 세…","fields":{"slug":"/web/2022-04-25-browsers-repository/"},"frontmatter":{"categories":"web","title":"[web] Storage vs Cookie","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/git/2022-04-25-git-basic/"}},"previous":{"fields":{"slug":"/redux/2022-04-25-redux-saga/"}}},{"node":{"id":"ff20454d-b4f0-57e6-a33c-e5c9ec92daae","excerpt":"기본 명령어 브랜치 생성하여 작업하고 공통 브랜치에서 변경사항 다운받기 좋은 커밋 메시지를 작성하는 7가지 규칙 주제와 본문을 빈줄로 분리하기 주제는 50자로 제한하기 주제의 첫 글자는 대문자로 쓰기 주제에 마침표를 넣지 않기 주제는 명령으로 작성하기 본문은 72자에 줄바꿈하기 how 보단 what과 why를 설명하기 커밋 메시지의 구조 subject의 type은 커밋의 성격을 나타낸다. 바닥글/꼬리말 꼬리말은 “type: #이슈 번호” 형식 이슈 번호는 쉼표(,)로 구분 커밋 구조를 적용한 예시 기본 명령어 브랜치 생성하여 작업하고 공통 브랜치에서 변경사항 다운받기 좋은 커밋 메시지를 작성하는 7가지 규칙 커밋 메시지의 구조 subject의 type은 커밋의 성격을 나타낸다. 바닥글/꼬리말 커밋 구조를 적용한 예시","fields":{"slug":"/git/2022-04-25-git-basic/"},"frontmatter":{"categories":"git","title":"[git] git 기본 사용법","date":"April 25, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/diary/2022-03-09/"}},"previous":{"fields":{"slug":"/web/2022-04-25-browsers-repository/"}}},{"node":{"id":"7196c4a5-a89c-5ea5-b9d8-0631d8516916","excerpt":"2달동안의 구직활동을 마치고, 마침내 신입 프론트엔드 개발자로 합격했다. \r\n그동안 내가 많은 개발자분들의 블로그를 통해 도움을 받은 것 처럼, 내 글이 프론트엔드 개발자로 취업을 희망하는 신입개발자들에게 도움이 되길 바라는 마음으로 글을 썼다. 1월부터 신입 프론트엔드 개발자로 구직을 시작했다. \r\n하지만 며칠에 한번씩 한꺼번에 지원했었고, 본격적으로 구직을 시작한건 2월 부터다. 나는 36곳을 지원했고 총 13군데를 서류합격했다. (나쁘지 않은 33%정도의 승률) \r\n2번의 코딩테스트, 3번의 과제 테스트, 4번의 면접(대면, 비대면)을 봐서 2개의 회사에 최종 합격했다. \r\n부끄럽지만 나란 사람이란, 27살에 의류학과 석사 졸업 국비학원을 다닌 후, 29살에 퍼블리셔로 취업 에이전시 근무 및 프리랜서로 대략 4년간의 퍼블리셔 경력 보유\r\n(즉, 비전공자출신에 IT 경력은 있지만 개발직군 경력은 전무한 상황) 현재 나이는 30대 중반 방통대 컴퓨터과학과 3학년으로 편입했으나 휴…","fields":{"slug":"/diary/2022-03-09/"},"frontmatter":{"categories":"diary","title":"[diary] 프론트엔드 신입 면접 준비하기","date":"April 14, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/react/2022-04-05-react/"}},"previous":{"fields":{"slug":"/git/2022-04-25-git-basic/"}}},{"node":{"id":"877f1639-2f1e-51c5-98c8-e17edf1b0bda","excerpt":"최근 면접을 보면서 나의 코딩 스타일에 대해 생각하게 되었다. \r\n나는 많은 인강을 보면서 react를 독학한 케이스인데 아무래도 인강 강사님의 코드 스타일을 따라가게 되었고 무의식적으로 그렇게 코딩을 했었다. \r\n면접관님이 코딩스타일은 다 다르지만 내가 사용한 코딩스타일은 값과 코드를 확인하기 위해 여러군데를 살펴봐야 하기때문에 본인은 선호하는 방식이 아니라고 하셨다. (솔직히 생각해본적이 없어서 충격 😱)  신규 서비스를 개발하는 경우도 있지만 대부분의 개발은 기존코드를 유지보수 하는 경우가 많다. 이전 개발자가 코딩했던 스타일이 지극히 개인적이라면 어떻겠는가? 또는 동료 개발자가 내 스타일데로 코딩한 코드를 이해하지 못한다면? 개발자들은 자신이 코딩했던 코드도 까먹는 경우가 꽤 많다. 저 당시에 내가 왜 저렇게 코딩 했지?하는 경우를 많이 봤기 때문에 더더욱 개발자들 사이의 규칙이 중요한 것 같다. \r\n현업에서 혼자 개발하는 개발자는 드물다. 그렇기 때문에 협업을 위한 코딩 …","fields":{"slug":"/react/2022-04-05-react/"},"frontmatter":{"categories":"react","title":"[react] react 코딩 컨벤션","date":"April 05, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/react/2022-03-03-react-modal/"}},"previous":{"fields":{"slug":"/diary/2022-03-09/"}}},{"node":{"id":"44efe41a-372d-587f-91ed-9fa69603dde3","excerpt":"내 블로그에서 가장 조회수가 높은 포스팅은 react 모달 포스팅이다. ([react] 모달 팝업창 만들기) \r\n전에 만들었던 Modal은 트랜지션이 적용되지 않았었다. 최근 프로젝트를 만들면서 트랜지션이 적용된 Modal을 만들어야 했었기에 트랜지션이 적용된 react Modal을 만들어 보기로 했다. \r\n(* Modal은 이전에 만들었던 코드에 트랜지션을 추가 적용한다.) 트랜지션이 적용된 Modal 컴포넌트 (함수형) -완성된 모습- 트랜지션 모달 *파일구조   - CSS - Modal.js - App.js 이전코드와 달라진점은 animate, visible 상태값을 추가하고 모달창을 열때와 닫을때의 상태를 체크하여 그에 맞는 css animation 값을 준다는 것이다. 특히, 모달창을 닫을때의 상태를 체크해서 setTimeout으로 애니메이션을 보여준다음 모달창을 사라지게 해야한다는 것이다.","fields":{"slug":"/react/2022-03-03-react-modal/"},"frontmatter":{"categories":"react","title":"[react] transition이 적용된 Modal 만들기","date":"March 03, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/react/2022-02-18-react/"}},"previous":{"fields":{"slug":"/react/2022-04-05-react/"}}},{"node":{"id":"7eae57a9-8dec-5251-8c78-6cb8a831c1ff","excerpt":"최근 구직활동을 시작하면서 사전과제를 받게 되었다. \r\n나의 포지션은 프론트엔드 개발자로 react 라이브러리를 사용하고 있기때문에 react로 자사 사이트 클론 코딩하고 api 요청에 대한 응답결과를 구현하는 과제였다. \r\n포트폴리오를 만들었을때는 CRA를 사용해서 리액트 프로젝트를 만들었었다. create-react-app 한줄만 입력하면 손쉽게 리액트 프로젝트를 만들 수 있었기 때문이다. 생각해보니 프론트엔드 자격요건이나 우대사항에 webpack & babel에 대한 이해나 지식을 요구하는 경우를 종종 보았는데 직접 설정해서 사용해본적은 인강으로 react를 배웠을때 정도였던 것 같다. 문득 직접 프로젝트를 설정할 수 있지만 CRA를 사용하는 것과 모르고 사용하는 것의 차이는 매우 크다는 생각이 들었다. 그래서 마침 사전과제도 요청받았겠다 과제도 하고 내 공부도 할 겸 (꿩먹고 알먹고😋) CRA없이 react 프로젝트를 만들고 프로젝트 환경을 설정해 보기로 했다.  웹팩과 바…","fields":{"slug":"/react/2022-02-18-react/"},"frontmatter":{"categories":"react","title":"[react] CRA없이 React환경 구축하기 (웹팩, 바벨)","date":"February 18, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/css/2022-02-06-scss-for/"}},"previous":{"fields":{"slug":"/react/2022-03-03-react-modal/"}}},{"node":{"id":"44eff4b8-8469-51fe-a632-b463ebad3485","excerpt":"scss의 @for를 이용하면 반복적인 구문을 쉽게 처리할 수있다. \r\n인강에선 @for ~ through로 설명을 했는데 vs코드의 자동완성 코드는 @for ~ to였다. \r\n어떤 차이점이 있는걸까? @for 기본 사용법  $var : 변수명 \r\n<start> : 시작하는 숫자와 \r\n<end> : 끝나는 숫자  for ~ through end로 지장한 숫자까지 반복 for ~ to end로 지장한 숫자-1까지 반복 솔직히 to가 왜있는지 모르겠다 😅 \r\nscss가 자바스크립트랑 비슷한 개념이 많다보니까 js for문의 0인덱스에 익숙한 개발자들을 위해서 나온걸까? \r\n나는 주로 through를 이용해서 코딩하는 습관을 길러야겠다. \r\n(to / through를 동시다발적으로 사용하면 나중에 리뷰할 때 헷갈릴 것 같다.) @for 기본 사용법 for ~ through for ~ to","fields":{"slug":"/css/2022-02-06-scss-for/"},"frontmatter":{"categories":"css","title":"[scss] @for ~ through / to 차이점","date":"February 06, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/react/2022-01-27-styled-components/"}},"previous":{"fields":{"slug":"/react/2022-02-18-react/"}}},{"node":{"id":"fd20216e-a234-50e0-b2d8-77e9b4cdf236","excerpt":"react를 배우던 초창기에는 를 일일히 써주면서 코딩했던 기억이 있다. \r\n사이드 프로젝트에서 styled-components를 사용하고 있는데 저 코드를 일일히 썼을 때 디자이너분이 사이즈의 기준을 바꾸거나 하 코딩한 모든 컴포넌트를 수정해야 한다. \r\nreact로 여러가지 개인 프로젝트나 팀 프로젝트를 진행해보았기 때문에 저런 하드코딩적인 느낌을 지우고 싶었다. \r\nstyled-components에는 라는 속성을 사용해 공통으로 스타일을 관리해 줄 수 있다고 한다.  ThemeProvider Context API를 기반으로 작동하기 때문에 ThemeProvider로 감싸진 모든 하위 컴포넌트들은 전달받은 theme를 props로 사용할 수 있다.\r\n*특히 color사용에 좋다 → 프로젝트를 진행하면서 메인컬러가 바뀌는 경우가 있는데 모든 컴포넌트를 수정하는건 너무 비효율적이다. /assets/style/theme.js App.js (또는 index.js) theme 사용하기 …","fields":{"slug":"/react/2022-01-27-styled-components/"},"frontmatter":{"categories":"react","title":"[react] styled-components 반응형 스타일 설정하기","date":"January 27, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/web/2022-01-02-aws/"}},"previous":{"fields":{"slug":"/css/2022-02-06-scss-for/"}}},{"node":{"id":"534a6f70-a4f6-53cc-80df-2570e0cdb469","excerpt":"맥을 사용하면 터미널로 쉽게 접속이 가능하지만 윈도우로는 터미널 만으로는 ec2 서버에 접속할 수 없다. \r\n(사실 맥을 주로 이용해서 윈도우는 안된다는 걸 몰랐었는데 집에있는 데스크탑으로 접속하려니 안되서 찾아보니 PuTTY를 이용하라 카더라..) 먼저 자신의 window 환경에 맞는 파일을 다운받는다. PuTTY 다운로드  msi 파일을 설치하면 PuTTY.exe 와 PuTTYgen.exe 2개의 파일이 설치된다. PuTTYgen.exe 실행  asw에서 인스턴스를 생성하면서 만들었던 pem 키를 Load한다.  Save private key를 눌러 .ppk 파일을 생성한다.  PuTTY.exe 실행 카테고리 Session에서 Host Name을 설정한다. Host Name은 aws ec2 인스턴스에 연결 페이지에서 확인할 수 있다. \r\n 카테고리 Connection → SSH → Auth를 선택하고 PuTTYgen으로 만들었더 ppk 파일을 추가한다.  다시 Sesstion으…","fields":{"slug":"/web/2022-01-02-aws/"},"frontmatter":{"categories":"web","title":"[aws] PuTTY로 윈도우에서 aws ec2 ssh 접속하기","date":"January 02, 2022","emoji":"📓"}},"next":{"fields":{"slug":"/react/2021-12-22-react-redux-persist/"}},"previous":{"fields":{"slug":"/react/2022-01-27-styled-components/"}}},{"node":{"id":"879dddf5-8832-5c3e-a4ba-6e5d2e5e774b","excerpt":"현재 진행하고 있는 팀프로젝트에서 rudux와 redux-saga를 사용하고 있다. \r\n나 외에도 프론트엔드분이 한분 계신데 store에 어떻게 저장할까 하다가 를 사용해 보고 싶어 제안해 보았고 동의해 주셔서 redux-persist를 사용하기로 하였다. redux-persist란 ? react에서 많이 사용하고 있는 redux는 상태관리로 유명한 라이브러리다. 하나의 store에서 데이터를 관리하면서 상태를 예측가능하게 만들고 유지보수 및 디버깅에 유리하기때문에 순수 js 및 js 라이브러리 및 프레임워크에서 많이 사용한다. \r\n하지만 새로고침을 하면 store의 데이터가 날아가기 때문에, 새로고침을 해도 상태를 유지시키는 기능을 구현해야 한다.\r\n대표적으로 브라우저의 localStorage나 sessionStorage를 이용한 방법이 있는데 직접 코드를 작성해야 하고, store의 데이터가 많아지수록 코드가 복잡해진다는 단점이 있다.  redux-persist는 localst…","fields":{"slug":"/react/2021-12-22-react-redux-persist/"},"frontmatter":{"categories":"react","title":"[react] react프로젝트에 redux-persist 적용하기","date":"December 22, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/algorithm/2021-12-14-codility/"}},"previous":{"fields":{"slug":"/web/2022-01-02-aws/"}}},{"node":{"id":"54a53e36-e32b-5dbd-9bbe-721ce1c1ae88","excerpt":"문제 : codilit MissingInteger \r\nN개의 정수로 이루어진 배열 A가 있다. A에 존재하지 않는 가장 작은 양의 정수를 반환하는 함수를 작성하는 문제이다.\r\n(0보다 큰 양의 정수를 반환해야 한다.)\r\n예를들어, 배열 A가 [−1, −3]으로 주어졌을때 0보다 큰 1이 반환되어야 한다.\r\n Solution: 처음 내가 푼 코드는 이렇다.\r\n배열 A를 순서대로 정렬하고 1부터 A의 가장큰수로 채워진 새로운 배열 arr을 만든다. \r\n그리고 존재하는 값을 확인하기 위해 Set을 사용하여 arr의 값을 복사한다. (indexOf를 사용하면 시간측정이 길어졌기 때문에 Set을 사용했다.)\r\nfor문으로 A의 배열을 돌면서 set에 값이 있는지 체크하고 있다면 delete 메소드로 삭제한다.  남아있는 배열의 개수가 0개라면 A = [1,2,3] 처럼 순서대로 채워진 배열이라는 뜻이기 때문에 3보다 큰 4를 리턴하기 위해 배열의 마지막 원소보다 1이 큰 수를 리턴한다. \r…","fields":{"slug":"/algorithm/2021-12-14-codility/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] Codility Lesson 4. MissingInteger","date":"December 14, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/gatsby/2021-12-12-gaysby/"}},"previous":{"fields":{"slug":"/react/2021-12-22-react-redux-persist/"}}},{"node":{"id":"737728fa-c397-5d9f-bc97-a2e719207dbf","excerpt":"최근 비전공자를 위한 개발자 취업 인강을 듣고 있다. 그곳에서 TIL에 대한 용어를 처음 알게되었다.  TIL ? TIL이란 의 약자로 오늘 내가 배운것이라는 뜻이다. \r\n한국에서는 개발자들 사이에서 많이 쓰이는 용어이지만 외국에서는 SNS상에서 자주 쓰이는 약어라고 한다. \r\n개발자들은 자신의 기술 블로그를 운영하기 때문에 TIL을 따로 운영하지는 분들은 많지 않은것 같다.\r\n(어떻게 생각하면 기술 블로그 = TIL과 비슷한 느낌이랄까.. 🤔)  나는 기술블로그를 운영하지고 있지만 많은 포스팅을 올리지 못하고 있기 때문에 TIL 페이지를 따로 생성할 지 고민을 했다.\r\nTIL을 자기가 배운 내용을 매일 하나씩 쌓으면서 만드는 나만의 지식 사전으로 생각해 보기로 했다. \r\n추후에 동일한 문제가 발생하였을때 해결하지 못한다면 자기반성 및 습득하지 못한 지식을 정리하기에 도움이 될 것 같았기 때문에 TIL 페이지를 생성하기로 결정하였다. TIL 참고 예시 진유림(milooy)님의 TI…","fields":{"slug":"/gatsby/2021-12-12-gaysby/"},"frontmatter":{"categories":"gatsby js","title":"[gatsby] gaysby로 TIL만들기","date":"December 12, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-14-codility/"}}},{"node":{"id":"1d2cec72-d711-5d76-997c-62e25f685b4d","excerpt":"정렬된 배열에서 요소를 찾는 것이 정렬되지 않는 배열에서 찾는 것보다 빠르고 쉽다. \r\n정렬 알고리즘을 사용해 메모리에서 배열을 정렬하거나 정렬된 배열을 파일에 기록할 수 있다. ArrayList함수를 만들어 정렬/검색 대상 데이터를 저장한다.\r\n(각 알고리즘에 대한 설명은 검색하면 너무 자세하게 나와있기 때문에 코드 위주의 포스팅을 했다.) 1. 버블정렬 가장 간단한 정렬 알고리즘이다. \r\n버블정렬은 전체 배열을 순회하면서 인접한 두 원소를 비교하고 그 결과에 따라 두 원소의 위치를 서로 바꾼다. \r\n버블정렬은 모든 값을 비교하기 때문에 정렬 알고리즘들 중에서 가장 최악이라고 할 수 있다. 2. 삽입정렬 배열의 모든 요소를 앞에서부터 차례대로 검색하면서 정렬된 요소와 비교한다. \r\n정렬되지 않은 요소들을 배열의 자신의 위치를 찾아 이동(삽입)시킨다.\r\n(두번째 요소부터 정렬을 시작한다.) 3. 선택정렬 가장 작은 요소를 찾아서(선택해서) 해당 요소를 배열의 현 위치에 삽입하는 방…","fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 정렬 알고리즘 - 버블, 삽입, 선택, 병합, 퀵","date":"December 07, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/algorithm/2021-12-02-bigO/"}},"previous":{"fields":{"slug":"/gatsby/2021-12-12-gaysby/"}}},{"node":{"id":"be168f4b-905b-5024-b846-6a944208c503","excerpt":"알고리즘을 구현하기 전에 알고리즘이 얼마나 효과적인지 분석하는 법을 이해해야 한다.\r\n알고리즘을 구현할 때 빅오 표기법이 해당 알고리즘이 얼마나 효율적인지를 나타내기 때문에 빅오 표기법은 중요하다.\r\n효율적인 방법을 고민한다는 것은 시간 복잡도를 고민한다는 것과 같은 말이다. \r\n Time Complexity (시간 복잡도) 문제를 해결하는데 걸리는 시간과 입력의 관계를 가리킨다. \r\n즉, 입력값에 따라 연산을 실행할 때, 연산 횟수에 비해 얼마만큼의 시간이 걸리는가를 의미한다. \r\n시간복잡도를 고민한다는 것은 입력값이 커짐에 따라 증가하는 시간을 최소화한 알고리즘을 만들었다는 의미이기도 한다.\r\n시간복잡도는 Big-o 표기법을 사용해 나타낼 수 있다. \r\n출처 : 자바스크립트로하는 자료 구조와 알고리즘 *시간복잡도 순서 : 𝑂(1) < 𝑂(log n) < 𝑂(n) < 𝑂(n log n) < 𝑂(n²) < 𝑂(n³) < 𝑂(2ⁿ) < 𝑂(n!)  알고리즘 분석 시 가장 자주 등장하…","fields":{"slug":"/algorithm/2021-12-02-bigO/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 자바스크립트 빅오 표기법 (Big-O)","date":"December 02, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/algorithm/2021-11-28-algorithm/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"}}},{"node":{"id":"f5243214-9608-5785-91e5-e31a0bee570e","excerpt":"Description: Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. \r\n문자열s와 단어들로 이루어진 배열 wordDict가 주어질 때, \r\nwordDict내의 문자들로 문자열 s를 만들 수 있는지 구하는 문제 (구할 수 있다면 true 반환)\r\n동일한 단어를 여러번 사용해도 되고 사용하지 않아도 된다. Solution: 처음에는 관련 주제를 살펴보지 않고 set을 이용해서 일치하는 단어가 배열에 있다면 문자열 s를 지워나가는 식으로 풀었다. \r\n이렇게 풀면 wordBreak(‘cars’, [“car”,“ca”,“rs”])에서 배열의 “car”을 먼저 만단 문자열 s는 “s”만 남게 되어 false를 리턴했다. \r\n“ca”,“rs” 를 사용하면 효율적으로 …","fields":{"slug":"/algorithm/2021-11-28-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] LeetCode 139. Word Break ","date":"November 28, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/react/2021-11-25-mui-react/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-02-bigO/"}}},{"node":{"id":"105191c5-8116-5387-aa68-a56caa55848c","excerpt":"얼마전부터 사이드 프로젝트를 시작하였다. \r\n프로젝트 인원은 나포함 프론트엔드 개발자 2명, 백엔드 개발자 1명\r\n3명 다 디자인과는 거리가 먼 사람들이었다. \r\n사이드 프로젝트의 규모가 큰것도 아니라 디자이너를 구하기가 어려웠다. \r\n디자인적으로 어떻게 할 지 고민을 하다 필자가 사용해본 material ui의 Template를 보고 라이브러리 적용을 권유했고 다른 프론트엔드 개발자분이 사용에 OK해 프로젝트에 적용해 보기로 했다.\r\nPS. Material UI가 v5로 업데이트 되면서 MUI로 이름이 변경되었다. 처음에는 비슷한 사이트인지 알고 당황했으나 이름이 변경됐을 뿐! 😅\r\nMaterial-UI (MUI) 홈페이지 : https://mui.com/ 1. 설치하기 사용하기 전에 패키지를 설치해야 한다. \r\nnpm, yarn 을 이용하여 설치 가능하다. (기본설치) \r\nMaterial에서는 다양한 svg 아이콘도 제공한다. \r\nMaterial icons : https://m…","fields":{"slug":"/react/2021-11-25-mui-react/"},"frontmatter":{"categories":"react","title":"[react] Material ui 템플릿 (Mui) 으로 회원가입 페이지 만들기 ","date":"November 27, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/algorithm/2021-11-09-algorithm/"}},"previous":{"fields":{"slug":"/algorithm/2021-11-28-algorithm/"}}},{"node":{"id":"411cd371-09b1-543a-9dd7-742b2518cbfa","excerpt":"프로그래머스에서 자바스크립트 알고리즘 문제를 풀다보면 간간히 접하게 되는 수학관련 문제들이 있다.\r\n그 중 자연수와 관련된(약수, 소수, 최대공약수, 최소공배수) 문제들이 있었는데 이에 대한 이론을 정리하고 프로그래머스 코딩테스트 연습에 나오는 문제들을 풀어보면서 정확한 개념을 터득하고자 정리해 보았다. \r\n(문제 - 약수의 합, 약수의 개수와 덧셈, 소수 만들기, 소수 찾기, 최대공약수와 최소공배수, N개의 최소공배수)\r\n 1. 약수 약수란 무엇인가? \r\n    어떤 수를 나머지가 없이 나누어떨어지게 하는 수를 그 수의 약수라고 한다. \r\n    예를 들면 8을 1, 2, 4, 8로 나누면 나머지가 없다. 이때 1, 2, 4, 8을 8의 약수라고 한다. 1. 약수의 합   문제풀이 2. 약수의 개수와 덧셈  문제풀이 https://programmers.co.kr/learn/courses/30/lessons/77884?language=javascript\r\n 2. 소수 소수란 무엇인…","fields":{"slug":"/algorithm/2021-11-09-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 약수, 소수, 최대공약수, 최소공배수","date":"November 09, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/js/2021-10-30-var-let-const/"}},"previous":{"fields":{"slug":"/react/2021-11-25-mui-react/"}}},{"node":{"id":"3086922f-e7ce-500d-bdd6-c5a4d58b5ae8","excerpt":"var 선언한 변수의 문제점 ES6의 let과 const가 생기기 전에 변수를 선언할 수 있는 유일한 방법은 var를 사용하는 것이었다. var로 선언된 변수는 다른 언어와는 구별되는 독특한 특징을 가지고 있다.  1. 변수 중복 선언 허용 var 키워드로 선언한 변수는 중복 선언이 가능하다. 예제 1 var로 선언한 변수는 중복 선언이 가능하지만, 초기화문 유뮤에 따라 다르게 동작한다. 초기화문이 있는 변수 선언문은 기존 변수에 값을 재할당 하지만 초기화문이 없는 변수 선언문은 무시되고 에러가 발생하지 않는다.\r\n(여러명이 개발할때 다른 개발자가 동일한 이름의 변수를 초기화문으로 선언한다면 의도치않게 값이 변경될 수 있다.)  2. 함수 레벨 스코프 var 키워드로 선언한 변수는 함수내에서만 지역 스코프로 인정한다. 함수 밖에서 선언한 var 변수는 모두 전역 변수가 된다. 예제 2 위의 예제에서 변수 a와 i가 중복 선언되어 변수의 값이 의도치않게 변경되는 부작용이 발생했다. …","fields":{"slug":"/js/2021-10-30-var-let-const/"},"frontmatter":{"categories":"js","title":"[javascript] var, let, const","date":"October 31, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/react/2021-10-27-react-firebase/"}},"previous":{"fields":{"slug":"/algorithm/2021-11-09-algorithm/"}}},{"node":{"id":"61eb4493-0b25-509e-b662-e7673c19eef7","excerpt":"개인 포트폴리오 프로젝트 중 하나를 firebase를 이용하여 채팅앱을 만들었다. firebase를 이용하여 만들었으니 배포까지 해보자. google firebase에서 프로젝트를 만들어 앱에 연결된 상태이고 build까지 완료된 상태다.  1. CLI 설치 및 firebase 로그인 터미널 창에서 위 코드를 입력하고 로그인을 하면 가 뜨면 Y를 입력하고 구글 계정을 선택하여 로그인한다.  로그인이 완료되면 Success! 문구가 뜬다.\r\n  2. firebase 설정하기  이미 프로젝트를 생성했기 때문에 를 선택했다.   \r\n  → 미리 build한 폴더의 index.html파일을 사용하기 위해 build를 입력한다.  \r\n  → SPA일 경우 모든 url을 index.html으로 다시 작성하겠냐는 질문같은데 나는 리액트를 이용했기 때문에 Y를 입력했다.  \r\n  → 자동적으로 Github을 배포할거냐는 질문같은데 나는 N를 입력했다.  \r\n  → 이미 있는 index.html을…","fields":{"slug":"/react/2021-10-27-react-firebase/"},"frontmatter":{"categories":"react","title":"[react] firebase 프로젝트 배포하기","date":"October 27, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/gatsby/2021-10-26-gaysby/"}},"previous":{"fields":{"slug":"/js/2021-10-30-var-let-const/"}}},{"node":{"id":"70605e4b-9ae9-55b7-ac7f-73dee461bc72","excerpt":"최근 jekyll로 사용하던 블로그를 gatsby로 바꾸었다. \r\n처음에 jekyll을 선택했었던 이유를 github으로 시작할 생각이었고 테마가 다양했던 jekyll을 선택했었다. Jeykll에서 Gatsby로 이전한 이유는? 가장 큰 이유는 Jeykll은 Ruby로 만들어졌기 때문에 JS를 주언어로 사용하는 필자에게 어려우면서 생소했다. 프론트엔드 개발자가 많이 쓰는 gatsby는 react를 사용하는 나에게 쉬우면서도 재밌게 다가왔고 npm 플러그인을 쉽게 추가할 수 있어 다양한 기능을 다루기 수월했기 때문에 블로그 이전을 감행했다. (또한 전보다 많아진 테마도 마음에 들었다.) 나는 zoomkoding님의 zoomkoding-gatsby-blog테마를 사용하여 블로그를 개설했다. \r\n깃허브 테마는 심플한 테마가 많지만 zoomkoding님의 테마는 블랙/화이트 모드 선택 및 과하지 않게 동적인 요소들이 마음에 들어 이 테마로 블로그를 개설했다. Google Search Co…","fields":{"slug":"/gatsby/2021-10-26-gaysby/"},"frontmatter":{"categories":"gatsby","title":"[gatsby] Google Search Console과 Analytics 추가하기","date":"October 26, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/js/2021-09-21-closure/"}},"previous":{"fields":{"slug":"/react/2021-10-27-react-firebase/"}}},{"node":{"id":"df0e6802-9570-58ef-ab2f-62ac8e0a2d0c","excerpt":"사진 출처 : https://www.pinterest.co.kr/pin/439734351121493066/ 클로저(closure)는 자바스크립트 고유의 개념이 아니라 함수형 프로그래밍 언어에서 등장하는 보편적인 특성이다. 개념이 아니기 때문에 ECMAScript 명세서에도 클로저의 정의를 다루지 않고 있어 클로저에 대한 다양한 정의와 설명이 존재한다.  - 더글라스 크록포드 (자바스크립트 핵심 가이드)  >  - 에딘 브라운 (러닝 자바스크립트) >  - 존 레식 (자바스크립트 닌자 비급) >  - 송형주 고형준 (인사이드 자바스크립트) >  - 에릭 프리먼 (Head First Javascript programming) >  - 야마다 요시히로 (자바스크립트 마스터북) >  - 유인동 (함수형 자바스크립트 프로그래밍) >  - MDN >  이처럼 많은 설명과 정의가 존재하지만 막상 그 의미를 이해하기는 쉽지않다. MDN에서는  그림에서처럼 Outer내부에서 선언된 내부함수 Inn…","fields":{"slug":"/js/2021-09-21-closure/"},"frontmatter":{"categories":"js","title":"[javascript] closure (클로저)","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/js/2021-09-21-hoisting/"}},"previous":{"fields":{"slug":"/gatsby/2021-10-26-gaysby/"}}},{"node":{"id":"31a623e9-4be9-55fb-aa12-7f42e575f535","excerpt":"호이스팅(hoisting)이란 ‘끌어올리다’라는 의미의 hoist + ing를 붙여 만들어졌으며 의미 그대로 끌어올리는 행위로 작동한다. 주로 var로 선언된 변수의 선언문을 코드의 최상단으로 끌어올인다. (변수 정보를 수집하는 과정을 이해하기 쉬운 방법으로 대체한 가상의 개념으로, 자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주된다.) 호이스팅 실행컨텍스트에 담기는 LexicalEnvironment의 내부는 environmenRecord와 outer-EnvironmenReference로 구성되는데 environmenRecord는 호이스팅과 관련이 있다.  environmenRecord: 현재 컨텍스트와 관련된 코드의 식별자 정보를 순서대로 저장\r\n(식별자: 컨텍스트를 구성하는 함수에 지정된 매개변수, 함수자체, var로 선언된 변수의 식별자 등) 식별자 정보를 수집하는 과정을 마쳐도 코드가 실행되기 전이기 때문에 실행컨텍스트가 관여한 코드들은 실행되기 …","fields":{"slug":"/js/2021-09-21-hoisting/"},"frontmatter":{"categories":"js","title":"[javascript] hoisting (호이스팅)","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/js/2021-09-21-scope/"}},"previous":{"fields":{"slug":"/js/2021-09-21-closure/"}}},{"node":{"id":"4b841703-77c3-5374-8e6e-399a04efedc9","excerpt":"1. 실행 컨텍스트 실행 컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로 호이스팅, this 바인딩 등의 정보가 담긴다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보(Lexical Environmen)를 구성하고, this 값을 설정하는 등의 동작을 수행한다. 동일한 환경의 코드 실행 시 필요한 환경 정보를 모아 컨텍스트를 구성 콜 스택(call stack)에 쌓아올림 - 스택구조 컨텍스트와 관련있는 가장 위의 코드를 실행 (순서 보장)\r\n 흔히 실행 컨텍스트를 생성하는 방법은 함수를 실행하는 방법이다. (= 함수가 실행될 때 실행 컨텍스트가 만들어진다.) \r\n이미지 출처 : 코어 자바스크립트(정재남) 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 되며 콜스택에 담긴다. outer() 함수가 호출되면 자바스크립트 엔진이 outer에 대한 환경 정보를 수집해서…","fields":{"slug":"/js/2021-09-21-scope/"},"frontmatter":{"categories":"js","title":"[javascript] execution context, scope (실행 컨텍스트, 스코프)","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/js/2021-09-21-object/"}},"previous":{"fields":{"slug":"/js/2021-09-21-hoisting/"}}},{"node":{"id":"3dbed829-3b6e-5c83-9bb3-e9b4bd32cc40","excerpt":"1. assign() 앞서 설명했듯이 target에 pet1이 지정되어 있기때문에 target객체인 pet1에 변화가 생겼다. \r\n재귀적인 결합을 지원하지 않기때문에 description이 통째로 교체된다(birth → food)는 점에 주의한다.\r\n만약, sources객체들에 영향을 끼치고 싶지 않다면, 다음과 같이 target에 {}를 지정해주면 빈 객체에 sources객체를 결합한 값들을 반환한다.  2. create() 1, 2의 방법으로 생성된 객체는 Object의 인스턴스로써 Object의 기본 메서드를 계승하고 있다. (toString, valueOf등) Object.create메서드의 proto 인수에 null을 전달하면 Object의 프로토타입을 계승하지 않는 완전한 빈 객체를 만들 수 있다. (null이 전달되어 만들어진 객체는 toString, valueOf등의 메서드를 사용할 수 없다.) 위의 예제에서 configurable의 속성값을 true로 설정하였기 때…","fields":{"slug":"/js/2021-09-21-object/"},"frontmatter":{"categories":"js","title":"[javascript] Object.assign() & Object.create()","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/js/2021-09-21-scroll/"}},"previous":{"fields":{"slug":"/js/2021-09-21-scope/"}}},{"node":{"id":"1d4d7caa-526e-513b-b23b-584a3dfbda6a","excerpt":"마케팅이 활성화 되면서 원페이지 및 랜딩페이지의 수가 급증했다. 옛날의 웹페이지라고 하면 복잡하고 전문적인 느낌이었지만 최근에는 일반사용자도 쉽게 만들 수 있는 플랫폼이 많이 생기면서 그 수는 계속 증가하고 있다. 한페이지에 많은 내용들을 담다보면 스크롤이 길어지면서 집중력이 떨어지고 이탈률이 높아진다. 이탈률을 낮춰주는데 도움이 되는 기능 중 한가지가 바로 특정영역으로 스크롤을 이동시켜 원하는 부분에 집중할 수 있도록 해주는 것이다. 이 기능을 구현하는 대표적인 두 가지 방법은 a태그가 가지고 있는 anchor기능과 html 속성인 data를 활용하는 방법이다. a- anchor anchor란 사전적 의미로 을 뜻한다. 웹에서는 사용자가 지정한 부분에 닻을내려 특정 영역의 링크를 만드는 기능이라고 생각하면 쉬우며 주로 목차로 많이 사용한다. \r\nhtml태그만으로 쉽게 작성이 가능하다는 점에서 사용성이 좋다.  두번째는 url 주소에 #id명의 해쉬가 생성되는데 자바스크립트 his…","fields":{"slug":"/js/2021-09-21-scroll/"},"frontmatter":{"categories":"web","title":"[html] 특정 영역으로 스크롤 이동 - 앵커기능(anchor) vs data 속성","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/js/2021-09-21-function-prototype/"}},"previous":{"fields":{"slug":"/js/2021-09-21-object/"}}},{"node":{"id":"bb060842-ce54-548b-b285-0dd05e8eda41","excerpt":"자바스크립트는 원시타입(기본타입)과 참조타입으로 나뉜다. · 원시타입   Number  String  Boolean  undefined  null  원시타입을 제외한 모든값은 객체다.(즉, 참조타입은 객체다) 참조타입에는 원시타입을 제외한 모든타입, 배열, 함수, 정규표현식 등이 있다. 함수도 객체이기 때문에 값을 처리할 수 있으며 프로퍼티와 메서드도 가지고 있다. 함수는 객체 자바스크립트의 함수는 Function 객체이다. 함수가 객체라서 가지는 특징은 다음과 같으며 이러한 작업이 가능한 객체를 일급객체라고 한다. 함수는 변수나 프로퍼티나 배열 요소에 대입할 수 있다. 함수는 함수의 인수로 사용할 수 있다. 함수는 함수의 반환값으로 사용할 수 있다. 함수는 프로퍼티와 메서드를 가질 수 있다. 함수는 이름 없는 리터럴로 표현할 수 있다(익명함수). 함수는 동적으로 생성할 수 있다. 일급 객체인 함수는 일급함수라고도 한다. 함수의 프로퍼티(메서드) 함수는 Function 생성자의 p…","fields":{"slug":"/js/2021-09-21-function-prototype/"},"frontmatter":{"categories":"js","title":"[javascript] 함수의 call, apply, bind 메서드","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/react/2021-09-21-react-modal/"}},"previous":{"fields":{"slug":"/js/2021-09-21-scroll/"}}},{"node":{"id":"31dfdacc-113e-5d70-b9c0-1ae9d96cd239","excerpt":"프로젝트를 진행할 때마다 모달창을 마주치는 일이 많다. 프론트엔드 프레임워크나 라이브러리를 사용하면 편리성이나 시간을 아낄 수 있기때문에 npm에 등록된 모듈을 사용하곤 했지만, 만들어진 모듈이 아닌 직접 만들어 재사용해 보기로 했다.\r\n 어떻게 만들까?  재사용성 고려하기  Redux없이 만들기  함수형/클래스형 컴포넌트로 각각 만들기 1. 함수형으로 컴포넌트 만들기 -완성된 모습- img/modal-2.gif  *파일구조   재사용할 컴포넌트로 Modal.js 파일을 만들고, App.js에서 불러오도록 했다.  - CSS (함수형/클래스형 공통) - Modal.js - App.js  2. 클래스형으로 컴포넌트 만들기 - Modal.js (재사용 컴포넌트 - 자식) - App.js (부모 컴포넌트) 이로써 어디서든 Modal 컴포넌트를 가지고 와서 재사용할 수 있게 되었다. 모달은 워낙 기본적이고 중요한 부분은 아니라 만들어진 모듈을 사용할때가 많은데, 못만들어서 모듈을 이용하는…","fields":{"slug":"/react/2021-09-21-react-modal/"},"frontmatter":{"categories":"react","title":"[react] 모달 팝업창 만들기 (react modal)","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/web/2021-09-21-rwd-awd/"}},"previous":{"fields":{"slug":"/js/2021-09-21-function-prototype/"}}},{"node":{"id":"aeceb24e-2ab5-58d4-9af6-a88518abca34","excerpt":"퍼블리싱 프리랜서일을 할때면 자주 등장하는 용어가 바로 이란 단어다. 반응형이란 단어와 함께 언급되는 이란 단어도 있으며, 이 두 단어가 나올때마다 ‘도대체 무슨 차이지?’ 라는 의문도 따라온다. 퍼블리싱을 3년동안 했지만 반응형과 적응형의 차이에 대해 명확하게 설명하지 못하고 명확한 차이를 모른다고 생각됐기 때문에 이 두가지는 어떻게 다른지에 대해 알아보고자 조사하게 되었다.\r\n 반응형 vs 적응형  사진 출처 : https://uxplanet.org/ 1. 반응형: RWD(Responsive Web Design) *웹의 해상도, 레이아웃 등이 디바이스에 따라 반응하여 유동적으로 변환되는 웹페이지 \r\n과거의 웹을 사용하는 주요기기는 컴퓨터였으며, 모니터에 맞춰 화면의 크기와 레이아웃이 구성되었다. 2007년 애플사에서 아이폰을 출시하면서 스마트폰의 시대가 열렸고, 어디서든 손쉽게 웹사이트에 접근할 수 있게 되었다. 하지만 아래의 사진처럼 문제가 발생하였다. \r\n 바로 손바닥만한 …","fields":{"slug":"/web/2021-09-21-rwd-awd/"},"frontmatter":{"categories":"web","title":"[web] 반응형(RWD)웹과 적응형(AWD)웹","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/js/2021-09-21-javascript-object/"}},"previous":{"fields":{"slug":"/react/2021-09-21-react-modal/"}}},{"node":{"id":"318d046f-01d7-5038-a11e-a357f1ac046c","excerpt":"는 블록 스코프이며, 변수의 재선언 및 재할당이 모두 불가능하다.\r\n흔히 여기서 오는 오해 중 하나가 const로 정의하면 객체 속성값도 수정할 수 없다고 생각하지만, const로 정의해도 객체의 내부 속성값은 수정이 가능하다. (객체를 참조하는 변수를 수정하는 것은 불가능 하다.) - JS 객체에서 이미 존재하는 속성값을 수정하거나 새로운 값을 추가하는 것은 모두 가능하다. 객체의 내부 속성값을 수정하지 못하게 하고 싶다면 유명한 불변성 패키지인 immer.js, immutable.js 등을 사용하면 된다. (immer.js는 리액트에서도 많이이 쓰이기 때문에 알아두면 좋다.) 이러한 패키지들은 기존 객체를 수정하지 않고 새롭게 객체를 생성한다.\r\n 다음의 JS내장 함수는 불변성 외부 패키지에서 새롭게 객체를 생성하는 편의성은 필요 없고 수정만 할 수 없도록 만들고 싶을 때 사용하면 유용하다. Object.preventExtensions Object.seal Object.free…","fields":{"slug":"/js/2021-09-21-javascript-object/"},"frontmatter":{"categories":"js","title":"[javascript] 객체 수정 제어 : preventExtensions(), seal(), freeze()","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/html/2021-09-21-sematic-tag/"}},"previous":{"fields":{"slug":"/web/2021-09-21-rwd-awd/"}}},{"node":{"id":"9a15b1d4-0bd2-5c6e-94f6-622a033c016f","excerpt":"“HTML is the World Wide Web’s core markup language. Originally, HTML was primarily designed as a language for semantically describing scientific documents.”  > - “HTML은 World Wide Web의 핵심 markup 언어이다. 원래 HTML은 과학적인 문서를 로 설계되었다.” \r\n“Elements, attributes, and attribute values in HTML are defined (by this specification) to have certain meanings (semantics)”\r\n- “HTML의 요소와 속성 및 속성 값은 되었다.”  Semantic Tag 시맨틱 태그란? 흔히들 HTML5 시대에서 가장 큰 변화는 시맨틱 태그라고 말한다. semantic은 사전적인 의미로 ‘의미의, 의미론적인’라는 의미를 가지고 있다.\r\nHTM…","fields":{"slug":"/html/2021-09-21-sematic-tag/"},"frontmatter":{"categories":"web","title":"[html] Semantic Tag Layout (시맨틱 태그)","date":"September 21, 2021","emoji":"📓"}},"next":{"fields":{"slug":"/vue/2021-09-21-vue-clap-button/"}},"previous":{"fields":{"slug":"/js/2021-09-21-javascript-object/"}}},{"node":{"id":"0860351f-ad60-54ee-8a15-3b0dc2968ce1","excerpt":"새로운 vue 프로젝트 사전미팅에서 장바구니에 담기는 액션을 부탁받았었다.\r\n\r\n출처 : react clap button\r\n 이런 방식으로 장바구니에 담기는 액션을 부탁받았는데, 아직 vue가 미숙한 나는 어떻게 코딩해야 할지 큰 고민에 빠졌었다. 어떻게 만들까? 1. npm에서 타인이 만든걸 사용할까? npm에서 clap button을 검색하여 위의 박수치는 액션을 찾았다. 정말 딱 내가 원하던 액션이었고 클라이언트가 보여준 액션과도 거의 흡사했다. ‘Wow! 딱 원하던거야! 역시 npm 최고! 내가 생각하는건 이미 남이 만들어 놨을줄 알았다니까? 가만히 보자… 어라? 그런데 이건 react잖아? 😥 아니야! 실망하긴 이르지!! react가 있으면 vue도 있을거야!’ 라는 생각으로 바로 npm 검색을 했고 vue clap button을 찾았다. ‘역시! react가 있으면 vue도 있었어!’ 흡족한 마음으로 테스트용 프로젝트에 모듈을 설치해보았다.\r\n그런데 내가 원하던 액션이 …","fields":{"slug":"/vue/2021-09-21-vue-clap-button/"},"frontmatter":{"categories":"vue","title":"[vue] 박수치기 버튼 만들기 (vue clap button)","date":"September 21, 2021","emoji":"📓"}},"next":null,"previous":{"fields":{"slug":"/html/2021-09-21-sematic-tag/"}}}],"categories":["All","diary","web","react","js","redux","git","css","algorithm","gatsby","vue"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}