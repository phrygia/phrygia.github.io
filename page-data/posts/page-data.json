{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts",
    "result": {"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"08bf8942-8114-5fed-8627-ea9b9c2b3c25","excerpt":"scss의 @for를 이용하면 반복적인 구문을 쉽게 처리할 수있다. \r\n인강에선 @for ~ through로 설명을 했는데 vs코드의 자동완성 코드는 @for ~ to였다. \r\n어떤 차이점이 있는걸까? @for 기본 사용법  $var : 변수명 \r\n<start> : 시작하는 숫자와 \r\n<end> : 끝나는 숫자  for ~ through end로 지장한 숫자까지 반복 for ~ to end로 지장한 숫자-1까지 반복 솔직히 to가 왜있는지 모르겠다 😅 \r\nscss가 자바스크립트랑 비슷한 개념이 많다보니까 js for문의 0인덱스에 익숙한 개발자들을 위해서 나온걸까? \r\n나는 주로 through를 이용해서 코딩하는 습관을 길러야겠다. \r\n(to / through를 동시다발적으로 사용하면 나중에 리뷰할 때 헷갈릴 것 같다.) @for 기본 사용법 for ~ through for ~ to","fields":{"slug":"/css/2022-02-06-scss-for/"},"frontmatter":{"categories":"css","title":"[scss] @for ~ through / to 차이점","date":"February 06, 2022"}},"next":{"fields":{"slug":"/react/2022-01-27-styled-components/"}},"previous":null},{"node":{"id":"c1e9ea31-ac56-5a66-8c15-21cba66d9c96","excerpt":"react를 배우던 초창기에는 를 일일히 써주면서 코딩했던 기억이 있다. \r\n사이드 프로젝트에서 styled-components를 사용하고 있는데 저 코드를 일일히 썼을 때 디자이너분이 사이즈의 기준을 바꾸거나 하 코딩한 모든 컴포넌트를 수정해야 한다. \r\nreact로 여러가지 개인 프로젝트나 팀 프로젝트를 진행해보았기 때문에 저런 하드코딩적인 느낌을 지우고 싶었다. \r\nstyled-components에는 라는 속성을 사용해 공통으로 스타일을 관리해 줄 수 있다고 한다.  ThemeProvider Context API를 기반으로 작동하기 때문에 ThemeProvider로 감싸진 모든 하위 컴포넌트들은 전달받은 theme를 props로 사용할 수 있다.\r\n*특히 color사용에 좋다 → 프로젝트를 진행하면서 메인컬러가 바뀌는 경우가 있는데 모든 컴포넌트를 수정하는건 너무 비효율적이다. /assets/style/theme.js App.js (또는 index.js) theme 사용하기 …","fields":{"slug":"/react/2022-01-27-styled-components/"},"frontmatter":{"categories":"react","title":"[react] styled-components 반응형 스타일 설정하기","date":"January 27, 2022"}},"next":{"fields":{"slug":"/web/2022-01-02-aws/"}},"previous":{"fields":{"slug":"/css/2022-02-06-scss-for/"}}},{"node":{"id":"7b6176e2-a2b6-5d49-bce6-c93ccba969d3","excerpt":"맥을 사용하면 터미널로 쉽게 접속이 가능하지만 윈도우로는 터미널 만으로는 ec2 서버에 접속할 수 없다. \r\n(사실 맥을 주로 이용해서 윈도우는 안된다는 걸 몰랐었는데 집에있는 데스크탑으로 접속하려니 안되서 찾아보니 PuTTY를 이용하라 카더라..) 먼저 자신의 window 환경에 맞는 파일을 다운받는다. PuTTY 다운로드  msi 파일을 설치하면 PuTTY.exe 와 PuTTYgen.exe 2개의 파일이 설치된다. PuTTYgen.exe 실행  asw에서 인스턴스를 생성하면서 만들었던 pem 키를 Load한다.  Save private key를 눌러 .ppk 파일을 생성한다.  PuTTY.exe 실행 카테고리 Session에서 Host Name을 설정한다. Host Name은 aws ec2 인스턴스에 연결 페이지에서 확인할 수 있다. \r\n 카테고리 Connection → SSH → Auth를 선택하고 PuTTYgen으로 만들었더 ppk 파일을 추가한다.  다시 Sesstion으…","fields":{"slug":"/web/2022-01-02-aws/"},"frontmatter":{"categories":"web","title":"[aws] PuTTY로 윈도우에서 aws ec2 ssh 접속하기","date":"January 02, 2022"}},"next":{"fields":{"slug":"/react/2021-12-22-react-redux-persist/"}},"previous":{"fields":{"slug":"/react/2022-01-27-styled-components/"}}},{"node":{"id":"620552dc-6b94-58ce-a0b0-063d7dd4489c","excerpt":"현재 진행하고 있는 팀프로젝트에서 rudux와 redux-saga를 사용하고 있다. \r\n나 외에도 프론트엔드분이 한분 계신데 store에 어떻게 저장할까 하다가 를 사용해 보고 싶어 제안해 보았고 동의해 주셔서 redux-persist를 사용하기로 하였다. redux-persist란 ? react에서 많이 사용하고 있는 redux는 상태관리로 유명한 라이브러리다. 하나의 store에서 데이터를 관리하면서 상태를 예측가능하게 만들고 유지보수 및 디버깅에 유리하기때문에 순수 js 및 js 라이브러리 및 프레임워크에서 많이 사용한다. \r\n하지만 새로고침을 하면 store의 데이터가 날아가기 때문에, 새로고침을 해도 상태를 유지시키는 기능을 구현해야 한다.\r\n대표적으로 브라우저의 localStorage나 sessionStorage를 이용한 방법이 있는데 직접 코드를 작성해야 하고, store의 데이터가 많아지수록 코드가 복잡해진다는 단점이 있다.  redux-persist는 localst…","fields":{"slug":"/react/2021-12-22-react-redux-persist/"},"frontmatter":{"categories":"react","title":"[react] react프로젝트에 redux-persist 적용하기","date":"December 22, 2021"}},"next":{"fields":{"slug":"/algorithm/2021-12-14-codility/"}},"previous":{"fields":{"slug":"/web/2022-01-02-aws/"}}},{"node":{"id":"d8e3183f-c223-5246-b26d-39add6066c1e","excerpt":"문제 : codilit MissingInteger \r\nN개의 정수로 이루어진 배열 A가 있다. A에 존재하지 않는 가장 작은 양의 정수를 반환하는 함수를 작성하는 문제이다.\r\n(0보다 큰 양의 정수를 반환해야 한다.)\r\n예를들어, 배열 A가 [−1, −3]으로 주어졌을때 0보다 큰 1이 반환되어야 한다.\r\n Solution: 처음 내가 푼 코드는 이렇다.\r\n배열 A를 순서대로 정렬하고 1부터 A의 가장큰수로 채워진 새로운 배열 arr을 만든다. \r\n그리고 존재하는 값을 확인하기 위해 Set을 사용하여 arr의 값을 복사한다. (indexOf를 사용하면 시간측정이 길어졌기 때문에 Set을 사용했다.)\r\nfor문으로 A의 배열을 돌면서 set에 값이 있는지 체크하고 있다면 delete 메소드로 삭제한다.  남아있는 배열의 개수가 0개라면 A = [1,2,3] 처럼 순서대로 채워진 배열이라는 뜻이기 때문에 3보다 큰 4를 리턴하기 위해 배열의 마지막 원소보다 1이 큰 수를 리턴한다. \r…","fields":{"slug":"/algorithm/2021-12-14-codility/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] Codility Lesson 4. MissingInteger","date":"December 14, 2021"}},"next":{"fields":{"slug":"/gatsby/2021-12-12-gaysby/"}},"previous":{"fields":{"slug":"/react/2021-12-22-react-redux-persist/"}}},{"node":{"id":"cb27b642-67dc-507b-8588-e8da7dfd36e7","excerpt":"최근 비전공자를 위한 개발자 취업 인강을 듣고 있다. 그곳에서 TIL에 대한 용어를 처음 알게되었다.  TIL ? TIL이란 의 약자로 오늘 내가 배운것이라는 뜻이다. \r\n한국에서는 개발자들 사이에서 많이 쓰이는 용어이지만 외국에서는 SNS상에서 자주 쓰이는 약어라고 한다. \r\n개발자들은 자신의 기술 블로그를 운영하기 때문에 TIL을 따로 운영하지는 분들은 많지 않은것 같다.\r\n(어떻게 생각하면 기술 블로그 = TIL과 비슷한 느낌이랄까.. 🤔)  나는 기술블로그를 운영하지고 있지만 많은 포스팅을 올리지 못하고 있기 때문에 TIL 페이지를 따로 생성할 지 고민을 했다.\r\nTIL을 자기가 배운 내용을 매일 하나씩 쌓으면서 만드는 나만의 지식 사전으로 생각해 보기로 했다. \r\n추후에 동일한 문제가 발생하였을때 해결하지 못한다면 자기반성 및 습득하지 못한 지식을 정리하기에 도움이 될 것 같았기 때문에 TIL 페이지를 생성하기로 결정하였다. TIL 참고 예시 진유림(milooy)님의 TI…","fields":{"slug":"/gatsby/2021-12-12-gaysby/"},"frontmatter":{"categories":"gatsby js","title":"[gatsby] gaysby로 TIL만들기","date":"December 12, 2021"}},"next":{"fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-14-codility/"}}},{"node":{"id":"05fa32d6-d0e0-512f-8858-acd2eb984eac","excerpt":"정렬된 배열에서 요소를 찾는 것이 정렬되지 않는 배열에서 찾는 것보다 빠르고 쉽다. \r\n정렬 알고리즘을 사용해 메모리에서 배열을 정렬하거나 정렬된 배열을 파일에 기록할 수 있다. ArrayList함수를 만들어 정렬/검색 대상 데이터를 저장한다.\r\n(각 알고리즘에 대한 설명은 검색하면 너무 자세하게 나와있기 때문에 코드 위주의 포스팅을 했다.) 1. 버블정렬 가장 간단한 정렬 알고리즘이다. \r\n버블정렬은 전체 배열을 순회하면서 인접한 두 원소를 비교하고 그 결과에 따라 두 원소의 위치를 서로 바꾼다. \r\n버블정렬은 모든 값을 비교하기 때문에 정렬 알고리즘들 중에서 가장 최악이라고 할 수 있다. 2. 삽입정렬 배열의 모든 요소를 앞에서부터 차례대로 검색하면서 정렬된 요소와 비교한다. \r\n정렬되지 않은 요소들을 배열의 자신의 위치를 찾아 이동(삽입)시킨다.\r\n(두번째 요소부터 정렬을 시작한다.) 3. 선택정렬 가장 작은 요소를 찾아서(선택해서) 해당 요소를 배열의 현 위치에 삽입하는 방…","fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 정렬 알고리즘 - 버블, 삽입, 선택, 병합, 퀵","date":"December 07, 2021"}},"next":{"fields":{"slug":"/algorithm/2021-12-02-bigO/"}},"previous":{"fields":{"slug":"/gatsby/2021-12-12-gaysby/"}}},{"node":{"id":"b7ec90cf-e14c-5f98-937b-510823c48099","excerpt":"알고리즘을 구현하기 전에 알고리즘이 얼마나 효과적인지 분석하는 법을 이해해야 한다.\r\n알고리즘을 구현할 때 빅오 표기법이 해당 알고리즘이 얼마나 효율적인지를 나타내기 때문에 빅오 표기법은 중요하다.\r\n효율적인 방법을 고민한다는 것은 시간 복잡도를 고민한다는 것과 같은 말이다. \r\n Time Complexity (시간 복잡도) 문제를 해결하는데 걸리는 시간과 입력의 관계를 가리킨다. \r\n즉, 입력값에 따라 연산을 실행할 때, 연산 횟수에 비해 얼마만큼의 시간이 걸리는가를 의미한다. \r\n시간복잡도를 고민한다는 것은 입력값이 커짐에 따라 증가하는 시간을 최소화한 알고리즘을 만들었다는 의미이기도 한다.\r\n시간복잡도는 Big-o 표기법을 사용해 나타낼 수 있다. \r\n출처 : 자바스크립트로하는 자료 구조와 알고리즘 *시간복잡도 순서 : 𝑂(1) < 𝑂(log n) < 𝑂(n) < 𝑂(n log n) < 𝑂(n²) < 𝑂(n³) < 𝑂(2ⁿ) < 𝑂(n!)  알고리즘 분석 시 가장 자주 등장하…","fields":{"slug":"/algorithm/2021-12-02-bigO/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 자바스크립트 빅오 표기법 (Big-O)","date":"December 02, 2021"}},"next":{"fields":{"slug":"/algorithm/2021-11-28-algorithm/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"}}},{"node":{"id":"dc92eaf2-21cd-5f23-84cc-1077ad5cf71a","excerpt":"Description: Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. \r\n문자열s와 단어들로 이루어진 배열 wordDict가 주어질 때, \r\nwordDict내의 문자들로 문자열 s를 만들 수 있는지 구하는 문제 (구할 수 있다면 true 반환)\r\n동일한 단어를 여러번 사용해도 되고 사용하지 않아도 된다. Solution: 처음에는 관련 주제를 살펴보지 않고 set을 이용해서 일치하는 단어가 배열에 있다면 문자열 s를 지워나가는 식으로 풀었다. \r\n이렇게 풀면 wordBreak(‘cars’, [“car”,“ca”,“rs”])에서 배열의 “car”을 먼저 만단 문자열 s는 “s”만 남게 되어 false를 리턴했다. \r\n“ca”,“rs” 를 사용하면 효율적으로 …","fields":{"slug":"/algorithm/2021-11-28-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] LeetCode 139. Word Break ","date":"November 28, 2021"}},"next":{"fields":{"slug":"/react/2021-11-25-mui-react/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-02-bigO/"}}},{"node":{"id":"23d6e1fe-c33e-525c-a257-47075559c166","excerpt":"얼마전부터 사이드 프로젝트를 시작하였다. \r\n프로젝트 인원은 나포함 프론트엔드 개발자 2명, 백엔드 개발자 1명\r\n3명 다 디자인과는 거리가 먼 사람들이었다. \r\n사이드 프로젝트의 규모가 큰것도 아니라 디자이너를 구하기가 어려웠다. \r\n디자인적으로 어떻게 할 지 고민을 하다 필자가 사용해본 material ui의 Template를 보고 라이브러리 적용을 권유했고 다른 프론트엔드 개발자분이 사용에 OK해 프로젝트에 적용해 보기로 했다.\r\nPS. Material UI가 v5로 업데이트 되면서 MUI로 이름이 변경되었다. 처음에는 비슷한 사이트인지 알고 당황했으나 이름이 변경됐을 뿐! 😅\r\nMaterial-UI (MUI) 홈페이지 : https://mui.com/ 1. 설치하기 사용하기 전에 패키지를 설치해야 한다. \r\nnpm, yarn 을 이용하여 설치 가능하다. (기본설치) \r\nMaterial에서는 다양한 svg 아이콘도 제공한다. \r\nMaterial icons : https://m…","fields":{"slug":"/react/2021-11-25-mui-react/"},"frontmatter":{"categories":"react","title":"[react] Material ui 템플릿 (Mui) 으로 회원가입 페이지 만들기 ","date":"November 27, 2021"}},"next":{"fields":{"slug":"/algorithm/2021-11-09-algorithm/"}},"previous":{"fields":{"slug":"/algorithm/2021-11-28-algorithm/"}}},{"node":{"id":"bcd13f8c-af03-5507-a84d-c8d4277b7afb","excerpt":"프로그래머스에서 자바스크립트 알고리즘 문제를 풀다보면 간간히 접하게 되는 수학관련 문제들이 있다.\r\n그 중 자연수와 관련된(약수, 소수, 최대공약수, 최소공배수) 문제들이 있었는데 이에 대한 이론을 정리하고 프로그래머스 코딩테스트 연습에 나오는 문제들을 풀어보면서 정확한 개념을 터득하고자 정리해 보았다. \r\n(문제 - 약수의 합, 약수의 개수와 덧셈, 소수 만들기, 소수 찾기, 최대공약수와 최소공배수, N개의 최소공배수)\r\n 1. 약수 약수란 무엇인가? \r\n    어떤 수를 나머지가 없이 나누어떨어지게 하는 수를 그 수의 약수라고 한다. \r\n    예를 들면 8을 1, 2, 4, 8로 나누면 나머지가 없다. 이때 1, 2, 4, 8을 8의 약수라고 한다. 1. 약수의 합   문제풀이 2. 약수의 개수와 덧셈  문제풀이 https://programmers.co.kr/learn/courses/30/lessons/77884?language=javascript\r\n 2. 소수 소수란 무엇인…","fields":{"slug":"/algorithm/2021-11-09-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 약수, 소수, 최대공약수, 최소공배수","date":"November 09, 2021"}},"next":{"fields":{"slug":"/js/2021-10-30-var-let-const/"}},"previous":{"fields":{"slug":"/react/2021-11-25-mui-react/"}}},{"node":{"id":"375f018a-e682-58d1-8d2e-c18fd7895823","excerpt":"var 선언한 변수의 문제점 ES6의 let과 const가 생기기 전에 변수를 선언할 수 있는 유일한 방법은 var를 사용하는 것이었다. var로 선언된 변수는 다른 언어와는 구별되는 독특한 특징을 가지고 있다.  1. 변수 중복 선언 허용 var 키워드로 선언한 변수는 중복 선언이 가능하다. 예제 1 var로 선언한 변수는 중복 선언이 가능하지만, 초기화문 유뮤에 따라 다르게 동작한다. 초기화문이 있는 변수 선언문은 기존 변수에 값을 재할당 하지만 초기화문이 없는 변수 선언문은 무시되고 에러가 발생하지 않는다.\r\n(여러명이 개발할때 다른 개발자가 동일한 이름의 변수를 초기화문으로 선언한다면 의도치않게 값이 변경될 수 있다.)  2. 함수 레벨 스코프 var 키워드로 선언한 변수는 함수내에서만 지역 스코프로 인정한다. 함수 밖에서 선언한 var 변수는 모두 전역 변수가 된다. 예제 2 위의 예제에서 변수 a와 i가 중복 선언되어 변수의 값이 의도치않게 변경되는 부작용이 발생했다. …","fields":{"slug":"/js/2021-10-30-var-let-const/"},"frontmatter":{"categories":"js","title":"[javascript] var, let, const","date":"October 31, 2021"}},"next":{"fields":{"slug":"/react/2021-10-27-react-firebase/"}},"previous":{"fields":{"slug":"/algorithm/2021-11-09-algorithm/"}}},{"node":{"id":"1d0a7e6f-2a16-5890-b39c-3e78e7fbab07","excerpt":"개인 포트폴리오 프로젝트 중 하나를 firebase를 이용하여 채팅앱을 만들었다. firebase를 이용하여 만들었으니 배포까지 해보자. google firebase에서 프로젝트를 만들어 앱에 연결된 상태이고 build까지 완료된 상태다.  1. CLI 설치 및 firebase 로그인 터미널 창에서 위 코드를 입력하고 로그인을 하면 가 뜨면 Y를 입력하고 구글 계정을 선택하여 로그인한다.  로그인이 완료되면 Success! 문구가 뜬다.\r\n  2. firebase 설정하기  이미 프로젝트를 생성했기 때문에 를 선택했다.   \r\n  → 미리 build한 폴더의 index.html파일을 사용하기 위해 build를 입력한다.  \r\n  → SPA일 경우 모든 url을 index.html으로 다시 작성하겠냐는 질문같은데 나는 리액트를 이용했기 때문에 Y를 입력했다.  \r\n  → 자동적으로 Github을 배포할거냐는 질문같은데 나는 N를 입력했다.  \r\n  → 이미 있는 index.html을…","fields":{"slug":"/react/2021-10-27-react-firebase/"},"frontmatter":{"categories":"react","title":"[react] firebase 프로젝트 배포하기","date":"October 27, 2021"}},"next":{"fields":{"slug":"/gatsby/2021-10-26-gaysby/"}},"previous":{"fields":{"slug":"/js/2021-10-30-var-let-const/"}}},{"node":{"id":"9b8ad425-68b0-569c-94ec-efae9509256b","excerpt":"최근 jekyll로 사용하던 블로그를 gatsby로 바꾸었다. \r\n처음에 jekyll을 선택했었던 이유를 github으로 시작할 생각이었고 테마가 다양했던 jekyll을 선택했었다. Jeykll에서 Gatsby로 이전한 이유는? 가장 큰 이유는 Jeykll은 Ruby로 만들어졌기 때문에 JS를 주언어로 사용하는 필자에게 어려우면서 생소했다. 프론트엔드 개발자가 많이 쓰는 gatsby는 react를 사용하는 나에게 쉬우면서도 재밌게 다가왔고 npm 플러그인을 쉽게 추가할 수 있어 다양한 기능을 다루기 수월했기 때문에 블로그 이전을 감행했다. (또한 전보다 많아진 테마도 마음에 들었다.) 나는 zoomkoding님의 zoomkoding-gatsby-blog테마를 사용하여 블로그를 개설했다. \r\n깃허브 테마는 심플한 테마가 많지만 zoomkoding님의 테마는 블랙/화이트 모드 선택 및 과하지 않게 동적인 요소들이 마음에 들어 이 테마로 블로그를 개설했다. Google Search Co…","fields":{"slug":"/gatsby/2021-10-26-gaysby/"},"frontmatter":{"categories":"gatsby","title":"[gatsby] Google Search Console과 Analytics 추가하기","date":"October 26, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-closure/"}},"previous":{"fields":{"slug":"/react/2021-10-27-react-firebase/"}}},{"node":{"id":"f835b33d-e905-5c2c-a1b9-41b3ad103ea3","excerpt":"사진 출처 : https://www.pinterest.co.kr/pin/439734351121493066/ 클로저(closure)는 자바스크립트 고유의 개념이 아니라 함수형 프로그래밍 언어에서 등장하는 보편적인 특성이다. 개념이 아니기 때문에 ECMAScript 명세서에도 클로저의 정의를 다루지 않고 있어 클로저에 대한 다양한 정의와 설명이 존재한다.  - 더글라스 크록포드 (자바스크립트 핵심 가이드)  >  - 에딘 브라운 (러닝 자바스크립트) >  - 존 레식 (자바스크립트 닌자 비급) >  - 송형주 고형준 (인사이드 자바스크립트) >  - 에릭 프리먼 (Head First Javascript programming) >  - 야마다 요시히로 (자바스크립트 마스터북) >  - 유인동 (함수형 자바스크립트 프로그래밍) >  - MDN >  이처럼 많은 설명과 정의가 존재하지만 막상 그 의미를 이해하기는 쉽지않다. MDN에서는  그림에서처럼 Outer내부에서 선언된 내부함수 Inn…","fields":{"slug":"/js/2021-09-21-closure/"},"frontmatter":{"categories":"js","title":"[javascript] closure (클로저)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-hoisting/"}},"previous":{"fields":{"slug":"/gatsby/2021-10-26-gaysby/"}}},{"node":{"id":"4a59f89a-d57e-5f0b-affa-b5fd9a6a3324","excerpt":"호이스팅(hoisting)이란 ‘끌어올리다’라는 의미의 hoist + ing를 붙여 만들어졌으며 의미 그대로 끌어올리는 행위로 작동한다. 주로 var로 선언된 변수의 선언문을 코드의 최상단으로 끌어올인다. (변수 정보를 수집하는 과정을 이해하기 쉬운 방법으로 대체한 가상의 개념으로, 자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주된다.) 호이스팅 실행컨텍스트에 담기는 LexicalEnvironment의 내부는 environmenRecord와 outer-EnvironmenReference로 구성되는데 environmenRecord는 호이스팅과 관련이 있다.  environmenRecord: 현재 컨텍스트와 관련된 코드의 식별자 정보를 순서대로 저장\r\n(식별자: 컨텍스트를 구성하는 함수에 지정된 매개변수, 함수자체, var로 선언된 변수의 식별자 등) 식별자 정보를 수집하는 과정을 마쳐도 코드가 실행되기 전이기 때문에 실행컨텍스트가 관여한 코드들은 실행되기 …","fields":{"slug":"/js/2021-09-21-hoisting/"},"frontmatter":{"categories":"js","title":"[javascript] hoisting (호이스팅)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-scope/"}},"previous":{"fields":{"slug":"/js/2021-09-21-closure/"}}},{"node":{"id":"96fa0de2-d973-53f9-bf99-db6753a37dfd","excerpt":"1. 실행 컨텍스트 실행 컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로 호이스팅, this 바인딩 등의 정보가 담긴다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보(Lexical Environmen)를 구성하고, this 값을 설정하는 등의 동작을 수행한다. 동일한 환경의 코드 실행 시 필요한 환경 정보를 모아 컨텍스트를 구성 콜 스택(call stack)에 쌓아올림 - 스택구조 컨텍스트와 관련있는 가장 위의 코드를 실행 (순서 보장)\r\n 흔히 실행 컨텍스트를 생성하는 방법은 함수를 실행하는 방법이다. (= 함수가 실행될 때 실행 컨텍스트가 만들어진다.) \r\n이미지 출처 : 코어 자바스크립트(정재남) 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 되며 콜스택에 담긴다. outer() 함수가 호출되면 자바스크립트 엔진이 outer에 대한 환경 정보를 수집해서…","fields":{"slug":"/js/2021-09-21-scope/"},"frontmatter":{"categories":"js","title":"[javascript] execution context, scope (실행 컨텍스트, 스코프)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-object/"}},"previous":{"fields":{"slug":"/js/2021-09-21-hoisting/"}}},{"node":{"id":"8f974467-e2b0-5c6a-a898-7bd5fa457d36","excerpt":"1. assign() 앞서 설명했듯이 target에 pet1이 지정되어 있기때문에 target객체인 pet1에 변화가 생겼다. \r\n재귀적인 결합을 지원하지 않기때문에 description이 통째로 교체된다(birth → food)는 점에 주의한다.\r\n만약, sources객체들에 영향을 끼치고 싶지 않다면, 다음과 같이 target에 {}를 지정해주면 빈 객체에 sources객체를 결합한 값들을 반환한다.  2. create() 1, 2의 방법으로 생성된 객체는 Object의 인스턴스로써 Object의 기본 메서드를 계승하고 있다. (toString, valueOf등) Object.create메서드의 proto 인수에 null을 전달하면 Object의 프로토타입을 계승하지 않는 완전한 빈 객체를 만들 수 있다. (null이 전달되어 만들어진 객체는 toString, valueOf등의 메서드를 사용할 수 없다.) 위의 예제에서 configurable의 속성값을 true로 설정하였기 때…","fields":{"slug":"/js/2021-09-21-object/"},"frontmatter":{"categories":"js","title":"[javascript] Object.assign() & Object.create()","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-scroll/"}},"previous":{"fields":{"slug":"/js/2021-09-21-scope/"}}},{"node":{"id":"ec49afed-c723-5675-b33b-2a424308a24a","excerpt":"마케팅이 활성화 되면서 원페이지 및 랜딩페이지의 수가 급증했다. 옛날의 웹페이지라고 하면 복잡하고 전문적인 느낌이었지만 최근에는 일반사용자도 쉽게 만들 수 있는 플랫폼이 많이 생기면서 그 수는 계속 증가하고 있다. 한페이지에 많은 내용들을 담다보면 스크롤이 길어지면서 집중력이 떨어지고 이탈률이 높아진다. 이탈률을 낮춰주는데 도움이 되는 기능 중 한가지가 바로 특정영역으로 스크롤을 이동시켜 원하는 부분에 집중할 수 있도록 해주는 것이다. 이 기능을 구현하는 대표적인 두 가지 방법은 a태그가 가지고 있는 anchor기능과 html 속성인 data를 활용하는 방법이다. a- anchor anchor란 사전적 의미로 을 뜻한다. 웹에서는 사용자가 지정한 부분에 닻을내려 특정 영역의 링크를 만드는 기능이라고 생각하면 쉬우며 주로 목차로 많이 사용한다. \r\nhtml태그만으로 쉽게 작성이 가능하다는 점에서 사용성이 좋다.  두번째는 url 주소에 #id명의 해쉬가 생성되는데 자바스크립트 his…","fields":{"slug":"/js/2021-09-21-scroll/"},"frontmatter":{"categories":"web","title":"[html] 특정 영역으로 스크롤 이동 - 앵커기능(anchor) vs data 속성","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-function-prototype/"}},"previous":{"fields":{"slug":"/js/2021-09-21-object/"}}},{"node":{"id":"044386b4-8ee5-5857-b242-6f2a7509c80a","excerpt":"자바스크립트는 원시타입(기본타입)과 참조타입으로 나뉜다. · 원시타입   Number  String  Boolean  undefined  null  원시타입을 제외한 모든값은 객체다.(즉, 참조타입은 객체다) 참조타입에는 원시타입을 제외한 모든타입, 배열, 함수, 정규표현식 등이 있다. 함수도 객체이기 때문에 값을 처리할 수 있으며 프로퍼티와 메서드도 가지고 있다. 함수는 객체 자바스크립트의 함수는 Function 객체이다. 함수가 객체라서 가지는 특징은 다음과 같으며 이러한 작업이 가능한 객체를 일급객체라고 한다. 함수는 변수나 프로퍼티나 배열 요소에 대입할 수 있다. 함수는 함수의 인수로 사용할 수 있다. 함수는 함수의 반환값으로 사용할 수 있다. 함수는 프로퍼티와 메서드를 가질 수 있다. 함수는 이름 없는 리터럴로 표현할 수 있다(익명함수). 함수는 동적으로 생성할 수 있다. 일급 객체인 함수는 일급함수라고도 한다. 함수의 프로퍼티(메서드) 함수는 Function 생성자의 p…","fields":{"slug":"/js/2021-09-21-function-prototype/"},"frontmatter":{"categories":"js","title":"[javascript] 함수의 call, apply, bind 메서드","date":"September 21, 2021"}},"next":{"fields":{"slug":"/react/2021-09-21-react-modal/"}},"previous":{"fields":{"slug":"/js/2021-09-21-scroll/"}}},{"node":{"id":"35f2c219-0e9b-5662-8aa6-0dbbeba60422","excerpt":"프로젝트를 진행할 때마다 모달창을 마주치는 일이 많다. 프론트엔드 프레임워크나 라이브러리를 사용하면 편리성이나 시간을 아낄 수 있기때문에 npm에 등록된 모듈을 사용하곤 했지만, 만들어진 모듈이 아닌 직접 만들어 재사용해 보기로 했다.\r\n 어떻게 만들까?  재사용성 고려하기  Redux없이 만들기  함수형/클래스형 컴포넌트로 각각 만들기 1. 함수형으로 컴포넌트 만들기 -완성된 모습- img/modal-2.gif  *파일구조   재사용할 컴포넌트로 Modal.js 파일을 만들고, App.js에서 불러오도록 했다.  - CSS (함수형/클래스형 공통) - Modal.js - App.js  2. 클래스형으로 컴포넌트 만들기 - Modal.js (재사용 컴포넌트 - 자식) - App.js (부모 컴포넌트) 이로써 어디서든 Modal 컴포넌트를 가지고 와서 재사용할 수 있게 되었다. 모달은 워낙 기본적이고 중요한 부분은 아니라 만들어진 모듈을 사용할때가 많은데, 못만들어서 모듈을 이용하는…","fields":{"slug":"/react/2021-09-21-react-modal/"},"frontmatter":{"categories":"react","title":"[react] 모달 팝업창 만들기 (react modal)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/web/2021-09-21-rwd-awd/"}},"previous":{"fields":{"slug":"/js/2021-09-21-function-prototype/"}}},{"node":{"id":"c2e338a2-47de-5c21-a7d6-bd95bec7677f","excerpt":"퍼블리싱 프리랜서일을 할때면 자주 등장하는 용어가 바로 이란 단어다. 반응형이란 단어와 함께 언급되는 이란 단어도 있으며, 이 두 단어가 나올때마다 ‘도대체 무슨 차이지?’ 라는 의문도 따라온다. 퍼블리싱을 3년동안 했지만 반응형과 적응형의 차이에 대해 명확하게 설명하지 못하고 명확한 차이를 모른다고 생각됐기 때문에 이 두가지는 어떻게 다른지에 대해 알아보고자 조사하게 되었다.\r\n 반응형 vs 적응형  사진 출처 : https://uxplanet.org/ 1. 반응형: RWD(Responsive Web Design) *웹의 해상도, 레이아웃 등이 디바이스에 따라 반응하여 유동적으로 변환되는 웹페이지 \r\n과거의 웹을 사용하는 주요기기는 컴퓨터였으며, 모니터에 맞춰 화면의 크기와 레이아웃이 구성되었다. 2007년 애플사에서 아이폰을 출시하면서 스마트폰의 시대가 열렸고, 어디서든 손쉽게 웹사이트에 접근할 수 있게 되었다. 하지만 아래의 사진처럼 문제가 발생하였다. \r\n 바로 손바닥만한 …","fields":{"slug":"/web/2021-09-21-rwd-awd/"},"frontmatter":{"categories":"web","title":"[web] 반응형(RWD)웹과 적응형(AWD)웹","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-javascript-object/"}},"previous":{"fields":{"slug":"/react/2021-09-21-react-modal/"}}},{"node":{"id":"5185809c-415a-5b01-9e43-17e38c276359","excerpt":"는 블록 스코프이며, 변수의 재선언 및 재할당이 모두 불가능하다.\r\n흔히 여기서 오는 오해 중 하나가 const로 정의하면 객체 속성값도 수정할 수 없다고 생각하지만, const로 정의해도 객체의 내부 속성값은 수정이 가능하다. (객체를 참조하는 변수를 수정하는 것은 불가능 하다.) - JS 객체에서 이미 존재하는 속성값을 수정하거나 새로운 값을 추가하는 것은 모두 가능하다. 객체의 내부 속성값을 수정하지 못하게 하고 싶다면 유명한 불변성 패키지인 immer.js, immutable.js 등을 사용하면 된다. (immer.js는 리액트에서도 많이이 쓰이기 때문에 알아두면 좋다.) 이러한 패키지들은 기존 객체를 수정하지 않고 새롭게 객체를 생성한다.\r\n 다음의 JS내장 함수는 불변성 외부 패키지에서 새롭게 객체를 생성하는 편의성은 필요 없고 수정만 할 수 없도록 만들고 싶을 때 사용하면 유용하다. Object.preventExtensions Object.seal Object.free…","fields":{"slug":"/js/2021-09-21-javascript-object/"},"frontmatter":{"categories":"js","title":"[javascript] 객체 수정 제어 : preventExtensions(), seal(), freeze()","date":"September 21, 2021"}},"next":{"fields":{"slug":"/html/2021-09-21-sematic-tag/"}},"previous":{"fields":{"slug":"/web/2021-09-21-rwd-awd/"}}},{"node":{"id":"4e306843-7dfd-566f-9b4d-e33d97ed6533","excerpt":"“HTML is the World Wide Web’s core markup language. Originally, HTML was primarily designed as a language for semantically describing scientific documents.”  > - “HTML은 World Wide Web의 핵심 markup 언어이다. 원래 HTML은 과학적인 문서를 로 설계되었다.” \r\n“Elements, attributes, and attribute values in HTML are defined (by this specification) to have certain meanings (semantics)”\r\n- “HTML의 요소와 속성 및 속성 값은 되었다.”  Semantic Tag 시맨틱 태그란? 흔히들 HTML5 시대에서 가장 큰 변화는 시맨틱 태그라고 말한다. semantic은 사전적인 의미로 ‘의미의, 의미론적인’라는 의미를 가지고 있다.\r\nHTM…","fields":{"slug":"/html/2021-09-21-sematic-tag/"},"frontmatter":{"categories":"web","title":"[html] Semantic Tag Layout (시맨틱 태그)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/vue/2021-09-21-vue-clap-button/"}},"previous":{"fields":{"slug":"/js/2021-09-21-javascript-object/"}}},{"node":{"id":"df8392ce-2819-5fa4-9b86-9beeaaf93d60","excerpt":"새로운 vue 프로젝트 사전미팅에서 장바구니에 담기는 액션을 부탁받았었다.\r\n\r\n출처 : react clap button\r\n 이런 방식으로 장바구니에 담기는 액션을 부탁받았는데, 아직 vue가 미숙한 나는 어떻게 코딩해야 할지 큰 고민에 빠졌었다. 어떻게 만들까? 1. npm에서 타인이 만든걸 사용할까? npm에서 clap button을 검색하여 위의 박수치는 액션을 찾았다. 정말 딱 내가 원하던 액션이었고 클라이언트가 보여준 액션과도 거의 흡사했다. ‘Wow! 딱 원하던거야! 역시 npm 최고! 내가 생각하는건 이미 남이 만들어 놨을줄 알았다니까? 가만히 보자… 어라? 그런데 이건 react잖아? 😥 아니야! 실망하긴 이르지!! react가 있으면 vue도 있을거야!’ 라는 생각으로 바로 npm 검색을 했고 vue clap button을 찾았다. ‘역시! react가 있으면 vue도 있었어!’ 흡족한 마음으로 테스트용 프로젝트에 모듈을 설치해보았다.\r\n그런데 내가 원하던 액션이 …","fields":{"slug":"/vue/2021-09-21-vue-clap-button/"},"frontmatter":{"categories":"vue","title":"[vue] 박수치기 버튼 만들기 (vue clap button)","date":"September 21, 2021"}},"next":null,"previous":{"fields":{"slug":"/html/2021-09-21-sematic-tag/"}}}],"categories":["All","css","react","web","js","algorithm","gatsby","vue"]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}