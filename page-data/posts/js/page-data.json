{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/js","result":{"pageContext":{"currentCategory":"js","categories":["All","js","web","react","vue"],"edges":[{"node":{"id":"1c2a8a1d-dcc2-5441-9c32-bbcc2dc24742","excerpt":"","fields":{"slug":"/react-firebase/2021-10-26-firebase/"},"frontmatter":{"categories":"js react","title":"[react] firebase 프로젝트 배포하기","date":"September 26, 2021"}},"next":{"fields":{"slug":"/closure/"}},"previous":null},{"node":{"id":"1729f0ee-f37b-50ff-a706-4e0566ebc60b","excerpt":"사진 출처 : https://www.pinterest.co.kr/pin/439734351121493066/ 클로저(closure)는 자바스크립트 고유의 개념이 아니라 함수형 프로그래밍 언어에서 등장하는 보편적인 특성이다. 개념이 아니기 때문에 ECMAScript 명세서에도 클로저의 정의를 다루지 않고 있어 클로저에 대한 다양한 정의와 설명이 존재한다.  - 더글라스 크록포드 (자바스크립트 핵심 가이드) \n - 에딘 브라운 (러닝 자바스크립트)\n - 존 레식 (자바스크립트 닌자 비급)\n - 송형주 고형준 (인사이드 자바스크립트)\n - 에릭 프리먼 (Head First Javascript programming)\n - 야마다 요시히로 (자바스크립트 마스터북)\n - 유인동 (함수형 자바스크립트 프로그래밍)\n - MDN\n 이처럼 많은 설명과 정의가 존재하지만 막상 그 의미를 이해하기는 쉽지않다. MDN에서는   그림에서처럼 Outer내부에서 선언된 내부함수 Inner의 실행 컨텍스트가 활성…","fields":{"slug":"/closure/"},"frontmatter":{"categories":"js","title":"[javascript] closure (클로저)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/2021-09-21-hoisting/"}},"previous":{"fields":{"slug":"/react-firebase/2021-10-26-firebase/"}}},{"node":{"id":"060ca1db-7378-51e6-9262-099d3963b4f7","excerpt":"호이스팅(hoisting)이란 ‘끌어올리다’라는 의미의 hoist + ing를 붙여 만들어졌으며 의미 그대로 끌어올리는 행위로 작동한다. 주로 var로 선언된 변수의 선언문을 코드의 최상단으로 끌어올인다. (변수 정보를 수집하는 과정을 이해하기 쉬운 방법으로 대체한 가상의 개념으로, 자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주된다.) 호이스팅 실행컨텍스트에 담기는 LexicalEnvironment의 내부는 environmenRecord와 outer-EnvironmenReference로 구성되는데 environmenRecord는 호이스팅과 관련이 있다.  environmenRecord: 현재 컨텍스트와 관련된 코드의 식별자 정보를 순서대로 저장\n(식별자: 컨텍스트를 구성하는 함수에 지정된 매개변수, 함수자체, var로 선언된 변수의 식별자 등) 식별자 정보를 수집하는 과정을 마쳐도 코드가 실행되기 전이기 때문에 실행컨텍스트가 관여한 코드들은 실행되기 전…","fields":{"slug":"/2021-09-21-hoisting/"},"frontmatter":{"categories":"js","title":"[javascript] hoisting (호이스팅)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/scope/"}},"previous":{"fields":{"slug":"/closure/"}}},{"node":{"id":"8346e953-0293-5b9e-9d34-78084402323d","excerpt":"1. 실행 컨텍스트 실행 컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로 호이스팅, this 바인딩 등의 정보가 담긴다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보(Lexical Environmen)를 구성하고, this 값을 설정하는 등의 동작을 수행한다.  동일한 환경의 코드 실행 시 필요한 환경 정보를 모아 컨텍스트를 구성 콜 스택(call stack)에 쌓아올림 - 스택구조 컨텍스트와 관련있는 가장 위의 코드를 실행 (순서 보장) \n 흔히 실행 컨텍스트를 생성하는 방법은 함수를 실행하는 방법이다. (= 함수가 실행될 때 실행 컨텍스트가 만들어진다.) \n이미지 출처 : 코어 자바스크립트(정재남) 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 되며 콜스택에 담긴다. outer() 함수가 호출되면 자바스크립트 엔진이 outer에 대한 환경 정보를 수집해서…","fields":{"slug":"/scope/"},"frontmatter":{"categories":"js","title":"[javascript] execution context, scope (실행 컨텍스트, 스코프)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/2021-09-21-object/"}},"previous":{"fields":{"slug":"/2021-09-21-hoisting/"}}},{"node":{"id":"8df5727a-c73b-5fb8-946d-a75a45fc5206","excerpt":"1. assign() 앞서 설명했듯이 target에 pet1이 지정되어 있기때문에 target객체인 pet1에 변화가 생겼다. \n재귀적인 결합을 지원하지 않기때문에 description이 통째로 교체된다(birth → food)는 점에 주의한다.\n만약, sources객체들에 영향을 끼치고 싶지 않다면, 다음과 같이 target에 {}를 지정해주면 빈 객체에 sources객체를 결합한 값들을 반환한다.  2. create() 1, 2의 방법으로 생성된 객체는 Object의 인스턴스로써 Object의 기본 메서드를 계승하고 있다. (toString, valueOf등) Object.create메서드의 proto 인수에 null을 전달하면 Object의 프로토타입을 계승하지 않는 완전한 빈 객체를 만들 수 있다. (null이 전달되어 만들어진 객체는 toString, valueOf등의 메서드를 사용할 수 없다.) 위의 예제에서 configurable의 속성값을 true로 설정하였기 때문에…","fields":{"slug":"/2021-09-21-object/"},"frontmatter":{"categories":"js","title":"[javascript] Object.assign() & Object.create()","date":"September 21, 2021"}},"next":{"fields":{"slug":"/scroll/"}},"previous":{"fields":{"slug":"/scope/"}}},{"node":{"id":"984d107d-a737-56e4-b68c-21de11d4c9fc","excerpt":"자바스크립트는 원시타입(기본타입)과 참조타입으로 나뉜다. · 원시타입   Number  String  Boolean  undefined  null\n 원시타입을 제외한 모든값은 객체다.(즉, 참조타입은 객체다) 참조타입에는 원시타입을 제외한 모든타입, 배열, 함수, 정규표현식 등이 있다. 함수도 객체이기 때문에 값을 처리할 수 있으며 프로퍼티와 메서드도 가지고 있다. 함수는 객체 자바스크립트의 함수는 Function 객체이다. 함수가 객체라서 가지는 특징은 다음과 같으며 이러한 작업이 가능한 객체를 일급객체라고 한다. 함수는 변수나 프로퍼티나 배열 요소에 대입할 수 있다. 함수는 함수의 인수로 사용할 수 있다. 함수는 함수의 반환값으로 사용할 수 있다. 함수는 프로퍼티와 메서드를 가질 수 있다. 함수는 이름 없는 리터럴로 표현할 수 있다(익명함수). 함수는 동적으로 생성할 수 있다. 일급 객체인 함수는 일급함수라고도 한다. 함수의 프로퍼티(메서드) 함수는 Function 생성자의 p…","fields":{"slug":"/2021-09-21-function-prototype/"},"frontmatter":{"categories":"js","title":"[javascript] 함수의 call, apply, bind 메서드","date":"September 21, 2021"}},"next":{"fields":{"slug":"/react-modal/"}},"previous":{"fields":{"slug":"/scroll/"}}},{"node":{"id":"cff7438c-e202-5040-ac2e-7ddbceb63cc7","excerpt":"는 블록 스코프이며, 변수의 재선언 및 재할당이 모두 불가능하다.\n흔히 여기서 오는 오해 중 하나가 const로 정의하면 객체 속성값도 수정할 수 없다고 생각하지만, const로 정의해도 객체의 내부 속성값은 수정이 가능하다. (객체를 참조하는 변수를 수정하는 것은 불가능 하다.) - JS  객체에서 이미 존재하는 속성값을 수정하거나 새로운 값을 추가하는 것은 모두 가능하다. 객체의 내부 속성값을 수정하지 못하게 하고 싶다면 유명한 불변성 패키지인 immer.js, immutable.js 등을 사용하면 된다. (immer.js는 리액트에서도 많이이 쓰이기 때문에 알아두면 좋다.) 이러한 패키지들은 기존 객체를 수정하지 않고 새롭게 객체를 생성한다.\n 다음의 JS내장 함수는 불변성 외부 패키지에서 새롭게 객체를 생성하는 편의성은 필요 없고 수정만 할 수 없도록 만들고 싶을 때 사용하면 유용하다. Object.preventExtensions Object.seal Object.freez…","fields":{"slug":"/2021-09-21-javascript-object/"},"frontmatter":{"categories":"js","title":"[javascript] 객체 수정 제어 : preventExtensions(), seal(), freeze()","date":"September 21, 2021"}},"next":{"fields":{"slug":"/html-semantic-tag/"}},"previous":{"fields":{"slug":"/rwd-awd/"}}}]}},"staticQueryHashes":["1073350324","2938748437"]}