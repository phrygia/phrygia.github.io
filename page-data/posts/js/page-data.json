{
    "componentChunkName": "component---src-templates-category-template-js",
    "path": "/posts/js",
    "result": {"pageContext":{"currentCategory":"js","categories":["All","web","react","js","algorithm","gatsby","vue"],"edges":[{"node":{"id":"b83836f9-4d16-5e0a-bcc3-bc76fe1cf189","excerpt":"문제 : codilit MissingInteger \nN개의 정수로 이루어진 배열 A가 있다. A에 존재하지 않는 가장 작은 양의 정수를 반환하는 함수를 작성하는 문제이다.\n(0보다 큰 양의 정수를 반환해야 한다.)\n예를들어, 배열 A가 [−1, −3]으로 주어졌을때 0보다 큰 1이 반환되어야 한다.\n Solution: 처음 내가 푼 코드는 이렇다.\n배열 A를 순서대로 정렬하고 1부터 A의 가장큰수로 채워진 새로운 배열 arr을 만든다. \n그리고 존재하는 값을 확인하기 위해 Set을 사용하여 arr의 값을 복사한다. (indexOf를 사용하면 시간측정이 길어졌기 때문에 Set을 사용했다.)\nfor문으로 A의 배열을 돌면서 set에 값이 있는지 체크하고 있다면 delete 메소드로 삭제한다.  남아있는 배열의 개수가 0개라면 A = [1,2,3] 처럼 순서대로 채워진 배열이라는 뜻이기 때문에 3보다 큰 4를 리턴하기 위해 배열의 마지막 원소보다 1이 큰 수를 리턴한다. \nA = [1,…","fields":{"slug":"/algorithm/2021-12-14-codility/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] Codility Lesson 4. MissingInteger","date":"December 14, 2021"}},"next":{"fields":{"slug":"/gatsby/2021-12-12-gaysby/"}},"previous":{"fields":{"slug":"/react/2021-12-22.react-redux-persist/"}}},{"node":{"id":"15d86963-a417-5f7e-aa63-38aa68750f36","excerpt":"최근 비전공자를 위한 개발자 취업 인강을 듣고 있다. 그곳에서 TIL에 대한 용어를 처음 알게되었다.  TIL ? TIL이란 의 약자로 오늘 내가 배운것이라는 뜻이다. \n한국에서는 개발자들 사이에서 많이 쓰이는 용어이지만 외국에서는 SNS상에서 자주 쓰이는 약어라고 한다. \n개발자들은 자신의 기술 블로그를 운영하기 때문에 TIL을 따로 운영하지는 분들은 많지 않은것 같다.\n(어떻게 생각하면 기술 블로그 = TIL과 비슷한 느낌이랄까.. 🤔)  나는 기술블로그를 운영하지고 있지만 많은 포스팅을 올리지 못하고 있기 때문에 TIL 페이지를 따로 생성할 지 고민을 했다.\nTIL을 자기가 배운 내용을 매일 하나씩 쌓으면서 만드는 나만의 지식 사전으로 생각해 보기로 했다. \n추후에 동일한 문제가 발생하였을때 해결하지 못한다면 자기반성 및 습득하지 못한 지식을 정리하기에 도움이 될 것 같았기 때문에 TIL 페이지를 생성하기로 결정하였다. TIL 참고 예시 진유림(milooy)님의 TIL 저장소…","fields":{"slug":"/gatsby/2021-12-12-gaysby/"},"frontmatter":{"categories":"gatsby js","title":"[gatsby] gaysby로 TIL만들기","date":"December 12, 2021"}},"next":{"fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-14-codility/"}}},{"node":{"id":"fa7346fa-c32a-5186-a69b-ed162684931e","excerpt":"정렬된 배열에서 요소를 찾는 것이 정렬되지 않는 배열에서 찾는 것보다 빠르고 쉽다. \n정렬 알고리즘을 사용해 메모리에서 배열을 정렬하거나 정렬된 배열을 파일에 기록할 수 있다. ArrayList함수를 만들어 정렬/검색 대상 데이터를 저장한다.\n(각 알고리즘에 대한 설명은 검색하면 너무 자세하게 나와있기 때문에 코드 위주의 포스팅을 했다.) 1. 버블정렬 가장 간단한 정렬 알고리즘이다. \n버블정렬은 전체 배열을 순회하면서 인접한 두 원소를 비교하고 그 결과에 따라 두 원소의 위치를 서로 바꾼다. \n버블정렬은 모든 값을 비교하기 때문에 정렬 알고리즘들 중에서 가장 최악이라고 할 수 있다. 2. 삽입정렬 배열의 모든 요소를 앞에서부터 차례대로 검색하면서 정렬된 요소와 비교한다. \n정렬되지 않은 요소들을 배열의 자신의 위치를 찾아 이동(삽입)시킨다.\n(두번째 요소부터 정렬을 시작한다.) 3. 선택정렬 가장 작은 요소를 찾아서(선택해서) 해당 요소를 배열의 현 위치에 삽입하는 방식이다. *…","fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 정렬 알고리즘 - 버블, 삽입, 선택, 병합, 퀵","date":"December 07, 2021"}},"next":{"fields":{"slug":"/algorithm/2021-12-02-bigO/"}},"previous":{"fields":{"slug":"/gatsby/2021-12-12-gaysby/"}}},{"node":{"id":"77ee7db2-1ce6-5482-b717-539af2723280","excerpt":"알고리즘을 구현하기 전에 알고리즘이 얼마나 효과적인지 분석하는 법을 이해해야 한다.\n알고리즘을 구현할 때 빅오 표기법이 해당 알고리즘이 얼마나 효율적인지를 나타내기 때문에 빅오 표기법은 중요하다.\n효율적인 방법을 고민한다는 것은 시간 복잡도를 고민한다는 것과 같은 말이다. \n Time Complexity (시간 복잡도) 문제를 해결하는데 걸리는 시간과 입력의 관계를 가리킨다. \n즉, 입력값에 따라 연산을 실행할 때, 연산 횟수에 비해 얼마만큼의 시간이 걸리는가를 의미한다. \n시간복잡도를 고민한다는 것은 입력값이 커짐에 따라 증가하는 시간을 최소화한 알고리즘을 만들었다는 의미이기도 한다.\n시간복잡도는 Big-o 표기법을 사용해 나타낼 수 있다. \n출처 : 자바스크립트로하는 자료 구조와 알고리즘 *시간복잡도 순서 : 𝑂(1) < 𝑂(log n) < 𝑂(n) < 𝑂(n log n) < 𝑂(n²) < 𝑂(n³) < 𝑂(2ⁿ) < 𝑂(n!)  알고리즘 분석 시 가장 자주 등장하는 유형 O …","fields":{"slug":"/algorithm/2021-12-02-bigO/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 자바스크립트 빅오 표기법 (Big-O)","date":"December 02, 2021"}},"next":{"fields":{"slug":"/algorithm/2021-11-28-algorithm/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-07-sorting-algorithm/"}}},{"node":{"id":"f4a369fa-dc70-5864-aae0-2a4c4f64b840","excerpt":"Description: Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. \n문자열s와 단어들로 이루어진 배열 wordDict가 주어질 때, \nwordDict내의 문자들로 문자열 s를 만들 수 있는지 구하는 문제 (구할 수 있다면 true 반환)\n동일한 단어를 여러번 사용해도 되고 사용하지 않아도 된다. Solution: 처음에는 관련 주제를 살펴보지 않고 set을 이용해서 일치하는 단어가 배열에 있다면 문자열 s를 지워나가는 식으로 풀었다. \n이렇게 풀면 wordBreak(‘cars’, [“car”,“ca”,“rs”])에서 배열의 “car”을 먼저 만단 문자열 s는 “s”만 남게 되어 false를 리턴했다. \n“ca”,“rs” 를 사용하면 효율적으로 모든 문자…","fields":{"slug":"/algorithm/2021-11-28-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] LeetCode 139. Word Break ","date":"November 28, 2021"}},"next":{"fields":{"slug":"/react/2021-11-25-mui-react/"}},"previous":{"fields":{"slug":"/algorithm/2021-12-02-bigO/"}}},{"node":{"id":"bce55080-5052-5743-a56d-f417778bfa73","excerpt":"프로그래머스에서 자바스크립트 알고리즘 문제를 풀다보면 간간히 접하게 되는 수학관련 문제들이 있다.\n그 중 자연수와 관련된(약수, 소수, 최대공약수, 최소공배수) 문제들이 있었는데 이에 대한 이론을 정리하고 프로그래머스 코딩테스트 연습에 나오는 문제들을 풀어보면서 정확한 개념을 터득하고자 정리해 보았다. \n(문제 - 약수의 합, 약수의 개수와 덧셈, 소수 만들기, 소수 찾기, 최대공약수와 최소공배수, N개의 최소공배수)\n 1. 약수 약수란 무엇인가? \n    어떤 수를 나머지가 없이 나누어떨어지게 하는 수를 그 수의 약수라고 한다. \n    예를 들면 8을 1, 2, 4, 8로 나누면 나머지가 없다. 이때 1, 2, 4, 8을 8의 약수라고 한다. 1. 약수의 합   문제풀이 2. 약수의 개수와 덧셈  문제풀이 https://programmers.co.kr/learn/courses/30/lessons/77884?language=javascript\n 2. 소수 소수란 무엇인가? \n  …","fields":{"slug":"/algorithm/2021-11-09-algorithm/"},"frontmatter":{"categories":"js algorithm","title":"[algorithm] 약수, 소수, 최대공약수, 최소공배수","date":"November 09, 2021"}},"next":{"fields":{"slug":"/js/2021-10-30-var-let-const/"}},"previous":{"fields":{"slug":"/react/2021-11-25-mui-react/"}}},{"node":{"id":"b293129a-ad91-5b59-9dca-370c7cf16bfb","excerpt":"var 선언한 변수의 문제점 ES6의 let과 const가 생기기 전에 변수를 선언할 수 있는 유일한 방법은 var를 사용하는 것이었다. var로 선언된 변수는 다른 언어와는 구별되는 독특한 특징을 가지고 있다.  1. 변수 중복 선언 허용 var 키워드로 선언한 변수는 중복 선언이 가능하다. 예제 1 var로 선언한 변수는 중복 선언이 가능하지만, 초기화문 유뮤에 따라 다르게 동작한다. 초기화문이 있는 변수 선언문은 기존 변수에 값을 재할당 하지만 초기화문이 없는 변수 선언문은 무시되고 에러가 발생하지 않는다.\n(여러명이 개발할때 다른 개발자가 동일한 이름의 변수를 초기화문으로 선언한다면 의도치않게 값이 변경될 수 있다.)  2. 함수 레벨 스코프 var 키워드로 선언한 변수는 함수내에서만 지역 스코프로 인정한다. 함수 밖에서 선언한 var 변수는 모두 전역 변수가 된다. 예제 2 위의 예제에서 변수 a와 i가 중복 선언되어 변수의 값이 의도치않게 변경되는 부작용이 발생했다.  …","fields":{"slug":"/js/2021-10-30-var-let-const/"},"frontmatter":{"categories":"js","title":"[javascript] var, let, const","date":"October 31, 2021"}},"next":{"fields":{"slug":"/react/2021-10-27-react-firebase/"}},"previous":{"fields":{"slug":"/algorithm/2021-11-09-algorithm/"}}},{"node":{"id":"be8395f3-897c-5792-a8c9-3cbe4e69f32b","excerpt":"사진 출처 : https://www.pinterest.co.kr/pin/439734351121493066/ 클로저(closure)는 자바스크립트 고유의 개념이 아니라 함수형 프로그래밍 언어에서 등장하는 보편적인 특성이다. 개념이 아니기 때문에 ECMAScript 명세서에도 클로저의 정의를 다루지 않고 있어 클로저에 대한 다양한 정의와 설명이 존재한다.  - 더글라스 크록포드 (자바스크립트 핵심 가이드)  >  - 에딘 브라운 (러닝 자바스크립트) >  - 존 레식 (자바스크립트 닌자 비급) >  - 송형주 고형준 (인사이드 자바스크립트) >  - 에릭 프리먼 (Head First Javascript programming) >  - 야마다 요시히로 (자바스크립트 마스터북) >  - 유인동 (함수형 자바스크립트 프로그래밍) >  - MDN >  이처럼 많은 설명과 정의가 존재하지만 막상 그 의미를 이해하기는 쉽지않다. MDN에서는  그림에서처럼 Outer내부에서 선언된 내부함수 Inn…","fields":{"slug":"/js/2021-09-21-closure/"},"frontmatter":{"categories":"js","title":"[javascript] closure (클로저)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-hoisting/"}},"previous":{"fields":{"slug":"/gatsby/2021-10-26-gaysby/"}}},{"node":{"id":"a00943be-bae7-5672-abc8-7effe30b2ff3","excerpt":"호이스팅(hoisting)이란 ‘끌어올리다’라는 의미의 hoist + ing를 붙여 만들어졌으며 의미 그대로 끌어올리는 행위로 작동한다. 주로 var로 선언된 변수의 선언문을 코드의 최상단으로 끌어올인다. (변수 정보를 수집하는 과정을 이해하기 쉬운 방법으로 대체한 가상의 개념으로, 자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주된다.) 호이스팅 실행컨텍스트에 담기는 LexicalEnvironment의 내부는 environmenRecord와 outer-EnvironmenReference로 구성되는데 environmenRecord는 호이스팅과 관련이 있다.  environmenRecord: 현재 컨텍스트와 관련된 코드의 식별자 정보를 순서대로 저장\n(식별자: 컨텍스트를 구성하는 함수에 지정된 매개변수, 함수자체, var로 선언된 변수의 식별자 등) 식별자 정보를 수집하는 과정을 마쳐도 코드가 실행되기 전이기 때문에 실행컨텍스트가 관여한 코드들은 실행되기 전…","fields":{"slug":"/js/2021-09-21-hoisting/"},"frontmatter":{"categories":"js","title":"[javascript] hoisting (호이스팅)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-scope/"}},"previous":{"fields":{"slug":"/js/2021-09-21-closure/"}}},{"node":{"id":"de9717f7-8dae-5f10-b0f2-76cefdf77b15","excerpt":"1. 실행 컨텍스트 실행 컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로 호이스팅, this 바인딩 등의 정보가 담긴다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보(Lexical Environmen)를 구성하고, this 값을 설정하는 등의 동작을 수행한다. 동일한 환경의 코드 실행 시 필요한 환경 정보를 모아 컨텍스트를 구성 콜 스택(call stack)에 쌓아올림 - 스택구조 컨텍스트와 관련있는 가장 위의 코드를 실행 (순서 보장)\n 흔히 실행 컨텍스트를 생성하는 방법은 함수를 실행하는 방법이다. (= 함수가 실행될 때 실행 컨텍스트가 만들어진다.) \n이미지 출처 : 코어 자바스크립트(정재남) 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 되며 콜스택에 담긴다. outer() 함수가 호출되면 자바스크립트 엔진이 outer에 대한 환경 정보를 수집해서 o…","fields":{"slug":"/js/2021-09-21-scope/"},"frontmatter":{"categories":"js","title":"[javascript] execution context, scope (실행 컨텍스트, 스코프)","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-object/"}},"previous":{"fields":{"slug":"/js/2021-09-21-hoisting/"}}},{"node":{"id":"a03fdc05-f693-5e05-92a4-592d0c967eb4","excerpt":"1. assign() 앞서 설명했듯이 target에 pet1이 지정되어 있기때문에 target객체인 pet1에 변화가 생겼다. \n재귀적인 결합을 지원하지 않기때문에 description이 통째로 교체된다(birth → food)는 점에 주의한다.\n만약, sources객체들에 영향을 끼치고 싶지 않다면, 다음과 같이 target에 {}를 지정해주면 빈 객체에 sources객체를 결합한 값들을 반환한다.  2. create() 1, 2의 방법으로 생성된 객체는 Object의 인스턴스로써 Object의 기본 메서드를 계승하고 있다. (toString, valueOf등) Object.create메서드의 proto 인수에 null을 전달하면 Object의 프로토타입을 계승하지 않는 완전한 빈 객체를 만들 수 있다. (null이 전달되어 만들어진 객체는 toString, valueOf등의 메서드를 사용할 수 없다.) 위의 예제에서 configurable의 속성값을 true로 설정하였기 때문에…","fields":{"slug":"/js/2021-09-21-object/"},"frontmatter":{"categories":"js","title":"[javascript] Object.assign() & Object.create()","date":"September 21, 2021"}},"next":{"fields":{"slug":"/js/2021-09-21-scroll/"}},"previous":{"fields":{"slug":"/js/2021-09-21-scope/"}}},{"node":{"id":"c321bf53-5090-5fd4-b5c9-5270a83847d8","excerpt":"자바스크립트는 원시타입(기본타입)과 참조타입으로 나뉜다. · 원시타입   Number  String  Boolean  undefined  null  원시타입을 제외한 모든값은 객체다.(즉, 참조타입은 객체다) 참조타입에는 원시타입을 제외한 모든타입, 배열, 함수, 정규표현식 등이 있다. 함수도 객체이기 때문에 값을 처리할 수 있으며 프로퍼티와 메서드도 가지고 있다. 함수는 객체 자바스크립트의 함수는 Function 객체이다. 함수가 객체라서 가지는 특징은 다음과 같으며 이러한 작업이 가능한 객체를 일급객체라고 한다. 함수는 변수나 프로퍼티나 배열 요소에 대입할 수 있다. 함수는 함수의 인수로 사용할 수 있다. 함수는 함수의 반환값으로 사용할 수 있다. 함수는 프로퍼티와 메서드를 가질 수 있다. 함수는 이름 없는 리터럴로 표현할 수 있다(익명함수). 함수는 동적으로 생성할 수 있다. 일급 객체인 함수는 일급함수라고도 한다. 함수의 프로퍼티(메서드) 함수는 Function 생성자의 p…","fields":{"slug":"/js/2021-09-21-function-prototype/"},"frontmatter":{"categories":"js","title":"[javascript] 함수의 call, apply, bind 메서드","date":"September 21, 2021"}},"next":{"fields":{"slug":"/react/2021-09-21-react-modal/"}},"previous":{"fields":{"slug":"/js/2021-09-21-scroll/"}}},{"node":{"id":"517a0043-be6f-549e-af4c-4a92903015e9","excerpt":"는 블록 스코프이며, 변수의 재선언 및 재할당이 모두 불가능하다.\n흔히 여기서 오는 오해 중 하나가 const로 정의하면 객체 속성값도 수정할 수 없다고 생각하지만, const로 정의해도 객체의 내부 속성값은 수정이 가능하다. (객체를 참조하는 변수를 수정하는 것은 불가능 하다.) - JS 객체에서 이미 존재하는 속성값을 수정하거나 새로운 값을 추가하는 것은 모두 가능하다. 객체의 내부 속성값을 수정하지 못하게 하고 싶다면 유명한 불변성 패키지인 immer.js, immutable.js 등을 사용하면 된다. (immer.js는 리액트에서도 많이이 쓰이기 때문에 알아두면 좋다.) 이러한 패키지들은 기존 객체를 수정하지 않고 새롭게 객체를 생성한다.\n 다음의 JS내장 함수는 불변성 외부 패키지에서 새롭게 객체를 생성하는 편의성은 필요 없고 수정만 할 수 없도록 만들고 싶을 때 사용하면 유용하다. Object.preventExtensions Object.seal Object.freeze…","fields":{"slug":"/js/2021-09-21-javascript-object/"},"frontmatter":{"categories":"js","title":"[javascript] 객체 수정 제어 : preventExtensions(), seal(), freeze()","date":"September 21, 2021"}},"next":{"fields":{"slug":"/html/2021-09-21-sematic-tag/"}},"previous":{"fields":{"slug":"/web/2021-09-21-rwd-awd/"}}}]}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}