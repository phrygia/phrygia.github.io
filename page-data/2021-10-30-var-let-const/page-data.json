{"componentChunkName":"component---src-templates-post-jsx","path":"/2021-10-30-var-let-const/","result":{"data":{"site":{"siteMetadata":{"title":"phrygia dev.log"}},"markdownRemark":{"id":"2d4fc9ca-ba49-574a-bfe3-3606aa0d4331","excerpt":"var 선언한 변수의 문제점 ES6의 let과 const가 생기기 전에 변수를 선언할 수 있는 유일한 방법은 var를 사용하는 것이었다. var로 선언된 변수는 다른 언어와는 구별되는 독특한 특징을 가지고 있다. 1. 변수 중복 선언 허용 var 키워드로 선언한 변수는 중복 선언이 가능하다. 예제 1 var로 선언한 변수는 중복 선언이 가능하지만, 초기화…","html":"<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 457px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/0d4322b4ef4596768bb7f2c30c270662/ff7b0/jsDeepDive.jpg' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 122.3529411764706%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAYABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAQBAwL/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABtoo5RQxXP2Gg/8QAGxAAAgIDAQAAAAAAAAAAAAAAAQIAAxAREhP/2gAIAQEAAQUCZit9b2MYdCeoJjL1AAMf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAGxAAAgIDAQAAAAAAAAAAAAAAAREAEAIhURL/2gAIAQEABj8CJeuObxx89dMxAE0Hf//EABsQAQACAwEBAAAAAAAAAAAAAAEAERBBYSFR/9oACAEBAAE/IfWgbc/JY+CwoKUQB6jWD3AbqAAFVj//2gAMAwEAAgADAAAAEOzIPP/EABURAQEAAAAAAAAAAAAAAAAAABEg/9oACAEDAQE/ECP/xAAVEQEBAAAAAAAAAAAAAAAAAAARIP/aAAgBAgEBPxBI/8QAHBABAAICAwEAAAAAAAAAAAAAAQARIUEQMVGR/9oACAEBAAE/ED1k8k08Z3DYCsLT84dATKrghd5ep094aqLMumCjAorUEbrU/9k='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='jsDeepDive' title='' src='/static/0d4322b4ef4596768bb7f2c30c270662/ff7b0/jsDeepDive.jpg' srcset='/static/0d4322b4ef4596768bb7f2c30c270662/0b705/jsDeepDive.jpg 170w,\n/static/0d4322b4ef4596768bb7f2c30c270662/31389/jsDeepDive.jpg 340w,\n/static/0d4322b4ef4596768bb7f2c30c270662/ff7b0/jsDeepDive.jpg 457w' sizes='(max-width: 457px) 100vw, 457px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span></p>\n<h2>var 선언한 변수의 문제점</h2>\n<p>ES6의 let과 const가 생기기 전에 변수를 선언할 수 있는 유일한 방법은 var를 사용하는 것이었다. var로 선언된 변수는 다른 언어와는 구별되는 독특한 특징을 가지고 있다.</p>\n<h3>1. 변수 중복 선언 허용</h3>\n<p>var 키워드로 선언한 변수는 중복 선언이 가능하다.<br></p>\n<p><strong>예제 1</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\">// 초기화문이 없는 변수 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</span>\n<span class=\"token comment\">// 초기화문 : 변수 선언과 동시에 초기값을 할당하는 문</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">var</span> b <span class=\"token comment\">// 초기화문이 없는 선언문은 무시된다.</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 100</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span></code></pre></div>\n<p>var로 선언한 변수는 중복 선언이 가능하지만, 초기화문 유뮤에 따라 다르게 동작한다. 초기화문이 있는 변수 선언문은 기존 변수에 값을 재할당 하지만 초기화문이 없는 변수 선언문은 무시되고 에러가 발생하지 않는다.\n(여러명이 개발할때 다른 개발자가 동일한 이름의 변수를 초기화문으로 선언한다면 의도치않게 값이 변경될 수 있다.)</p>\n<h3>2. 함수 레벨 스코프</h3>\n<p>var 키워드로 선언한 변수는 함수내에서만 지역 스코프로 인정한다. 함수 밖에서 선언한 var 변수는 모두 전역 변수가 된다.<br></p>\n<p><strong>예제 2</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// a가 이미 함수 외부에서 선언됐기 때문에 전역변수가 된다.</span>\n  <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token punctuation\">}</span>\ncosnole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 10</span>\n\n<span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// for문에서 선언한 i는 전역변수고 위에서 선언한 i가 있으므로 값이 변경된다.</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 0 1 2 3 4</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 5</span></code></pre></div>\n<p>위의 예제에서 변수 a와 i가 중복 선언되어 변수의 값이 의도치않게 변경되는 부작용이 발생했다.</p>\n<h3>3. 변수 호이스팅</h3>\n<p>var 키워드로 변수를 선언하면 호이스팅이 발생한다. 호이스팅에 의해 변수 선언문 이전에 값을 참조할 수 있다. (값을 할당하기 이전에 변수를 참조하면 값은 undefined를 반환한다.)<br></p>\n<p><strong>예제 3</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 1. 호이스팅에 의해 foo 변수가 선언되었다.</span>\n<span class=\"token comment\">// 2. 변수 foo는 undefined</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span>\n\n<span class=\"token comment\">// 3. 변수에 값을 할당</span>\nfoo <span class=\"token operator\">=</span> <span class=\"token number\">123</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 123</span>\n\n<span class=\"token comment\">// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행</span>\n<span class=\"token keyword\">var</span> foo</code></pre></div>\n<p>변수 선언문 이전에 변수를 참조하는 것은 호이스팅에 의해 에러가 발생하지는 않지만 가독성이 떨어지고 좋은 코드는 아니기 때문에 사용을 지양한다.</p>\n<h2>let 키워드</h2>\n<h3>1. 변수 중복 선언 금지</h3>\n<p>위에서 살펴본 것 처럼 var는 동일한 이름의 변수를 선언해도 아무런 에러가 발생하지 않았지만 값이 바뀔 수 있는 부작용이 발생한다. <br>하지만 let으로 이름이 같은 변수를 중복 선언하면 문법 에러(Syntax Error)가 발생한다.<br></p>\n<p><strong>예제 4</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 중복 선언되어 변수의 값이 변한다.</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">123</span>\n<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">456</span>\n\n<span class=\"token comment\">// 중복 선언을 허용하지 않는다.</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">123</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">456</span> <span class=\"token comment\">// SyntaxError: Identifier 'b' has already been declared</span></code></pre></div>\n<h3>2.블록 레벨 스코프</h3>\n<ul>\n<li><code class=\"language-text\">함수 레벨 스코프</code> : var 키워드로 선언한 변수는 함수 내부에서만 선언한 변수는 지역 스코프로 인정한다. <br></li>\n<li><code class=\"language-text\">블록 레벨 스코프</code> : let 키워드로 선언한 변수는 모든 코드 블록 (함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정한다.</li>\n</ul>\n<p><strong>예제 5</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 전역 변수</span>\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 지역 변수</span>\n  <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">2</span>\n  <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// ReferenceError: b is not defined</span></code></pre></div>\n<p>전역에서 선언된 a 변수와 코드 블록 내에서 선언된 a는 다른 변수다. 코드 블록 내에서 선언한 a와 b는 지역 변수다. 따라서 전역에서는 b를 참조할 수 없기때문에 참조에러 (ReferenceError)가 뜬다.</p>\n<h3>3. 변수 호이스팅</h3>\n<p>let으로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다. (실제론 동작함)</p>\n<p><strong>예제 6</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span> <span class=\"token comment\">// ReferenceError: foo is not defined</span>\n<span class=\"token keyword\">let</span> foo</code></pre></div>\n<p>let으로 선언한 변수를 선언문 이전에 참조하면 참조 에러가 발생한다.<br>\nvar로 선언한 변수는</p>\n<ol>\n<li>런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 <strong>선언과 초기화가 함께 진행</strong></li>\n<li>초기화 단계에서 <strong>변수에 접근하면 undefined를 반환</strong></li>\n<li>변수 선언문제 도달했을때 값이 할당</li>\n<li>변수에 접근하면 할당값 반환</li>\n</ol>\n<p>let으로 선언한 변수는</p>\n<ol>\n<li><strong>선언과 초기화가 분리되어 진행</strong></li>\n<li>자바스크립트 엔진에 의해 암묵적으로 선언 단계 실행</li>\n<li><strong>변수에 접근하면 참조에러(ReferenceError) 반환</strong></li>\n<li>초기화는 변수 선언문에 도달했을때 실행</li>\n<li>이후 변수에 접근 가능</li>\n</ol>\n<h3>4. 전역 객체와 let</h3>\n<p>var로 선언한 변수의 암묵적 전역은 전역객체 window의 프로퍼티가 된다.</p>\n<p><strong>예제 7</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span>\n<span class=\"token comment\">// window의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span>\n\n<span class=\"token comment\">// 함수 선언문으로 정의한 전역 함수는 전역 객체 window의 프로퍼티다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// f foo() {}</span>\n<span class=\"token comment\">// window의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// f foo() {}</span>\n\n<span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n\n<span class=\"token comment\">// let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다.</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>x<span class=\"token punctuation\">)</span> <span class=\"token comment\">// undefined</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 1</span></code></pre></div>\n<p>let으로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. window.변수명과 같이 접근할 수 없다.</p>\n<h2>const 키워드</h2>\n<p>const는 상수(constant)를 선언하기 위해 사용한다. let 키워드와 비슷하다. <br>\n<strong>상수? 재할당이 금지된 변수</strong></p>\n<h3>1. 선언과 초기화</h3>\n<p>const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.</p>\n<p><strong>예제 8</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 초기화를 하지 않는다면 에러가 발생</span>\n<span class=\"token keyword\">const</span> b<span class=\"token punctuation\">;</span> <span class=\"token comment\">// SyntaxError: Missing initializer in const declaration</span></code></pre></div>\n<p>const 키워드로 선언한 변수는 let과 마찬가지로 <code class=\"language-text\">블록 레벨 스코프</code>를 가지며, 호이스팅이 발생하지 않는 것처럼 동작한다.</p>\n<h3>2. 재할당 금지</h3>\n<p>var나 let으로 선언한 변수를 재할당이 가능하나 <strong>const로 선언한 변수는 재할당이 금지된다.</strong></p>\n<p><strong>예제 9</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\na <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token comment\">// TypeError: Assignment to constant variable.</span></code></pre></div>\n<h3>3. 상수</h3>\n<p>상수는 재할당이 금지되며 상수의 상태 유지와 가독성, 유지보수를 위해 적극적으로 사용하기를 권장한다.</p>\n<p><strong>예제 10</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">/* let을 사용했을 때 */</span>\n<span class=\"token comment\">// 세전 가격</span>\n<span class=\"token keyword\">let</span> preTaxPrice <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token comment\">// 세후 가격</span>\n<span class=\"token keyword\">let</span> afterTaxPrice <span class=\"token operator\">=</span> preTaxPrice <span class=\"token operator\">+</span> preTaxPrice <span class=\"token operator\">*</span> <span class=\"token number\">0.1</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>afterTaxPrice<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 110</span>\n\n<span class=\"token comment\">/* const를 사용했을 때 */</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">TAX_RATE</span> <span class=\"token operator\">=</span> <span class=\"token number\">0.1</span> <span class=\"token comment\">// 세율을 의미하는 0.1은 변경할 수 없다.</span>\n<span class=\"token keyword\">let</span> preTaxPrice <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token keyword\">let</span> afterTaxPrice <span class=\"token operator\">=</span> preTaxPrice <span class=\"token operator\">+</span> preTaxPrice <span class=\"token operator\">*</span> <span class=\"token constant\">TAX_RATE</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>afterTaxPrice<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 100</span></code></pre></div>\n<p>let을 사용한 코드는</p>\n<ul>\n<li>0.1은 어떤 의미로 사용했는지 명확히 알기 어렵기 때문에 가독성이 좋지 않다. <br></li>\n<li>세율을 의미하는 0.1은 쉽게 바뀌지 않는 값이다. → 고정된 값</li>\n</ul>\n<p>const를 사용한 코드로 바꾸면</p>\n<ul>\n<li>세율을 의미하는 TAX_RATE변수는 변경할 수 없는 값으로 할당된 값을 변경할 수 없다.</li>\n<li>프로그램 전체에서 공통적으로 사용 → 나중에 세율이 변경되면 값만 바꾼다 → <strong>유지보수성 향상</strong></li>\n</ul>\n<h3>4. const 키워드와 객체</h3>\n<p>const로 선언된 변수에 값을 변경할 수 없다. 하지만 const로 선언된 변수에 객체가 할당된 경우에는 값을 변경할 수 있다. <br>\n(변경 가능한 값인 객체는 재할당 없이도 직접 변경이 가능하기 때문에)</p>\n<p><strong>예제 11</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token literal-property property\">age</span><span class=\"token operator\">:</span> <span class=\"token number\">33</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\nperson<span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> <span class=\"token number\">32</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span> <span class=\"token comment\">// {age: 32}</span></code></pre></div>\n<p><strong>const는 재할당은 금지할 뿐 <code class=\"language-text\">불변</code>을 의미하지 않는다.</strong> 새로운 값을 재할당 하는것은 불가능 하지만 프로퍼티 동적 생성, 삭제, 값의 변경 등을 토해 객체를 변경하는 것은 가능하다.</p>\n<h2>var, let, const</h2>\n<ul>\n<li>ES6를 사용한다면 var는 사용하지 않는다.</li>\n<li>재할당이 필요한 경우 let을 사용한다. (스코프는 최대한 좁게)</li>\n<li>값이 변경되지 않을 경우 const를 사용한다.</li>\n<li><strong>되도록 const를 사용한다.</strong></li>\n</ul>\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>var</th>\n            <th>let</th>\n            <th>const</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>변수 재할당</th>\n            <td>O</td>\n            <td>O</td>\n            <td>X</td>\n        </tr>\n        <tr>\n          <th>스코프</th>\n            <td>함수 레벨 스코프</td>\n            <td>블록 레벨 스코프</td>\n            <td>블록 레벨 스코프</td>\n        </tr>\n        <tr>\n          <th>호이스팅</th>\n            <td>O</td>\n            <td>O (발생하지 않는것처럼 동작)</td>\n            <td>O (발생하지 않는것처럼 동작)</td>\n        </tr>\n        <tr>\n          <th>전역객체 프로퍼티 여부</th>\n            <td>O</td>\n            <td>X</td>\n            <td>X</td>\n        </tr>\n    </tbody>\n</table>","frontmatter":{"title":"[javascript] var, let, const","date":"October 31, 2021","update":null,"tags":["js"],"series":null},"fields":{"slug":"/2021-10-30-var-let-const/","readingTime":{"minutes":12.32}}},"seriesList":{"edges":[{"node":{"id":"85f01aa5-eee3-575e-811d-813ae4014d8c","fields":{"slug":"/2021-09-21-vue-clap-button/"},"frontmatter":{"title":"[vue] 박수치기 버튼 만들기 (vue clap button)"}}},{"node":{"id":"e17c2c8d-3ac3-52c8-b833-f0f63fb145ca","fields":{"slug":"/2021-09-21-sematic-tag/"},"frontmatter":{"title":"[html] Semantic Tag Layout (시맨틱 태그)"}}},{"node":{"id":"e9406318-7870-53b8-be0d-0628d5f16c6e","fields":{"slug":"/2021-09-21-javascript-object/"},"frontmatter":{"title":"[javascript] 객체 수정 제어 : preventExtensions(), seal(), freeze()"}}},{"node":{"id":"cba7b4a8-a8ea-5b52-8dd2-a248e4608e02","fields":{"slug":"/2021-09-21-rwd-awd/"},"frontmatter":{"title":"[web] 반응형(RWD)웹과 적응형(AWD)웹"}}},{"node":{"id":"121d2f8c-b8bd-5859-adb4-d552da584a31","fields":{"slug":"/2021-09-21-react-modal/"},"frontmatter":{"title":"[react] 모달 팝업창 만들기 (react modal)"}}},{"node":{"id":"157b47fb-9294-57ef-9771-7d7a2821fbf4","fields":{"slug":"/2021-09-21-function-prototype/"},"frontmatter":{"title":"[javascript] 함수의 call, apply, bind 메서드"}}},{"node":{"id":"10ab8846-cab6-5f3b-8284-505b13f7084a","fields":{"slug":"/2021-09-21-scroll/"},"frontmatter":{"title":"[html] 특정 영역으로 스크롤 이동 - 앵커기능(anchor) vs data 속성"}}},{"node":{"id":"4b5dea8f-4444-5637-9830-c3c989400402","fields":{"slug":"/2021-09-21-object/"},"frontmatter":{"title":"[javascript] Object.assign() & Object.create()"}}},{"node":{"id":"88fb7276-7d08-5a9a-ba95-c65bdef391c6","fields":{"slug":"/2021-09-21-scope/"},"frontmatter":{"title":"[javascript] execution context, scope (실행 컨텍스트, 스코프)"}}},{"node":{"id":"50a8a0a9-8dd3-57a0-948c-9212fb004fb3","fields":{"slug":"/2021-09-21-hoisting/"},"frontmatter":{"title":"[javascript] hoisting (호이스팅)"}}},{"node":{"id":"ec875953-377a-5ada-8b87-c272e65f12a1","fields":{"slug":"/2021-09-21-closure/"},"frontmatter":{"title":"[javascript] closure (클로저)"}}},{"node":{"id":"06cddb64-6db7-508a-8cb5-1564e438ebb7","fields":{"slug":"/2021-10-26-gaysby/"},"frontmatter":{"title":"[gatsby] Google Search Console과 Analytics 추가하기"}}},{"node":{"id":"e6286486-8ec3-5662-b1cf-895996e89851","fields":{"slug":"/2021-10-27-react-firebase/"},"frontmatter":{"title":"[react] firebase 프로젝트 배포하기"}}},{"node":{"id":"2d4fc9ca-ba49-574a-bfe3-3606aa0d4331","fields":{"slug":"/2021-10-30-var-let-const/"},"frontmatter":{"title":"[javascript] var, let, const"}}},{"node":{"id":"4d966f89-a26f-5410-a2fa-a41551cd718e","fields":{"slug":"/2021-11-09-algorithm/"},"frontmatter":{"title":"[algorithm] 약수, 소수, 최대공약수, 최소공배수"}}},{"node":{"id":"4c707311-c079-57e1-a572-98f3aa7ae231","fields":{"slug":"/2021-11-25-mui-react/"},"frontmatter":{"title":"[react] Material ui 템플릿 (Mui) 으로 회원가입 페이지 만들기 "}}},{"node":{"id":"0ab0d3c0-07e9-503d-ac43-54d9254180e5","fields":{"slug":"/2021-11-28-algorithm/"},"frontmatter":{"title":"[algorithm] LeetCode 139. Word Break "}}},{"node":{"id":"6dcf61f9-9ed6-5cfb-8947-f87bac931416","fields":{"slug":"/2021-12-02-bigO/"},"frontmatter":{"title":"[algorithm] 자바스크립트 빅오 표기법 (Big-O)"}}},{"node":{"id":"45389ff3-dff3-51b6-ab97-2eaa99c99dc4","fields":{"slug":"/2021-12-07-sorting-algorithm/"},"frontmatter":{"title":"[algorithm] 정렬 알고리즘 - 버블, 삽입, 선택, 병합, 퀵"}}},{"node":{"id":"f1ac0cd5-4c87-5edd-9702-ad95516ccd7d","fields":{"slug":"/2021-12-12-gaysby/"},"frontmatter":{"title":"[gatsby] gaysby로 TIL만들기"}}},{"node":{"id":"0b9239b9-8a3f-5bce-b733-412718adc20b","fields":{"slug":"/2021-12-14-codility/"},"frontmatter":{"title":"[algorithm] Codility Lesson 4. MissingInteger"}}},{"node":{"id":"3bc11fc9-8a50-5b56-ac54-8c89973dae82","fields":{"slug":"/2021-12-22-react-redux-persist/"},"frontmatter":{"title":"[react] react프로젝트에 redux-persist 적용하기"}}},{"node":{"id":"1c11f636-4486-5cb5-9bd0-e4ac4e3a1f03","fields":{"slug":"/2022-01-02-aws/"},"frontmatter":{"title":"[aws] PuTTY로 윈도우에서 aws ec2 ssh 접속하기"}}},{"node":{"id":"623c8fce-4a4c-58e9-82c3-932272112732","fields":{"slug":"/2022-01-27-styled-components/"},"frontmatter":{"title":"[react] styled-components 반응형 스타일 설정하기"}}},{"node":{"id":"c3bd1f2b-9d76-5f6b-af23-328ede9408e0","fields":{"slug":"/2022-02-06-scss-for/"},"frontmatter":{"title":"[scss] @for ~ through / to 차이점"}}},{"node":{"id":"f4995c24-f2de-5b69-9eb4-b6d86b64e1cf","fields":{"slug":"/2022-02-18-react/"},"frontmatter":{"title":"[react] CRA없이 React환경 구축하기 (웹팩, 바벨)"}}},{"node":{"id":"7e733056-9768-5753-9b29-0d34cc3320dc","fields":{"slug":"/2022-03-03-react-modal/"},"frontmatter":{"title":"[react] transition이 적용된 Modal 만들기"}}},{"node":{"id":"3f792d2c-3143-561e-9a78-cbf812f2d06c","fields":{"slug":"/2022-04-05-react/"},"frontmatter":{"title":"[react] react 코딩 컨벤션"}}},{"node":{"id":"d85197d6-d2e1-5420-b0dc-493facfb091a","fields":{"slug":"/2022-03-09/"},"frontmatter":{"title":"[diary] 프론트엔드 신입 면접 준비하기"}}},{"node":{"id":"8b9e8572-327f-5494-a9db-f0680b8d0458","fields":{"slug":"/2022-04-25-git-basic/"},"frontmatter":{"title":"[git] git 기본 사용법"}}},{"node":{"id":"90793e50-0e7d-523b-a01a-edd3233d3daa","fields":{"slug":"/2022-04-25-browsers-repository/"},"frontmatter":{"title":"[web] Storage vs Cookie"}}},{"node":{"id":"b6e54fa8-a7d3-584a-9ecf-288d4447f853","fields":{"slug":"/2022-04-25-redux-saga/"},"frontmatter":{"title":"[redux] Redux Saga"}}},{"node":{"id":"2a064548-9f02-5961-b1fd-ddd288759867","fields":{"slug":"/2022-04-25-hooks/"},"frontmatter":{"title":"[react] React Hooks (리액트 훅스)"}}},{"node":{"id":"bfc8fa0a-6428-5a7f-ae78-1264c36e56d9","fields":{"slug":"/2022-04-25-virtual-dom/"},"frontmatter":{"title":"[react] Virtual Dom (가상 돔)"}}},{"node":{"id":"d9910675-d365-5284-9c30-93a93a2d5fcc","fields":{"slug":"/2022-04-25-async-await/"},"frontmatter":{"title":"[javascript] Async await"}}},{"node":{"id":"12f3c640-b2cd-5cdb-8a6c-8bfe16c4cf87","fields":{"slug":"/2022-04-25-js-runtime/"},"frontmatter":{"title":"[javascript] 자바스크립트 런타임"}}},{"node":{"id":"96dd1868-430e-5558-a4ae-4707f19eec2c","fields":{"slug":"/2022-04-25-promise/"},"frontmatter":{"title":"[javascript] Promise"}}},{"node":{"id":"0481546f-7543-5f1f-af9b-f0ef107366ba","fields":{"slug":"/2022-04-25-throttle-debounce/"},"frontmatter":{"title":"[javascript] throttling과 debouncing"}}},{"node":{"id":"b8f5a7d8-6e73-5cce-a287-a8bd97d590ad","fields":{"slug":"/2022-04-25-url-web/"},"frontmatter":{"title":"[web] 브라우저에 URL을 입력했을 때 발생하는 일들"}}},{"node":{"id":"e3ddc21a-e1b0-56fb-9424-a26a63d3b3fa","fields":{"slug":"/2022-06-12/"},"frontmatter":{"title":"[diary] 성장하는 개발자"}}},{"node":{"id":"a40425b1-a608-5090-b224-4ef330e67298","fields":{"slug":"/2022-08-06-react-query/"},"frontmatter":{"title":"[react] React Query 기초"}}},{"node":{"id":"3cb97112-9e20-5bc8-8938-f2900a32150b","fields":{"slug":"/2022-08-15-recoil/"},"frontmatter":{"title":"[react] Recoil 상태관리 라이브러리"}}},{"node":{"id":"e40f337e-6ce7-571b-a183-087cceb67d25","fields":{"slug":"/2022-11-06-nextjs-13/"},"frontmatter":{"title":"[nextjs] Next.js 13"}}},{"node":{"id":"6df23f2e-58a7-5423-b212-4298c7019cbc","fields":{"slug":"/2023-01-08/"},"frontmatter":{"title":"[diary] 2022년 회고"}}},{"node":{"id":"dc6e27bc-c609-56f6-86d8-97bfeb346561","fields":{"slug":"/2023-01-23-array-to-object/"},"frontmatter":{"title":"[javascript] 배열에서 특정값을 선택해서 객체로 변환하기 (배열을 객체로)"}}},{"node":{"id":"82f7d2e8-2e89-5fe9-94df-4178ad8a5b6a","fields":{"slug":"/2023-03-03-git/"},"frontmatter":{"title":"[git] 실무에서 사용했던 git 정리"}}}]},"previous":{"fields":{"slug":"/2021-10-27-react-firebase/"},"frontmatter":{"title":"[react] firebase 프로젝트 배포하기"}},"next":{"fields":{"slug":"/2021-11-09-algorithm/"},"frontmatter":{"title":"[algorithm] 약수, 소수, 최대공약수, 최소공배수"}}},"pageContext":{"id":"2d4fc9ca-ba49-574a-bfe3-3606aa0d4331","series":null,"previousPostId":"e6286486-8ec3-5662-b1cf-895996e89851","nextPostId":"4d966f89-a26f-5410-a2fa-a41551cd718e"}},"staticQueryHashes":[],"slicesMap":{}}