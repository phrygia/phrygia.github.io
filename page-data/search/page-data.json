{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"프론트엔드 개발자로 입사한지 어느덧 1년 8개월 정도 되었다.\n입사 했을때부터 서버는 Sentry에 연동되어 있었고 Slack으로 알림도 와서 종종 들여다보곤 했으며 사수가 Sentry를 보면서 에러를 해결하는 상황도 종종 옆에서 지켜봤다. \n프론트 개발자 친구가 자신이 다니는 회사 프로젝트에 Sentry를 도입했다는걸 들었을 때도 딱히 별생각이 없었다.…","fields":{"slug":"/2024-02-14-nextjs-with-sentry/"},"frontmatter":{"date":"February 15, 2024","title":"[nextjs] sentry + slack으로 nextjs 에러 모니터링 하기 (slack 채널 연동)","tags":["nextjs","vercel","sentry","slack"]},"rawMarkdownBody":"\n프론트엔드 개발자로 입사한지 어느덧 1년 8개월 정도 되었다.<br>\n입사 했을때부터 서버는 Sentry에 연동되어 있었고 Slack으로 알림도 와서 종종 들여다보곤 했으며 사수가 Sentry를 보면서 에러를 해결하는 상황도 종종 옆에서 지켜봤다. <br><br>\n프론트 개발자 친구가 자신이 다니는 회사 프로젝트에 Sentry를 도입했다는걸 들었을 때도 딱히 별생각이 없었다. 이유는 Nextjs에서 프론트 에러가 나면 내가 먼저 발견하기도 전에 바로 고객문의가 들어오기 때문이었다. (우리의 고객님들 😇..)<br><br>\n그런 내가 회사 Nextjs 파일에 **Sentry를 도입하게 된 이유**는 Nextjs12를 13으로 업그레이드 하려다가 사수한테 빠꾸먹고 이참에 프론트에도 Sentry를 도입해보면 어떻게냐는 제안 때문이었다. <br>\n(Nextjs14가 오지게 욕먹고 있기 때문에 피하고 싶어서 13으로 업그레이드 해본다고 했다가 나중에 14로 업데이트 하라고..)<br>\n\n새로운걸 해보고 싶은 마음과 에러 핸들링이 편하다는 사수의 유혹에 제안을 받아들이고 Sentry를 설치했다.<br>\n\n## 1. Sentry 프로젝트 생성\n\n<a href=\"https://sentry.io/\" target=\"_blank\">https://sentry.io/</a>에 접속하고 로그인/회원가입 한다.<br>\n(나는 팀 소속이라 사수가 나를 초대해줘서 가입했다. 개인/팀 자신의 상황에 따라 가입하면 된다.)\n\n![](img/2024-02-14-nextjs-sentry-01.jpg)\n\n### Projects 만들기\n\nProjects → Create Project → Nextjs 선택 + Project Name 입력 후 생성\n\n![](img/2024-02-14-nextjs-sentry-02.jpg)\n![](img/2024-02-14-nextjs-sentry-3.png)\n\n## 2. 프로젝트에 Sentry 설치\n\n프로젝트를 만들면 다음과 같은 설치 안내창이 나옵니다.\n\n![](img/2024-02-14-nextjs-sentry-4.png)\n\n프로젝트 root 디렉토리 터미널에서 다음 명령어 입력.\n\n```js\nnpx @sentry/wizard@latest -i nextjs\n```\n\n**🚨 생성한 프로젝트를 선택해주세요**\n\n- <span style=\"font-weight:600;\">Are you using Sentry Saas or self-hosted Sentry?</span><br >\n  ㄴ Saas : Sentry 에서 제공하는 클라우드 서비스 <br >\n  ㄴ Self-hosted : 자체 웹서버에 Sentry를 설치하는 방법\n- <span style=\"font-weight:600;\">Do you alreay have a Sentry acoount?</span><br >\n  ㄴ Yes\n- <span style=\"font-weight:600;\">Select your Sentry project</span><br >\n  ㄴ 위에서 생성한 프로젝트 선택\n\n![](img/2024-02-14-nextjs-sentry-5.jpg)\n\n설치가 완료되면 sentry 관련 폴더가 생성된다.<br>\n터미널의 `SENTRY_AUTH_TOKEN`를 복사하여 로컬 환경변수에 추가한다.\n![(왼)자동 파일생성 / (우)환경변수 입력](img/2024-02-14-nextjs-sentry-006.jpg)\n![next.config.js에 senty 관련 코드가 자동으로 생성된 모습](img/2024-02-14-nextjs-sentry-8.png)\n\n## 3. Vercel Sentry Token 환경변수 추가\n\n터미널의 `SENTRY_AUTH_TOKEN` 환경변수 추가\n\n![](img/2024-02-14-nextjs-sentry-9.png)\n\n## 4. Sentry Slack 연동하기\n\n### 1) Sentry 계정에 Slack 워크스페이스 등록하기\n\nSetting → Integrations → Slack → Install\n\n![](img/2024-02-14-nextjs-sentry-10.png)\n\n### 2) Slack에 Sentry 앱 설치하기\n\n앱 추가 → Sentry 검색 → 추가\n\n![](img/2024-02-14-nextjs-sentry-11.png)\n![](img/2024-02-14-nextjs-sentry-12.png)\n\n### 3) 연동할 Slack 채널 ID 복사하기\n\n슬래채널 마우스 오른쪽 클릭 → 채널 세부정보 보기 → 채널 ID 복사\n\n![](img/2024-02-14-nextjs-sentry-013.png)\n![](img/2024-02-14-nextjs-sentry-14.png)\n\n### 4) Slack으로 전송하는 Alert(이벤트) 생성하기\n\nAlerts → Alert 등록할 프로젝트 선택 → Create Alert\n\n![](img/2024-02-14-nextjs-sentry-15.png)\n![](img/2024-02-14-nextjs-sentry-16.png)\n\n- Set conditions에 local과 개발서버 제외하는 필터 추가하기. <br>\n- Slack 워크스페이스 선택 → 복사한 ID와 채널 이름 입력.\n\n![](img/2024-02-14-nextjs-sentry-17.png)\n\n## 에러 이벤트 로그 💻\n\n설정하면 다양한 에러가 Slack으로 전송된다. 라이브러리, 결제모듈 등에서 catch로 발생하는 에러도 Sentry 이슈로 전송된다. 내가 작성한 코드에서의 에러도 잡아내지만 프론트에 설치된 라이브러리의 에러도 잡아내는듯 하다. Sentry에서 보내는 모든 에러를 수정할 필요는 없을 듯 하다.\n\n![](img/2024-02-14-nextjs-sentry-18.png)\n![](img/2024-02-14-nextjs-sentry-19.png)\n"},{"excerpt":"회사에서 VIP를 상대로 한 연말 프로모션 페이지를 만들기 위해 한장한장 카드를 넘기는듯한 UI가 필요했습니다. 저희 회사는 기존에 Swiper를 사용하고 있었기 때문에 평소 자주 사이트를 방문하는 편이었고 전에 demo 페이지에서 봤던 기억을 떠올렸습니다. Effect cards 효과를 디자이너분께 보여드렸더니 생각했던것과 똑같다고 해주셔서 이걸 사용해…","fields":{"slug":"/2023-12-11-npm-install/"},"frontmatter":{"date":"December 11, 2023","title":"[npm/yarn] 한 프로젝트에서 같은 라이브러리 다른 버전 설치하기","tags":["react"]},"rawMarkdownBody":"\n회사에서 VIP를 상대로 한 연말 프로모션 페이지를 만들기 위해 한장한장 카드를 넘기는듯한 UI가 필요했습니다. 저희 회사는 기존에 <a href=\"https://swiperjs.com/demos\" targer=\"_blank\">Swiper</a>를 사용하고 있었기 때문에 평소 자주 사이트를 방문하는 편이었고 전에 demo 페이지에서 봤던 기억을 떠올렸습니다. Effect cards 효과를 디자이너분께 보여드렸더니 생각했던것과 똑같다고 해주셔서 이걸 사용해서 작업을 하기로 했습니다.\n\n<div style=\"max-width:380px; margin-left:auto; margin-right:auto;\">\n\n![](img/2023-12-11-swiper.gif)\n\n</div>\n\n```js\n// package.json\n{\n    \"swiper\": \"^6.8.0\",\n}\n```\n\n그런데 한가지 문제가 있었습니다. 저희 회사 홈페이지는 2년도 전에 만들었기 때문에 낮은 버전의 swiper가 깔려있다는게 문제였죠. Effect cards 7.0.0부터 사용이 가능합니다. 무작정 버전을 업그레이드 하기엔 import를 불러오는 형태가 다르기 때문에 기존에 사용하던 수많은 코드를 수정해야 하는 문제가 있습니다. 산더미같이 쌓여있는 프로젝트때문에 많은 시간을 할애 할수도 없는게 직장인의 슬픈 현실이죠 🥲\n\n줄서있는 프로젝트를 제치고 급하게 연말 프로젝트로 들어온 일이었기 때문에 빠른 작업이 중요했습니다. 제가 직접 구현하는 것보다 라이브러리를 사용하는게 훨씬 속도가 빠르겠지만 모든 파일을 수정할수도 없는 노릇이었죠.\n그래서 고민을 하다 생각한 방법이 같은 라이브러리를 다른 버전으로 설치하는 방법이었습니다. (권장하진 않습니다. 빠른 구현을 위해 어쩔수 없다고 합리화 했습니다.) 나중에 꼭 삭제하리라 마음먹고(혹시 구버전을 삭제하고 신버전으로 교체) 구글링하고 적용해 보았습니다.\n\n```js\nnpm install <alias>@npm:<라이브러리명>\nyarn add <alias>@npm:<라이브러리명>\n\n// npm install swiper-lastest@npm:swiper@latest - 최신버전 설치\n// npm install swiper-lastest@npm:swiper@11.0.5 - 특정버전 설치\n```\n\n이렇게 설치하면 package.json에 새롭게 라이브러리가 추가되고 node_modules에는 swiper-latest라는 폴더가 생성되었습니다.\n\n```js\n// package.json\n{\n    \"swiper\": \"^6.8.4\",\n    \"swiper-latest\": \"npm:swiper@^11.0.5\",\n}\n```\n\n![node_modules](img/2023-12-11-swiper2.png)\n\n파일에서는 이렇게 불러오면 잘 작동하는 걸 볼 수 있습니다!\n\n```js\nimport { Swiper, SwiperSlide } from \"swiper-latest/react\"\nimport { EffectCards, Pagination } from \"swiper-latest/modules\"\n\nimport \"swiper-latest/css/effect-cards\"\n```\n\n<div style=\"max-width:380px; margin-left:auto; margin-right:auto;\">\n\n![](img/2023-12-11-swiper3.gif)\n\n</div>\n\n시간이 넉넉하다면 기존 라이브러리 버전을 업데이트 해서 파일들을 수정하는 방식을 권장하지만, 저처럼 시간이 매우 촉박한(😂) 개발자에겐 유용한 방법이라고 생각됩니다. <br > \\*참고한 사이에서는 <u>점진적으로 업그레이드</u> 하기 위한 하나의 방법으로 소개하기도 합니다.<br ><br >\n\n<small class=\"from add\">참고 : <a href=\"https://www.nieknijland.nl/blog/use-multiple-versions-of-an-npm-package-at-the-same-time\" target=\"_blank\">https://www.nieknijland.nl/blog/use-multiple-versions-of-an-npm-package-at-the-same-time</a>\n</small>\n"},{"excerpt":"허겁지겁 코드를 작성하고 일정에 쫓겨 디자인을 따라하기에 급급해 성능따위 무시했던 신입 1년.. \n최근 개발에 많이 익숙해지면서 성능 및 최적화에 흥미가 생겼습니다. \n그중 제일 쉽게 사용할 수 있는게 구글에서 개발한 크롬 웹사이트 성능 측정 도구인 Lighthouse입니다.  Lighthouse는 크롬 개발자도구, 크롬익스텐션, npm 라이브러리(nod…","fields":{"slug":"/2023-11-19-light-house/"},"frontmatter":{"date":"November 19, 2023","title":"[web] Lighthouse 웹페이지 성능분석 (Performance)","tags":["web"]},"rawMarkdownBody":"\n허겁지겁 코드를 작성하고 일정에 쫓겨 디자인을 따라하기에 급급해 성능따위 무시했던 신입 1년.. <br>\n최근 개발에 많이 익숙해지면서 성능 및 최적화에 흥미가 생겼습니다. <br>\n그중 제일 쉽게 사용할 수 있는게 구글에서 개발한 크롬 웹사이트 성능 측정 도구인 Lighthouse입니다. <br >\n\nLighthouse는 크롬 개발자도구, <a href=\"https://chromewebstore.google.com/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk\" target=\"_blank\">크롬익스텐션</a>, <a href=\"https://www.npmjs.com/package/lighthouse\" target=\"_blank\">npm 라이브러리(node)</a>로 사용할 수 있습니다. 2020년 5월 19일 Lighthouse 개발자 도구에서 Lighthouse를 이용할 수 있게 되면서 별도의 설치없이 쉽게 사용할 수 있게되었기 때문에 여기서는 개발자 도구를 사용한 성능 분석을 해보겠습니다.\n\n## Lighthouse\n\n크롬 개발자 도구 (맥: command + option + i, 윈도우: F12)의 Lighthouse 탭의 모습입니다.\n![](img/2023-11-19-light-house-01.jpg)\n\n> <strong>Mode</strong> <br><strong>· Navigation</strong> : 기본값. 초기 페이지 로딩 시 발생하는 성능 문제를 분석합니다.<br> <strong>· Timespan</strong> : 사용자가 정의한 시간 동안 발생한 성능 문제를 분석합니다.<br> <strong>· Snapshop</strong> : 현재 상태의 성능 문제를 분석합니다. <br>\n\n> <strong>Categories</strong> <br><strong>· Performance</strong> : 웹 페이지의 로딩 과정에서 발생하는 성능 문제를 분석합니다.<br> <strong>· Accessibility</strong> : 서비스의 사용자 접근성 문제를 분석합니다.<br> <strong>· Best paractices</strong> : 웹사이트의 보안 측면과 웹 개발의 최신 표준에 중점을 두고 분석합니다. <br><strong>· SEO</strong> : 검색 엔진에서 얼마나 잘 크롤링되고 검색 결과에 표시되는지 분석합니다. <br> <strong>· Progressive Web App</strong> : 서비스 워커와 오프라인 동작 등, PWA와 관련된 문제를 분석합니다. <br>\n\n> <strong>Plugins</strong> <br><strong>· Publisher Ads</strong> : 광고 속도와 전반적인 품질을 개선해 주는 도구입니다. (광고 구현 최적화)<br><br><strong>Device</strong> <br> <strong>· Mobile</strong><br><strong>· Desktop</strong>\n\n## Performance 분석하기\n\n![](img/2023-11-19-light-house-02.jpg)\n제 블로그 https://phrygia.github.io/를 Lighthouse의 기본 선택값+desktop으로 분석한 결과입니다. (\\*저는 만들어진 테마를 사용하기 때문에 제가 코딩한건 아닙니다.)\n\n![](img/2023-11-19-light-house-03.jpg)\n![](img/2023-11-19-light-house-04.jpg)\n\n숫자 94는 Lighthouse가 측정한 웹 페이지의 종합 성능 점수 입니다. 이 점수는 METRICS에 보이는 5가지 지표에 가중치를 적용해 평균 낸 점수입니다.\n\n<table class=\"ph_tbl\">\n  <tr>\n    <th>Audit (검사 항목)</th>\n    <th>Weight (가중치)</th>\n  </tr>\n  <tr>\n    <th>\n    First Contentful Paint(FCP)\n    </th>\n    <td>\n    10%\n    </td>\n  </tr>\n   <tr>\n    <th>\n    Largest Contentful Paint(LCP)\n    </th>\n    <td>\n    25%\n    </td>\n  </tr>\n   <tr>\n    <th>\n    Total Blocking Time(TBT)\n    </th>\n    <td>\n    30%\n    </td>\n  </tr>\n   <tr>\n    <th>\n    Cumulative Layout Shift(CLS)\n    </th>\n    <td>\n    25%\n    </td>\n  </tr>\n   <tr>\n    <th>\n    Speed Index(SI)\n    </th>\n    <td>\n    10%\n    </td>\n  </tr>\n</table>\n\n**1. First Contentful Paint(FCP)** : 페이지가 로드될 때 브라우저가 DOM 콘텐츠의 첫 번째 부분을 렌더링 하는데 걸리는 시간에 관한 지표입니다. 제 결과에서 페이지에 진입하여 첫 콘텐츠가 뜨기까지 0.7초가 걸렸습니다.\n\n**2. Largest Contentful Paint(LCP)** : 페이지가 로드될 때 화면 내에 있는 가장 큰 이미지나 텍스트 요소가 렌더링되기까지 걸리는 시간을 나타내는 지표입니다. 제 결과에서 페이지에 진입하여 가장 큰 콘텐츠가 뜨기까지 0.8초가 걸렸습니다.\n\n**3. Total Blocking Time(TBT)** : 페이지가 클릭, 키보드 입력 등의 사용자와 페이지가 상호작용한 경우 해당 요청을 처리하는 시간을 총합한 지표입니다. 응답이 길어지는 경우 (50ms이상) 사용자가 불쾌감을 느끼기 시작합니다.\n\n**4. Cumulative Layout Shift(CLS)** : 페이지 로드 과정에서 발생하는 예기치 못한 레이아웃 이동을 측정한 지표입니다. \\*레이아웃 이동 : 화면상에서 요소의 위치나 크기가 순간적으로 변하는 것\n\n**5. Speed Index(SI)** : 페이지 로드중에 콘텐츠가 시각적으로 표시되는 속도를 나타내는 지표로 페이지가 얼마나 빠르게 화면에 채워지는지를 의미합니다.\n\n![출처: 프론트엔드 성능 최적화 가이드 14P 그림 1-9 Speed Index 측정 예시](img/2023-11-19-light-house-05.jpg)\nA페이지와 B페이지를 각각 로드했을때 두 페이지 모두 렌더링까지 4초라는 동일한 시간이 걸렸습니다. A의 경우 일부 콘텐츠가 B페이지도가 먼저 떴으며 이런 경우 B 페이지보다 더 빨리 로드된 것으로 계산되며 더 높은 점수를 받습니다. (B는 4초동안 빈화면이 보일것이므로 사용자 이탈이 일어날 가능성도 큽니다)\n\n![출처: 프론트엔드 성능 최적화 가이드 2P](img/2023-11-19-light-house-06.jpg)\n실제로 1초에서 3초로 느려진 경우, 사용자 이탈률이 32%로 증가한다고하니 제 블로그 2.5s도 위험하군요.. 🥲 (많이 읽어주세요)\n\n<!-- https://www.youtube.com/watch?v=aO-z9YmxOUk&t=1106s -->\n\n### OPPORTUNITIES / DIAGNOSTICS\n\n![출처: 프론트엔드 성능 최적화 가이드 2P](img/2023-11-19-light-house-07.jpg)\n5가지 지표 아래쪽의 위치한 섹션으로 웹 페이지의 문제점과 해결 방안 및 이점이 무엇인지 보여줍니다.\n**OPPORTUNITIES**: 페이지를 더욱 빨리 로드하는 데 잠재적으로 도움되는 제안들을 보여줍니다. <br>\n**DIAGNOSTICS**: 성능과 관련된 기타 정보를 보여줍니다. (로드 속도와 직접적인 관계X)\n\n해당 섹션의 해결방안을 따라하다보면 사이트의 성능이 좋아질 수 있습니다. (제가 다니는 회사 사이트 성능이 똥망이라 다음에 이걸 해결한 포스팅을 작성해 보면 좋겠네요. 매일 밀려있는 개발일정때문에 성능최적화 시도도 못하고 있는데 내년엔 꼭 개선하는걸 목표로 공부해 보겠습니다.)\n\n<small class=\"from add\">참고 : 프론트엔드 성능 최적화 가이드 (서적)<br><a href=\"https://blog.imqa.io/web-performance-index/\" target=\"_blank\">https://blog.imqa.io/web-performance-index/</a></small>\n"},{"excerpt":"Nextjs로 자사 브랜드를 2개 운영중인 회사의 프론트엔드 개발자로 일하고 있는 필자는 어느순간부터 vercel에 접속할때마다 이런 문구를 발견했다.\n \n\n2023년 8월 15일부터 새로운 빌드가 적용되지 않는다니😱😱 \n2개 프로젝트 모두 node 14로 되어있기 때문에 사수는 8월 15일 전까지만 적용하면 된다고 했다.. (그치만 아직 1년된 쪼렙이 …","fields":{"slug":"/2023-08-15-vercel-node-version-update/"},"frontmatter":{"date":"August 15, 2023","title":"[nextjs] nextjs node버전 업데이트 여정 (tailwind custom class error)","tags":["nextjs","tailwind","react"]},"rawMarkdownBody":"\nNextjs로 자사 브랜드를 2개 운영중인 회사의 프론트엔드 개발자로 일하고 있는 필자는 어느순간부터 vercel에 접속할때마다 이런 문구를 발견했다.<br />\n`Node 14.x is depercated. New builds will be disabled on August 15th 2023` <br />\n![](img/2023-08-15-vercel-node-version-update-01.png)\n2023년 8월 15일부터 새로운 빌드가 적용되지 않는다니😱😱 <br />\n2개 프로젝트 모두 node 14로 되어있기 때문에 사수는 8월 15일 전까지만 적용하면 된다고 했다.. (그치만 아직 1년된 쪼렙이 괜히 건들였다가 프러덕션에서 문제 생기면 어쩌지 하는 걱정이 컸다.) <br />\n프로젝트 1개는 작년 3분기~올해 1분기에 걸쳐 내가 만들어서 비교적 최신버전을 유지하고 있었기 때문에 상관없었지만, 나머지 1개는 사수가 몇년전에 만들어서 nextjs와 react 버전 자체가 낮았다. 새로운 npm 라이브러리를 설치할때마다 의존성 문제때문에 설치가 되지 않아 `npm install --lagacy-peer-deps`로 강제로 설치하고 있던 상태였다. `npm install --forc`로도 설치가되지 않아 더 강제적으로 설치해야만 했던 지난 날들..\n(변명을 하자면 이걸 먼저 해결했었어야 됐는데 회사 개발만으로 항상 바쁘기 때문에 건드리지도 못했었다. 변명이지만..) <br />\n어쨋든 무조건 node 버전을 업데이트 해야된 순간이 왔다. option으론 16.x와 18.x 가 있었기 때문에 쫄보는 16.x로 업데이트 하려고 했다.\n![](img/2023-08-15-vercel-node-version-update-07.png)\n\n아니 이보시게, 16.x도 2024년 2월 6일부터 안된다구요? 그럼 무조건 18.x로 해야되는거잖아😱 (18.x가 가장 최상위 버전이기때문에 지원 중단예정에 없다.)\n![](img/2023-08-15-vercel-node-version-update-06.png)\n\n어쩔수 없이 반강제로 18.x로 업데이트 여정이 시작되었다. <br />\n(여담으로 내가 만들었던 프로젝트는 갑작스러운 수정요청이 들어왔을때 18.x로 바꿔놓은지 모르고 배포를 했는데 프로젝트가 나름 최신버전으로 되어있었기 때문인지 에러없이 성공적으로 업데이트가 됐다. 얼떨결에 업데이트가 된 샘이다.)\n\n### 18.x 업데이트 에러발생\n\n오래된 버전의 nextjs node버전을 18.x로 수정하고 배포해보았지만.. 역시나 에러가 발생했다. 에러의 원인은 tailwind custom class. 많은 css 파일에서 @apply로 custom class 사용하고 있었기 때문에 tailwind를 다 떼버리긴 쉽지 않았다. 방법을 찾아야했다. 또한 `npm install --lagacy-peer-deps`없이 라이브러리가 설치되지 않는 것도 해결해야 했다. 어차피 시작한거 의존성문제를 위해 react와 nextjs 버전도 업데이트 하기로 결정했다.\n![](img/2023-08-15-vercel-node-version-update-02.png)\n\n#### 1. 라이브러리 버전 업데이트 및 정리\n\n<div style=\"max-width: 400px;\">\n\n![](img/2023-08-15-vercel-node-version-update-03.jpg)\n\n</div>\n\n의존성 에러가 발생했던 이유는 오래된 next 버전과 react 버전이 원인이었던 것 같다. next 13까지 나온 상황에서 11.1.2를 사용하고 있었다.. 13버전은 디렉토리 구조와 next 문법이 많이 달라졌기 때문에 13까지 업데이트 하는건 무리라고 판단해 12에서 가장 높은 12.3.4로 업데이트 하고 리액트로 17에서 가장 최신인 17.0.2로 업데이트 했다. <br />\n이로 인해 또다른 문제가 발생했는데 업데이트가 되지않는 오래된 라이브러리들에서 에러가 발생했고 아직 `npm i` 로 설치되지 않았다.\n이에 사용중이던 라이브러리들에 대한 버전을 찾아 설치하고 (너무 최신이면 또 에러가 발생한다.) 지원이 안되는 오래된 라이브러리들도 정리하여 새로운 라이브러리로 대체하자 정상적으로 설치가 되기 시작했다.\n\n#### 2. tailwind custom class 에러\n\n아직 tailwind custom class 때문에 여전히 많은 error가 발생했고 계속된 빌드 실패...\n(이전에 npm run build를 사용해 본적이 없었기때문에 빌드 하고 확인 빌드 확인을 반복하다 vecel이 error로 뒤덮혔는데.. 이상황에 build를 사용하면 되는 거였었다.. 사수도 나도 사용안해봐서 몰랐던 부분으로 내가 build쓰면 배포때와 동일한 에러를 볼수 있다고 알려드렸다.)\n![](img/2023-08-15-vercel-node-version-update-04.png)\n\n기존의 custom class는 이렇게 css파일안에 코딩되어있었는데 왜인지 모르겠으나 node 18.x에서는 이 파일을 제대로 읽어들이지 못하는 것 같았다.\n\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer utilities {\n  .ellipsis1 {\n    @apply whitespace-nowrap overflow-hidden overflow-ellipsis;\n  }\n}\n\n@tailwind variants;\n```\n\n이 문제를 해결하기위해 2일은 넘게 뻘짓을 하다가 결국 사수에게 sos..\n![](img/2023-08-15-vercel-node-version-update-05.png)\n그때부터 사수도 같이 고민하기 시작했고 사수가 해결해 줬다. (사수가 해결해 준 방법은 나도 적용해봤던건데 코드작성에 문제가 있었는지 해결되지 않았었다.. 결국 방법을 눈앞에 두고 나는 온갖 뻘짓을 한것.. **좀더 꼼꼼히 살펴보자**고 다시한번 느끼는 계기가 되었다. 정신차리자)\n\n#### 3. tailwind custom class 플러그인화\n\n왜 @layer안에 있는 코드를 불러오지 못하는지 이해가 되지 않아 검색하다가 발견한 블로그인데, 이분은 vue/svelte를 예시로 말씀해 주시지만 react도 비슷한 맥락을 가지고 있다고 생각하면 이해가 된다.\nreact가 &#60;style&#62;블록과 postCSS 플러그인 체인을 각각 독립적으로 실행하기 때문에 커스텀 클래스가 존재하는지 몰라 에러가 발생한다. 해결 방법은 plugin system을 사용하여 구성 요소에 '@apply'할 custom class 스타일을 정의하면 된다. <br />\n(그럼 왜 이전에는 된거지? 🤔 아마 nextjs react 버전의 문제라고는 생각한다..)\n![https://19-97.tistory.com/159](img/2023-08-15-vercel-node-version-update-09.png)\n\n![https://v2.tailwindcss.com/docs/adding-new-utilities](img/2023-08-15-vercel-node-version-update-08.png)\n\n기존의 css파일 @layer 안에 있던 코드를 tailwind.config.js 파일로 옮긴후 배포했더니 더이상의 에러 없이 18.x 버전으로 업데이트 되었다.\n![](img/2023-08-15-vercel-node-version-update-10.png)\n\n라이브러리 버전 및 tailwind 에러때문에 업데이트완료까지 3일이상의 시간이 걸렸었다. 내가 좀더 꼼꼼하고 자세히 봤었다면 사수의 도움없이도 해결될 수 있었던 문제였는데 아쉬운 마음이 든다. 앞으로는 좀더 주도적이고 꼼꼼하게 살펴보면서 왜 안되는지에 대한 원인도 정확하게 파악해봐야 겠다는 생각이 든다. 시간이 조금 걸리긴 했지만 업데이트 후 에러도 없고 의존성 문제도 해결해서 약간의 자신감과 동시에 주눅이 드는 시간이었던 것 같다.\n"},{"excerpt":"프론트엔드 개발자로 일한지 7개월정도가 되었다. 퍼블리셔로 오래 지내면서 git은 거의 사용해 본 적이 없었고 (아주 간단하게 사용) 사용하더라도 git GUI인 소스트리를 사용해 git 명령어를 거의 모르는 상태였다고 봐도 무방했다.\n물론 개발자로 이직 준비하면서 git에 대해 공부하긴 했었지만 혼자하는 공부는 한계가 있고 conflict나는 상황이 거…","fields":{"slug":"/2023-03-03-git/"},"frontmatter":{"date":"March 03, 2023","title":"[git] 실무에서 사용했던 git 정리","tags":["git"]},"rawMarkdownBody":"\n프론트엔드 개발자로 일한지 7개월정도가 되었다. 퍼블리셔로 오래 지내면서 git은 거의 사용해 본 적이 없었고 (아주 간단하게 사용) 사용하더라도 git GUI인 소스트리를 사용해 git 명령어를 거의 모르는 상태였다고 봐도 무방했다.\n물론 개발자로 이직 준비하면서 git에 대해 공부하긴 했었지만 혼자하는 공부는 한계가 있고 conflict나는 상황이 거의 없기 때문에 단편적인 git만 사용했던 것 같다.\n\n7개월동안 일하면서 자주 쓰던 git 명령어에 대해 정리해 보려고 한다.\n\n## git remote\n\n나는 회사에서는 회사 맥북, 집에서는 내 맥북으로 일을 한다. 💻 (처음엔 회사맥북을 가지고 다녔는데 출퇴근 시간이 길다보니 피로도가 어마어마하고 재택때문에 항상 노트북을 가지고 다니는게 힘들어서 집의 맥북으로 개발을 하게 되었다.)<br>\n퇴근전에 일을 끝내지 못했다면 다음날 이어서 작업을 해야되는데 노트북이 다른 경우가 많다보니 원격 저장소에 push를 한 후 다음날 pull을 받는 편인데 원격 저장소의 새로운 브랜치가 자동으로 반영되는게 아니다보니 `remote`는 자주 쓰는 명령어가 되었다.\n\n```bash\n# 현재 프로젝트에 등록된 원격 저장소를 확인 - 저장소를 Clone 하면 `origin`이라는 원격 저장소가 자동으로 등록되기 때문에 `origin` 출력됨\ngit remote\n\n# 원격 저장소의 브랜치 가져오기 (삭제 X)\ngit remote update\n\n# 원격 저장소에 존재하지 않는 브랜치들은 로컬에 반영하여 삭제 진행\ngit remote update --prune\ngit remote prune origin\n\n# 원격 저장소에 어떤 브랜치들이 존재하지와 저장소의 구체적인 정보 확인\ngit remote show origin\n\n# +원격 저장소 브랜치 가져오기\ngit checkout -t origin/[브랜치명]\n\n## remote와 관련된 다양한 명령어 → 추가 공부\n\n# 현재 프로젝트에 등록된 원격 저장소 확인\ngit remote -v\n\n# 원격 저장소 추가\ngit remote add [이름] [url]\ngit remote add secondOrigin git://github.com/test/test.git\n\n# 원격 저장소의 이름 변경\ngit remote rename [현재이름] [바꿀이름]\n\n# 원격 저장소 삭제\ngit remote remove [현재이름]\ngit remote remove origin\ngit remote rm origin\n```\n\n## git branch\n\n```bash\n# 로컬 브랜치 목록 조회\ngit branch\n\n# 원격 저장소의 브랜치 목록 조회\ngit branch -r\n\n# 모든 브랜치 목록 조회\ngit branch -a\n\n# 로컬 브랜치명 변경\ngit branch -m [현재브랜치명] [바뀔브랜치명]\n\n\n## 원격 브랜치명 변경\n# 원격 저장소의 브랜치명은 변경이 불가능하기 때문에\n# → 로컬에서 이름 변경 후\n# → 원격 브랜치에 push (새롭게 브랜치가 생성됨)\n# → 원격 브랜치 삭제 (기존 브랜치)\ngit checkout [현재브랜치명]\ngit branch -m [현재브랜치명] [바뀔브랜치명]\ngit push origin -u [바뀔브랜치명]\ngit push origin --delete [현재브랜치명]\n```\n\n#### -u 옵션\n\ngit push -u origin develop\n→ u 옵션을 사용하면 최초 한 번만 저장소명과 브랜치명을 입력하고 그 이후는 입력 생략 가능 (git push)\n\n1. 회사 원격 저장소에 연결되었고 재택근무 중 git branch -a로 모든 브랜치 목록 조회 (실제 원격 저장소와 다름)<br>\n2. git remote update --prune<br>\n   &nbsp;&nbsp;&nbsp;&nbsp;→ 4개의 원격 브랜치가 삭제됨 <br>\n3. git branch -r로 남아있는 원격 브랜치 확인<br>\n   &nbsp;&nbsp;&nbsp;&nbsp;(동일한 브랜치명으로 작업할 수 있기때문에 꼭 작업시작전 업데이트가 필요함)\n\n![](img/2023-03-03-1.jpeg)\n\n## git rebase\n\n우리회사는 원래 develop에서 pull을 받고 새로운 브랜치를 만들어서 개발을 해야 하는데 초반에는 가끔 까먹고 내가 작업하던 브랜치에서 새로운 브랜치를 생성해서 개발을 하기도 했다. 그럼 develop에 PR 요청을 하면 conflict가 나기도 했는데 그때 사수가 알려줬던게 rebase다. 내가 브랜치에서 작업하고 있는 동안 develop 에 적용된 커밋들을 나의 브랜치에 적용하기 위해서 rebase를 사용한다.\n`rebase`는 말 그대로 베이스를 다시 배치한다는 뜻이다. 같이 비교되는 것중 `merge`가 있다.\n\n- merge : merge를 사용해서 최신 이력을 가져올 경우, 히스토리의 뿌리가 여러개고 나눠져 있어 복잡하고 어려운 커밋 히스토리를 가지게 된다. (안전)\n- rebase : 베이스를 다시 정의함으로써 깔끔한 커밋 히스토리를 가지게 된다. (위험)\n\n```bash\ngit rebase [브랜치명]\n```\n\n## commit 메시지 수정\n\n```bash\n# 로컬의 마지막 commit 메시지 수정하기\ngit commit --amend\ngit commit --amend -m \"새로운 메시지\"\n\n# 이전 commit 메시지 수정하기\ngit log  # 이전 커밋의 hash값\ngit rebase -i [해쉬]\ngit rebase -i HEAD~3  # 최근 3개의 커밋 메시지 불러옴\n\n# 원격저장소에 push된 커밋 수정 - 최대한 사용하지 말기\ngit push --force [브랜치명]\n```\n\n#### -i 옵션\n\ngit rebase -i HEAD~3\n→ rebase명령을 대화형으로 수행하여 여러 커밋들의 순서를 바꾸거나 커밋 히스토리를 변경/삭제하고 싶을때 사용하는 옵션\n\n#### --force\n\n> We strongly discourage force pushing, since this changes the history of your repository. If you force push, people who have already cloned your repository will have to manually fix their local history. For more information, see \"Recovering from upstream rebase\" in the Git manual.\n\n공식문서에서는 리포지토리의 기록이 변경되므로 변경을 권하지 않고 있다.\n\n## git cherry-pick\n\n내가 작업한 내용을 develop까지는 합쳤는데 실제 배포일시가 미뤄지면서 해당 브랜치가 master에 포함되면 안되는 상황이 발생했다. 이떄 사수님이 썼던 명령어가 `cherry-pick`!! <br>\n`cherry-pick`이란 다른 브랜치에 있는 커밋을 선택적으로 현재 브랜치에 적용시킬 때 사용하는 명령어다. <br>\n\n```bash\ngit cherry-pick [hash]\n\n# cherry-pick 중단 (실행하기 전 코드로 되돌아감)\ngit cherry-pick -abort\n\n# conflict난 코드를 수정 → git add로 추가 → git cherry-pick -continue로 충돌한 코드 반영 및 cheey-pick 실행\ngit cherry-pick -continue\n\n```\n\n## reset --hard로 날려먹은 작업내역 복구하기\n\n작업을 하다보면 이전 commit 으로 되돌아가고 싶을때가 있다. 이때 `reset`을 사용한다. 나는 새롭게 작업한 내역이 필요가 없다면 `--reset` 옵션으로 작업내역이 필요하다면 `--soft` 옵션을 사용한다.\n\n- --hard : 돌아간 커밋 이후의 commit들 (변경이력) 삭제\n- --mixed : 변경 이력은 모두 삭제되지만 변경 내용은 남아있다. (unstaged 상태)\n- --soft : 변경 이력은 모두 삭제되지만 변경 되용은 남아있다. (stage 상태)\n\n```bash\ngit reset HEAD^\ngit reset HEAD~2\ngit reset [hash]\n\ngit reset --hard [hash]\ngit reset --mixed [hash]\ngit reset --soft [hash]\n```\n\n얼마전 작업을 하다가 특정 커밋으로 되돌아가야 하는 때가 있었는데 이후에 커밋된 내용들이 있었다. (새로운 개발내용) 근데 개발하느라 멘탈이 약간 나가있는 상태에서 확인을 잘 안하고 무작정 `reset --hard`를 하고 난 후에 개발했던 부분들이 로컬에서 날아갔다는걸 깨달았다. (심지어 github에서 history도 없었음) 🤯 <br>\n`reset --hard`로 복구할 수 있다는걸 알게되어 복구 후 다시 똑같은 개발을 하지 않아도 되서 좋이한 적이 있다.\n\n![](img/2023-03-03-2.jpeg)\n\n```bash\n# 이전 커밋 목록 보가\ngit reflog\n\n# 다시 reset으로 커밋 복구 → 이상태로 원격 저장소에 안올라감\ngit reset --hard [hash]\n\n# 강제로 원격 브랜치에 업로드\ngit push -f origin [브랜치명]\n\n\n## 위의 예제에서\ngit reset --hard a44789d\ngit reset --hard HEAD~6\n```\n\n## PR로 Review 받은 코드 수정한 후 재 commit (원격 저장소에 올라간 커밋내역 수정)\n\n![](img/2023-03-03-3.jpeg)\n\n내가 개발한 코드를 사수님께 PR (Pull Request) 요청하면 사수님이 확인 후 merge 하거나 Review를 남겨준다. 그럼 내가 그 리뷰를 보고 수정해서 다시 커밋해야 되는데 입사한지 얼마 안됐을때는 방법을 몰라서 리뷰받은 PR을 강제로 닫은 후 원격에 올라간 브랜치를 삭제하고 다시 브랜치를 push 한다음 새로운 PR을 요청했던 적이 있었다. (엄청난 삽질..🤪)\n나중에 제대로 된 검색을 통해 방법을 알게 되었고 종종 이 방법을 유용하게 사용하고 있다.\n\n```bash\n\n# 1. 수정한 코드 추가\ngit add .\n\n# 2. 최신 commit 덮어쓰기\ngit commit --amend\n\n# 3. 코드 변경을 강제로 원격 저장소에 반영 (*충돌 가능성이 있어 같은 브랜치를 여러명이 수정할땐 사용하지 않는게 좋음)\ngit push -f origin [브랜치명]\n\n```\n"},{"excerpt":"회사에서 개발하던 중 선택된 상품의 배열에서 각 상품의 와 를 추출해서 결제페이지로 넘겨주는 로직을 개발하고 있었다.  *api 값\n *api에서 추출하려는 값 우선 장바구니 상품들중 선택한 상품을 id로 필터하고 map으로 store_key키만 추출한 다음 reduce안에서 다시 filter해서 해당 상품의 수량을 붙여서 코딩을 했다..\n(진짜 부끄럽고…","fields":{"slug":"/2023-01-23-array-to-object/"},"frontmatter":{"date":"January 22, 2023","title":"[javascript] 배열에서 특정값을 선택해서 객체로 변환하기 (배열을 객체로)","tags":["javascript"]},"rawMarkdownBody":"\n회사에서 개발하던 중 선택된 상품의 배열에서 각 상품의 `store_key`와 `quantity`를 추출해서 결제페이지로 넘겨주는 로직을 개발하고 있었다.\n\n<div style=\"max-width: 350px\">\n\n![장바구니](img/2023-01-22.jpg)\n\n</div>\n\n**\\*api 값**\n![api](img/2023-01-22-1.jpg)\n\n**\\*api에서 추출하려는 값**\n\n```js\n// { store_key: quantity } 딕셔너리 형식\n{ 99ngh08: 2, 5gxyt1q: 1, 3ifu0ie: 1 }\n```\n\n우선 장바구니 상품들중 선택한 상품을 id로 필터하고 map으로 store_key키만 추출한 다음 reduce안에서 다시 filter해서 해당 상품의 수량을 붙여서 코딩을 했다..<br>\n(진짜 부끄럽고 지저분하고 개발자답지 못한 코드.. 🤪)\n<br><br>\n\n**\\*기존코드**\n\n```js\n// listItems [선택한 상품의 정보 배열값]\nconst filteredKey = listItems\n  .filter(item => checkedIds.includes(item.id))\n  .map(item => item.store_key)\n  .reduce((acc, cur) => {\n    const arr: { [key: string]: number } = acc\n\n    arr[cur] = listItems.filter(v => v.store_key === cur)[0]?.quantity\n\n    return arr\n  }, {})\n```\n\n개발하고 나서 코드가 너무 말이 안되는것 같아서 배열을 객체로 바꾸는 법을 검색해서 새로운 코드를 적용해 보았다.\n\n```js\nconst filteredArray = listItems\n  .filter(item => checkedIds.includes(item.id))\n  .map(item => [item.store_key, item.quantity])\n/*\nfilteredArray 출력결과\n[\n  ['99ngh08', 2],\n  ['5gxyt1q', 1],\n  ['3ifu0ie', 1],\n];\n*/\n\nconst arrayToObject = Object.fromEntries(filteredArray)\n/*\narrayToObject 출력결과\n{ 99ngh08: 2, 5gxyt1q: 1, 3ifu0ie: 1 }\n*/\n```\n\nOMG.. 훨씬 깔끔한 코드가 완성됐다. (개인적으로 reduce가 들어가는 순간 깔끔함이 사라진다고 생각하는 사람..)\n\n**\\*lodash 사용 (+ 2023.11.19)**\n\n울 회사는 lodash를 사용하고 있다. 최근 lodash로 사용하는 방법도 알게되었다.\n\n```js\nimport _ from \"lodash\"\n\nconst filteredArray = _.chain(listItems)\n  .keyBy(\"store_key\")\n  .mapValues(\"quantity\")\n  .value()\n\n/*\nfilteredArray 출력결과\n{ 99ngh08: 2, 5gxyt1q: 1, 3ifu0ie: 1 }\n*/\n```\n\n## Obejct.fromEntries ?\n\n<div class=\"blockquote\">\n    Object.fromEntries(iterable)\n</div>  \nObject.fromEntries() 메서드는 키-값(key-value) 요소를 갖고 있는 Array를 객체로 바꿔준다. <br>\n매개변수 : 반복 가능한 객체. Array, Map 등의 반복 규약을 구현한 객체\n\n```js\n// 인자로 배열 넘겨줄 때\nconst arr = [\n  [\"0\", \"a\"],\n  [\"1\", \"b\"],\n  [\"2\", \"c\"],\n]\nconst obj = Object.fromEntries(arr)\nconsole.log(obj) // { 0: \"a\", 1: \"b\", 2: \"c\" }\n\n// 인자로 Map 넘겨줄 때\nconst entries = new Map([\"foo\", \"bar\"], [\"baz\", 42])\nconst obj = Object.fromEntries(entries)\nconsole.log(obj) // { foo: \"bar\", baz: 42 }\n```\n\n## 이 외의 방법\n\n### 1. Object.assign()\n\n해당 포스트(<a href=\"https://phrygia.github.io/js/2021-09-21-object/\" target=\"_blank\">[javascript] Object.assign() & Object.create()</a>)에서는 {}에 대해서만 다뤘기 때문에 배열을 인자로 넘겨주면 자동으로 키값이 생성된다는 걸 몰랐다. 😳 <br>\n\n<div class=\"blockquote\">\n    Object.assign(target, ...sources)\n</div>  \nsource에 배열을 전달하면 0, 1, 2처럼 index가 자동으로 key값이 되고, 배열의 요소가 value인 객체가 생성된다.\n\n```js\nlet arr = [\"first\", \"second\", \"third\"]\nlet obj = Object.assign({}, arr)\nconsole.log(obj) // { 0: 'first', 1: 'second', 2: 'third' }\n\nlet arr2 = [\n  { id: 1386, quantity: 1 },\n  { id: 1385, quantity: 2 },\n]\nlet obj2 = Object.assign({}, arr2)\nconsole.log(obj2)\n// { 0: { \"id\": 1386, \"quantity\": 1 }, 1: { \"id\": 1385, \"quantity\": 2 } }\n```\n\n### 2. Spread operator\n\nSpread operator을 사용하면 배열을 객체로 변환할 수 있다. index가 자동으로 key값이 되고, 배열의 요소가 value인 객체가 생성된다.\n\n```js\nlet arr = [\"first\", \"second\", \"third\"]\nlet obj = { ...arr }\nconsole.log(obj) // { 0: 'first', 1: 'second', 2: 'third' }\n\nlet arr2 = [\n  { id: 1386, quantity: 1 },\n  { id: 1385, quantity: 2 },\n]\nlet obj2 = { ...arr2 }\nconsole.log(obj2)\n// { 0: { \"id\": 1386, \"quantity\": 1 }, 1: { \"id\": 1385, \"quantity\": 2 } }\n```\n\n### 3. forEach()\n\nObject.assign()이나 Spread operator를 사용하면 key는 자동으로 index가 된다. index가 아닌 특정 key를 사용하고 싶다면 forEach 반복문을 사용한다.\n\n```js\nlet arr = [\n  { id: 1386, quantity: 1 },\n  { id: 1385, quantity: 2 },\n]\nlet obj = {}\n\narr.forEach((elem, index) => {\n  obj[\"key\" + index] = elem\n})\n\nconsole.log(obj)\n// { key0: { \"id\": 1386, \"quantity\": 1 }, key1: { \"id\": 1385, \"quantity\": 2 } }\n```\n\n### 4. reduce()\n\n내가 실무에서 사용했던 reduce.. forEach 사용.\n\n```js\nlet arr = [\n  { id: 1386, quantity: 1 },\n  { id: 1385, quantity: 2 },\n]\n\nlet obj = arr.reduce((acc, cur, index) => {\n  return { ...acc, [\"key\" + index]: cur }\n}, {})\n\nconsole.log(obj)\n// { key0: { \"id\": 1386, \"quantity\": 1 }, key1: { \"id\": 1385, \"quantity\": 2 } }\n```\n\n코딩하면서 비효율적으로 코딩한다고 느끼는 순간이 있고, 아직 기초지식이 많이 부족하다고 느낀다. 자바스크립트 Deep Dive를 열심히 공부해야 겠다..\n\n<small class=\"from add\">참고 : <a href=\"https://codechacha.com/ko/javascript-convert-array-to-object/\" target=\"_blank\">https://codechacha.com/ko/javascript-convert-array-to-object/</a><br>\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries\" target=\"_blank\">MDN</a>\n</small>\n"},{"excerpt":"인생에서 제일 길었던 한해가 지나갔다. 2022년. 다사다난했던 한해. 많은 일들이 있었던 만큼 매우 긴 한해였다.\n프론트엔드 개발자가 되겠다고 연초부터 면접을 보러 다녔었는데 아주 오래전 이야기가 된것 같은 느낌.. 길고도 험난했던 해인만큼 2022년 회고록을 쓰며 안좋았던 기억들을 모두 훌훌 털어내고 새로운 2023년을 준비해보려고 한다.\n2022년의…","fields":{"slug":"/2023-01-08/"},"frontmatter":{"date":"January 08, 2023","title":"[diary] 2022년 회고","tags":["diary"]},"rawMarkdownBody":"\n인생에서 제일 길었던 한해가 지나갔다. **2022년.** 다사다난했던 한해. 많은 일들이 있었던 만큼 매우 긴 한해였다.\n프론트엔드 개발자가 되겠다고 연초부터 면접을 보러 다녔었는데 아주 오래전 이야기가 된것 같은 느낌.. 길고도 험난했던 해인만큼 2022년 회고록을 쓰며 안좋았던 기억들을 모두 훌훌 털어내고 새로운 2023년을 준비해보려고 한다.\n<u>2022년의 가장 큰 이슈는 3가지</u>다. 3가지 모두 취업 후 하반기에 일어났는데 인생에서 가장 긴 6개월이었다. (부들부들)<br>\n\n## 1. 퍼블리셔에서 프론트엔드 개발자로\n\n이전에 올렸던 포스팅에서 (<a href=\"/diary/2022-03-09/\" target=\"_blank\">[diary] 프론트엔드 신입 면접 준비하기</a>)처럼 나는 올해 프론트엔드 개발자로 커리어 전환에 성공했다. 취업까지도 여러 스토리가 존재한다..<br>\n면접 본 회사중 느낌이 좋았고 가고 싶던 회사가 있었는데 거의 2시간 30분 정도의 면접시간 동안 분위기도 좋았고 기술질문에도 대답을 잘했었고 집도 가까워서 엄청 기대했는데 탈락해서 한동안 멘탈이 나갔었다. (지금 생각해보면 회사는 경력자를 뽑을 생각이었는데 회사가 급성장하던 시기라 인적 데이터를 쌓기위해 면접을 계속 본것같다는 생각이 든다. 면접 2시간 30분은 뭐냐고 😡) <br>\n정신차리고 면접보러 다니다가 2번째로 마음에 드는 회사에 합격했다. (이 회사도 이력서-1차 온라인 면접-2차 과제면접- 3차과제면접까지 합격까지의 프로세스가 시간적으로 굉장히 길었던 회사다.) 한달후에 입사하기로 해서 한달동안 신나게 놀다가 출근했는데 투자취소로 회사가 어떻게 될지 모르는 상황이 생겨버렸었다. 대표님은 이런 상황인데 입사하고 싶으면 입사해도 되지만 회사가 없어질수도 있다고 하셨는데 저런 얘기를 듣고 어떻게 입사하지..?라는 생각과 내 한달은 뭐였지 라는 생각이 마구마구 들기 시작했다. 그러다가 본인 친구회사가 개발자를 뽑고 있는데 나를 굉장히 좋게 봐서 추천하고 싶으니 이력서 넘겨도 괜찮냐고 여쭤봐주셔서 OK했고 면접보고 들어온 회사가 지금의 회사다. (면접보기에 지쳐있어서 합격하자마자 바로 OK)<br>\n\n퍼블리셔에서 독학해서 프론트엔드 개발자가 된지 6개월정도 지났다. 스타트업 회사의 인하우스 개발자로 취업했는데 처음 취업 당시에 필자 포함 총 4명의 개발자가 있었다. 개발자가 여러명이라서 입사한 이유가 가장 컸는데 입사하고 2개월이 지났을때 2명의 개발자가 그만두는 상황이 발생했다. 입사한지 얼마안되서 개발자가 절반으로 줄어버린 상황이 너무 슬펐다. 사수랑 둘만하는 상황이 되버림과 동시에 입사한지 3개월도 안되서 아예 새로운 프러덕션 서비스의 프론트 전체페이지를 감당해야 하는 일까지 생겨버려 심적으로 부담이 커지기 시작했다. <br>\n특히 출퇴근 시간이 길기 때문에 체력적으로도 힘에 부치기 시작했다. (왕복 2시가 40분..) 제일 싫어하는 지하철을 타야한다는 스트레스때문에 정신적으로 힘들던 때에 새로운 프로젝트가 시작되면서 재택근무가 주 1회 → 3회로 늘어났고 프로젝트는 어찌어찌 완성되어 출시일이 얼마안남았고 2주전에 사수와 6개월 리뷰를 거치면서 연봉이 인상되어 지금은 즐거운 마음으로 다니고 있다. (다니려한다..)\n\n![재택근무](img/2022-1.jpeg)\n\n## 2. 코로나 감염\n\n![코로나 감염](img/2022-5.jpg)\n\n2022년 8월 30일 화요일. 어찌 잊으랴. 코로나 확진된 날이다. <br>\n걸리기 전주 토요일에 아주아주 오랜만에 외출해서 강남에서 여러명의 지인들과 저녁을 먹고 맥주를 마신날이 있었는데 그때 코로나에 걸렸던 것 같다. 나는 코로나에 안걸리는 슈퍼항체인가라고 내심 자부심이 있었는데 그냥 외출을 안해서 코로나에 안걸렸던게 아닐까 생각된다 🤣 <br>\n토요일 외출 → 월요일 출근 (동료 한분과 둘이 먹었는데 다행히 안걸리심) → 화요일 재택 (마침 재택이었는데 점심시간 지나고 몸상태가 너무 이상해서 자가키트 해봤는데 2개다 양성으로 떠서 병원에 신속항원검사하러 갔는데 양성판정..) 양성떠도 나는 무증상자겠지 라는 생각을 했지만 확정 당일 저녁부터 열이 오르고 목이 아프고 기침이 멈추질 않는 등 화-금요일까지 (코로나휴가+연차1일) 일은 아예 못하고 끙끙 앓았다. 집에 반려묘와 식구 1명이 있어 방에서 혼자 격리하며 항상 마스크를 끼고 소독약을 손에 들고 다니면서 강박적으로 뿌렸던 것 같다. 식구 1명은 내가 아프다고 반려묘를 돌봐줄 위인이 아니기에 아픈몸을 이끌고 반려묘 케어도 하느라 힘들었던 것 같다. <br>\n특히 4일째에 다시 열이 오르면서 나아질 기미가 없고 목은 아프다 못해 목소리가 아예 안나오는 상황이 되버려서 격리중에 어쩔수 없이 병원을 방문하는 상황이 생겼었다. 중간에 어플로 진료보고 약 처방하는 것까지 해봤는데 효과가 전혀 없었다. 격리중 대면 진료는 정해진 병원으로 대중교통 이용하지 않고 도보나 자차 이용하면 가능하다 해서 자차 이용해 병원과 약국을 방문했다. 화~토까지 미친듯이 아프다가 토요일에 대면진료해서 처방받은 약이 효과가 있었는지 일요일부터 상태가 좋아져서 월요일에는 재택근무가 가능한 상태가 되었다.<br>\n\n내가 건강해야 반려묘도 돌볼 수 있다는걸 깨달았던 경험이다... 이후 면연력을 위해 유산균과 비타민 등 면역력에 좋다는 음식을 챙겨먹으려고 노력하고 있다.\n\n![코로나 감염](img/2022-2.jpg)\n\n## 3. 어린 반려묘의 만성신부전 판정\n\n2022년 6월 18일 토요일. 아직 2살이 되지 않은 어린 고양이가 급성 신부전으로 입원한 날이다. <br>\n건강하던 반려묘가 입원 한달전부터 가끔씩 토를 하기 시작했다. 고양이가 토하는건 흔히 있는 일이기 때문에 대수롭지 않게 생각했다. 그런데 입원 며칠전에 녹색토를 했다. 고양이 토색깔로 대충 어떤 증상인지 유추해 볼 수 있는데 녹색토는 담즙과 관련된 것으로 건강에 이상이 있다는 신호라고 했다. 병원에 데리고 갈지 많은 고민을 했던 것 같다. 고민한 이유는 토한거 빼곤 평소보다 넘치는 활력과 에너지 때문이었는데 괜히 데려갔다가 별일 아닌데 스트레스만 줄까봐 며칠을 고민하다 별일 아니더라도 내 마음이 편하고자 지인과의 약속전에 병원에 데리고 갔다. 병원에서도 별 이상은 없는것 같다고 했지만 내가 혈액검사를 요구했고 혈검결과는 급성신부전. 응급상황으로 당장 입원해서 공격적으로 수액을 맞추면서 수치를 떨어뜨려야 하는 상황이었다. 입원하지 않으면 위험하다고.. 별일 아니겠지 했던 마음과 더 빨리 데려가지 못한 상황에 마음이 무너져 내렸었다. 병원에서는 그래도 빨리 데리고 온거라며 위로해주셨고 나는 바로 입원에 동의했고 집에 오는길에 지인에서 상황을 알리고 약속 취소 후 주말동안 눈이 부르트도록 울기만 했다. (그때를 생각하면서 글쓰는 지금도 눈물이 난다.) <br>\n주말내내 울다가 월요일 오전에 병원에 전화했었는데 아이가 얌전하고 애교도 많지만 머물고 있는 자리에서 꺼내려고만 하면 하악질 하고 난리라 꺼내서 혈검을 할수가 없으니 보호자가 오면 그때 꺼내서 혈검해서 퇴원 여부를 결정하자고 하셨었다. 최대한 빨리 퇴근해서 병원 문닫기 1시간전에 도착했는데 아직도 꺼낼수가 없으니 보호자분이 꺼내실수 있겠냐고 하셔서 이름을 불러주며 손을 내밀었더니 아주 얌전하게 안겨서 나와줬다.. 병원 관계자분들이 엄마 알아보고 가만히 있는거 보니 엄마 되게 좋아하는것 같다고 해서 또 눈물이.. 혈검했는데 다행히 수액처지가 잘되서 수치는 떨어졌지만 초음파상 신장모양이 이상하고 담석이 있어 선천적으로 신장이 안좋은 아이 같으니 계속 지켜보고 다시 내원하기로 했다. <br>\n퇴원 후 가끔씩 토를 할때마다 심장이 철렁해서 병원에 델꾸 갔었는데 단기간에 자주 가다보니 아이도 스트레스가 심하고 막상 가보면 별일이 아니었었다. 그러기를 반복하다 나중에 혈검을 해보니 만성신부전이 되버렸다고.. 선천적으로 신장이 안좋은 애니까 보호자 책임은 아니라고 했지만 내가 잘못케어해서 아픈 것 같아 지금도 너무 미안한 마음이다. <br>\n신부전 판정이후로 좋아하던 간식들은 신장에 좋지않아 줄 수 없고 좋아하지 않던 간식형태의 신부전 간식만 줘야해서 너무 불쌍하고 미안한 마음이다.\n\n![반려묘 퇴원](img/2022-3.jpeg)\n\n5월말 취업 → 6월 반려묘 신부전 입원 → 8월말 집사 코로나 확진 <br>\n코로나 이후로 2개월정도 미각을 잃고 (현재까지도 100% 돌아오지 않았다) 체력을 잃고 기억력도 잃었다. 코로나 걸리기 전에는 출근전 새벽에 일어나서 개발공부도 하고 그랬는데 코로나 이후로 모든 패턴이 무너졌다. 체력이 안되니 잠을 자도 많이 피곤하고 퇴근하면 골아떨어지고 아침에 일어나기 힘들어서 개발 공부를 할 수 없었다. 기억력도 나빠져서 업무에 지장이 생기기도 했었다. (이건 6개월 리뷰할때 사수한테 말하면서 사과했었는데 막상 사수는 대수롭지 않게 생각했었던 것 같다.) 거의 3개월을 골골거리고 방황하다 이건 아니다 싶어 무너진 페이스 복구를 위해 새로운 사이드 프로젝트 모임에 들어가고 다시 인강도 듣기 시작하는 등 페이스 복구를 위해 노력하는 중이다. 그 일환중의 하나가 다시 개발블로그를 열심히 하는 것!!!<br>\n\n### 기술적으로 배운 점\n\n#### 1. Next.js\n\n개발자가 되기위해 독학했을때는 React를 위주로 공부했었기 때문에 SSR을 고려해본적이 없다. 취업하고 Next.js를 많이 쓴다는걸 알게 되었고 실제로 회사에서도 사용하고 있으며 아예 새로운 프로젝트를 내손으로 만들어 보기도 하면서 Next.js를 알 수 있는 계기가 되었다. (다만 서버 자체를 다루진 않기때문에 프론트에 한정된 기술만 배운 것 같아 스스로 nodejs를 공부해서 다루는 공부가 필요할 것 같다.)\n\n#### 2. Typescript\n\n처음 입사했을때 Next.js로 되어있긴 했지만 Typescript를 사용하고 있진 않았다. 사수가 새로운 프로젝트에서 원하는 스택을 마음껏 써보라고 해서 Typescript를 실제로 사용해 볼 수 있게 되었다. (이것도 독학해서 사용하긴 하는데 엄청 한정적으로 사용하는 것 같아서 깊은 공부가 필요할 것 같다.)\n\n#### 3. React-Query + Recoil\n\n회사의 기존 프로젝트는 SWR과 axios를 사용하고 있었는데 React-Query를 아주 많은 곳에서 사용한다는 글을 발견하고 새 프로젝트에 사용해보고 싶어 인강을 보면서 공부해 새 프로젝트에서 사용하고 있다. 마찬가지로 깊은 공부가 필요하다고 생각되는게 유튜브 보면서 낙관적 업데이트가 뭔지 아냐는 영상을 봤는데 난 몰랐다.. deep하게 공부해야 될 것 같다. <br>\nRecoil은 React-Query와 같이 쓰기에 가벼워서 추천한다는 글을 보고 무작정 사용하기로 결정했는데 코드가 React스럽고 배우기 쉬워서 굉장히 만족하면서 쓰고 있다. (Redux-saga 어후..)\n\n#### 4. 기획자/디자이너/백엔드 개발자 소통 → 새로운 자극\n\n퍼블리셔 시절에도 개발자나 디자이너와의 소통을 하긴했었지만 중간지점에 머물러 작업물을 개발자에게 넘겨줘 개발자가 완성하는 페이지를 보고 최종 결과물을 봤었다면 개발자의 포지션이 된 지금은 최종 결과물을 만들고 제일 빨리 테스트해보는 사람이 되었다. 퍼블리셔 시절에서 내가 제일 싫었던 점은 결과물을 완성해도 상대적으로 내 노력이 낮게 평가된다는 점이었다. 결국 완성은 개발자의 손에 달린거고 클라이언트와 소통도 개발자가 했었기 때문에.. 이점이 너무 싫었기 때문에 개발자가 되기로 결심했고 지금은 최종 점검자로써 만족스럽게 일을 하고 있다. (실제로 안되요. 가능합니다 등 나의 의견을 피력할 수 있다는 점이 매우 만족스럽다.)\n\n## 2023년 목표\n\n- 사이드 프로젝트 완성하기\n- 알고리즘 공부\n- Next.js 13 + React 18 공부\n- React Native 공부하기\n- CS 관련 책 공부하기 (최소한 한번 읽기라도 하기)\n- 반려묘 별탈없이 건강하기 (더 나빠지지 않기)\n- 집사도 코로나 걸리지 않고 건강하기\n- 다이어트 (작년보다 5Kg이 쪘어요 🥲 - 최소 3키로는 빼기)\n- 주식/부동산/경제 관련 책보면서 공부하기 (경제문맹 탈출하기)\n- 독서 30권 이상\n"},{"excerpt":"어느날 사수가 갑작스럽게 보내준 링크. (Next.js 13 신버전 발표회 요약 (웹개발자 비상!!))\n나는 프론트엔드 웹개발자로 React를 사용하고 있고 우리회사는 production에서 많이 사용되고 편리한 Next.js를 사용중이다. \n사실 사수가 저 링크를 보내주기 전까지 우리 회사가 무슨 버전을 쓰는지도 모르고 신경조차 쓰지 않았다. \n핑계를 …","fields":{"slug":"/2022-11-06-nextjs-13/"},"frontmatter":{"date":"November 06, 2022","title":"[nextjs] Next.js 13","tags":["nextjs","react"]},"rawMarkdownBody":"\n<div style=\"max-width: 450px;\">\n\n![nextjs-13](img/2022-11-05-nextjs.jpg)\n\n</div>\n\n어느날 사수가 갑작스럽게 보내준 링크. <small class=\"from notline\"><a href=\"https://www.youtube.com/watch?v=5BRFGMs1v_o&t=1s\" target=\"_blank\">(Next.js 13 신버전 발표회 요약 (웹개발자 비상!!))</a></small>\n나는 프론트엔드 웹개발자로 React를 사용하고 있고 우리회사는 production에서 많이 사용되고 편리한 Next.js를 사용중이다. <br>\n사실 사수가 저 링크를 보내주기 전까지 우리 회사가 무슨 버전을 쓰는지도 모르고 신경조차 쓰지 않았다. <br>\n핑계를 대자면 나는 이제 막 5개월이 지난 신입 개발자라 Next.js를 배우는데 더 신경을 썼었고 입사 초반에 우리집 어린 고양이가 급성신부전으로 입원해서 심리적으로 힘들었었고 8월말에 걸린 코로나 + 후유증, 무너진 워라벨, 어린 고양이의 만성 신부전 판정으로 멘탈과 체력, 돈까지 탈탈 털려서 시키는 일적인 코딩외에 아무 생각도 하지 않았다. <br>\n그러다 최근 정신차리고 멘탈관리 및 커리어를 위해 다시 개발공부를 시작하려던 차에 사수가 보내준 링크와 사이드프로젝트에서 만난 프론트 개발자분과 13버전을 공부하기로 하면서 그동안 내가 써왔던 문법은 Next.js 9.3이후에 만들어진 메소드인걸 알게 되었다. <br>\n\n## Next.js의 주요기능\n\n1. automatic routing : /pages 폴더에 있는 파일은 자동 라우팅\n2. code splitting : 자동 코드 분할로 빠른 로딩\n3. pre-rendering, SSG/SSR : 페이지 단위로 지원되어 쉽게 사용가능\n4. Fast Refresh 지원 : 컴포넌트 수정에 대한 빠른 피드백을 제공\n5. 내장 CSS, Sass 지원 모든 CSS-in-JS 라이브러리 지원 : 손쉽게 scss/module.css 사용 가능\n6. typescript: 별다른 webpack 설정없이 typescript를 설치하면 바로 사용 가능\n\n## Next.js 13\n\n![https://www.youtube.com/watch?v=5BRFGMs1v_o&t=1s 캡쳐](img/2022-11-05-nextjs-2.jpg)\n\n10월 26일 <a href=\"https://nextjs.org/conf\" target=\"_blank\">Next.js Conf</a>에서 <a href=\"https://nextjs.org/blog/next-13\" target=\"_blank\">Next.js 13버전</a>이 새롭게 발표됐다.<br>\n공식문서에서 설명하고 있는 대표적인 변화점은,\n\n1. **app/Directory**\n   - Layouts : 리렌더링 방지를 기본으로 구현한 Layout<br>\n   - React Server Component : React 의 새로운 Server Component 지원하여 로딩 속도 개선<br>\n   - Streaming : 점진적으로 스트리밍 되어 UI 렌더링 할 수 있는 Streaming\n2. **Turbopack** (alpha) : 웹팩보다 700배 빠른 Rust 기반의 대체품\n3. **New Next/image** : 빨라진 lazy loading (Google과 협업으로 기존 로딩 퍼포먼스를 저해하던 요소들 개선)\n4. **New @next/font** (beta) : 빌드타임 때 최적화를 시키면 구글 폰트가 기본으로 내장 (폰트 최적화)\n5. **Improved next/link** : 기존 &lt;Link&gt;안에 사용되던 &lt;a&gt; 태그 불필요\n\n### 최신 Next.js 설치하기\n\n```js\nnpm i next@latest react@latest react-dom@latest eslint-config-next@latest\n```\n\n설치를 완료하니 3개의 파일/폴더가 있고, react 18.2.0, next 13.0.2 버전이 설치되어 있다.\n\n<div style=\"max-width: 550px;\">\n\n![nextjs-13](img/2022-11-05-nextjs-3.jpg)\n\n</div>\n\n### 1. app/Directory (beta)\n\n<div style=\"max-width: 200px;\">\n\n![nextjs-13](img/2022-11-05-nextjs-4.jpg)\n\n</div>\n\n기존의 Next.js는 별도의 라우터 설정없이도 `pages` 디렉토리 안에 파일을 생성하면 즉시 경로를 생성할 수 있었다. (automatic routing) <br>\nNext.js 13에서는 `app` 디렉토리가 새롭게 등장하였다. (현재 포스팅하는 날짜 기준으로 `pages`와 `app` 디렉토리가 공존할 수 있는 beta 버전이기 때문에 production에서의 사용을 권장하지 않고 있다.) <br>\n`app` 디렉토리는 아래에 등장하는 4가지가 포함된다.\n\n#### 1) Layouts\n\n공통으로 사용되는 UI 컴포넌트를 layout 파일안에 위치시키면 불필요한 리렌더링을 방지를 하고 컴포넌트간의 상호 작용을 쉽게 구현할 수 있다.\n\n<div style=\"max-width: 570px;\">\n\n![nextjs-13](img/2022-11-05-nextjs-5.jpg)\n\n</div>\n\n**layout 파일만 생성해서 실행하려고 하니 다음과 같은 에러 메시지가 떴다**\n\n![nextjs-13](img/2022-11-05-nextjs-6.jpg)\n\nnext.config.js파일을 생성하여 다음 코드를 추가하자.\n\n```js\nmodule.exports = {\n  experimental: { appDir: true },\n}\n```\n\n다시 실행하니 이번에는 404에러 페이지(This page could not be found)가 떴다. 원인은 page 파일을 생성하지 않아서였다. <br>\n**`app` 디렉토리안에 layout과 page 파일을 함께 만들어야 실행된다.** (기존 `pages`의 index 파일과 비슷하다.) <br>\ndynamic routes를 사용하려면 기존의 index였던 이름을 page로 바꾸기만 하면 된다.\n\n<div style=\"max-width: 570px;\">\n\n![nextjs-13](img/2022-11-05-nextjs-7.jpg)\n\n</div>\n\n<div style=\"max-width: 550px;\">\n\n![nextjs-13](img/2022-11-05-nextjs-8.jpeg)\n\n</div>\n\n정상적으로 실행되었다! 기존에는 페이지마다 Layout 컴포넌트를 불러와야하는 번거로움이 있었는데 성능에도 좋고 편리해진점이 마음에 든다. 👍\n\n#### 2) Server Components\n\nReact의 새로운 <a href=\"https://ko.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html\" target=\"_blank\">Server Components</a> 아키텍처에 대한 지원으로 나온듯한 업데이트 <br>\n서버 구성 요소를 사용 하여 클라이언트에 전송되는 JavaScript의 양을 줄이면서 더 빠른 초기 페이지 로드를 가능하게 하는 동시에 복잡한 인터페이스를 구축할 수 있는 기반을 마련하고 있다고 하는데.. <br>\n→ 아직 Server Components에 대한 개념이 부족해서 이부분은 공부를 해야겠다.\n\n#### 3) Streaming\n\n`app` 디렉토리에 lodaing이라는 예약파일을 생성하면 데이터를 가져오는 부분에서 로드 상태를 표시해주는 컴포넌트다. <br>\nServer Components와 layout 예약파일과 함께 사용하면 데이터가 필요하지 않은 부분은 화면에 먼저 표시되고 데이터가 필요한 부분은 loading에 작성한 내용이 먼저 표시된 후 로드가 완료되는 실제 내용이 표시된다. <br>\n로딩스피너같은 로딩중임을 나타내는 컴포넌트를 넣으면 따로 작업하지 않아도 자동으로 로딩중임을 보여주는 편리한 기능인 것 같다.\n\n<img src=\"https://nextjs.org/_next/image?url=%2Fstatic%2Fblog%2Fnext-13%2Fstreaming.png&w=3840&q=75\">\n\n#### 4) Support for Data Fetching\n\n이전의 Next.js에서 data를 fetch하기 위해선 getServerSideProps나 getStaticProps를 사용하여 데이터를 가지고 왔었다. 사실 저부분 코드가 예쁘지도 약간 난해한 느낌이었는데 Next.js 13에서는 좀더 직관적으로 쉽게 바꼈다!\n\n<div style=\"max-width: 550px;\">\n\n![nextjs-13](img/2022-11-05-nextjs-9.jpeg)\n\n</div>\n아래처럼 getStaticProps를 통해 받아온 응답데이터를 props로 넘겨준 후 파라미터로 받아왔다면 Next.js 13에서는 use를 사용해 fetch 함수를 실행해주면 된다. <br>\nfetch 함수 뒤에 cache, next 옵션을 추가할 수 있다.\n\n```js\n// getStaticProps와 비슷 - 빌드 시 딱 한번만 호출\nfetch(URL, { cache: \"force-cache\" })\n\n// getServerSideProps와 비슷 - 매 요청때마다 호출\nfetch(URL, { cache: \"no-store\" })\n\n// getStaticProps의 revalidate 옵션을 사용하는 것과 비슷\nfetch(URL, { next: { revalidate: 10 } })\n```\n\n### 2. Turbopack\n\n<div style=\"max-width: 300px; margin: 0 auto;\">\n\n![Turbopack](img/2022-11-05-nextjs-10.jpg)\n\n</div>\n\n새로운 Rust기반의 Js 번들링 툴로,\n\n- webpack보다 700배 빠른 업데이트\n- Vite보다 10배 빠른 업데이트\n  즉 Webpack보다 빠르게 번들링 해주는 새로운 툴인데.. 이게 진짜라면 엄청 유용할 것 같지만 아직 beta 버전이고 webpack자체도 좋기때문에 좀 더 안정화되면 사용해보는게 좋을 것 같다.\n\n### 3. Next/image\n\n새로운 Image 구성 요소가 도입되어 레이아웃 변경 없이 쉽게 이미지를 표시하고 성능 향상을 위해 필요에 따라 파일을 최적화할 수 있게 되었다. 기존에는 width height값을 적용하지 않으면 레이아웃이 깨지는 Layout shift가 발생하곤 했는데 Next.js 13에서는 이를 자동으로 처리해준다.\n\n- Ships less client-side JavaScript\n- Easier to style and configure\n- More accessible requiring alt tags by default\n- Aligns with the Web platform\n- Faster because native lazy loading doesn't require hydration\n\n업데이트 사항인데 alt와 성능향상이 주된 내용이다.\n\n### 4. @next/font\n\nNext.js 13에서는 새로운 글꼴 시스템이 도입되었다.\n\n- 사용자 정의 글꼴을 포함하여 글꼴을 자동으로 최적화.\n- 개인 정보 보호 및 성능 향상을 위해 외부 네트워크 요청 제거\n- 모든 글꼴 파일에 대한 자체 내장형 호스팅\n- CSS `size-adjust` 속성 을 사용하여 자동으로 레이아웃 이동 없음 (layout shift 사라짐)\n  새로운 글꼴 시스템을 사용하면 성능향상뿐만 아니라 내장된 구글 폰트를 편리하게 사용할 수 있다!!!\n  빌드 시 자동으로 다운되기 때문에 자체 호스팅에 포함되면 구글로 따로 요청을 보내지 않는다고 한다.\n\n```js\n// 구글 폰트 사용\nimport { Inter } from \"@next/font/google\"\n\nconst inter = Inter()\n;<html className={inter.className}></html>\n\n//  사용자 정의 글꼴\nimport localFont from \"@next/font/local\"\n\nconst myFont = localFont({ src: \"./my-font.woff2\" })\n;<html className={myFont.className}></html>\n```\n\n### 5. next/link\n\n드디어 &lt;Link&gt;안에 사용되던 &lt;a&gt;가 사라지게 되었다. (실제로 사라진건 아니고 자동으로 렌더된다.) 왜 써야하는지 이해가 안되던 &lt;a&gt;가 사라진걸 보니 나만 불편한게 아니었나 보다. 😏\n\n```js\nimport Link from 'next/link'\n\n// Next.js 12\n<Link href=\"/about\">\n  <a>About</a>\n</Link>\n\n// Next.js 13\n<Link href=\"/about\">\n  About\n</Link>\n```\n\n#### \\*next/link를 Next.js 13로 업그레이드 하기\n\nNext.js 13에 대한 링크를 업그레이드하기 위해 코드베이스를 자동으로 업데이트하는 <a href=\"https://nextjs.org/docs/advanced-features/codemods\" target=\"_blank\">codemod</a>를 제공한다.\n\n```js\n// ./pages 디렉토리에 있는 코드들을 변경하고 싶을때\nnpx @next/codemod new-link ./pages\n```\n\n### 6. OG Image Generation\n\n소셜 카드, 개방형 그래프 이미지(open graph images)라고 OG Image는 마케팅적으로 많이 사용되며 사용자들의 클릭수를 높여준다. <br>\n하지만 React로 OG를 관리하는게 생각보다 까다롭다. (실제로 회사에서 한번 og관련 이슈가 있었다.) 설정하지 않기에는 마케팅적으로 비효율적이고 카톡으로 링크공유가 일상인 한국인들은 og image에 매우 익숙하다. <br>\nNext.js 13에서 동적 소셜 카드를 생성하는 새로운 라이브러리인 <a href=\"https://vercel.com/docs/concepts/functions/edge-functions/og-image-generation\" target=\"_blank\">@vercel/og</a>가 등장했다.\n\n**\\*OG(Open Graph)** : 콘텐츠가 표시되는 방식을 관리하기 위한 메타정보들을 정의해놓은 프로토콜. 주로 url로 공유할때 해당 콘텐츠의 요약내용이 보이도록 미리보기를 제공해준다.\n\n<div style=\"max-width: 350px; margin: 0 auto;\">\n\n![nextjs-13](img/2022-11-05-nextjs-11.jpg)\n\n<small class=\"from\" style=\"margin-top:-15px;\">내 블로그 og image도 변경해야겠네..</small>\n\n</div>\n\n```js\n// pages/api/og.jsx\nimport { ImageResponse } from \"@vercel/og\"\n\nexport const config = {\n  runtime: \"experimental-edge\",\n}\n\nexport default function () {\n  return new ImageResponse(\n    (\n      <div\n        style={{\n          fontSize: 128,\n          background: \"white\",\n          width: \"100%\",\n          height: \"100%\",\n          display: \"flex\",\n          textAlign: \"center\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n        }}\n      >\n        Hello world!\n      </div>\n    ),\n    {\n      width: 1200,\n      height: 600,\n    }\n  )\n}\n```\n\n<div style=\"max-width: 350px;\">\n<img src=\"https://vercel.com/_next/image?url=%2Fstatic%2Fdocs%2Fconcepts%2Ffunctions%2Fog-image%2Fstatic-og-image.png&w=3840&q=75\n\">\n</div>\nurl을 공유하면 ImageResponse안에서 입력한 텍스트가 이미지로 바뀐다. 즉, text → image로 바꿔주는 것 같은데 안에 이미지 파일을 넣으면 이미지 그대로 출력해주는지도 알아봐야 될 것 같다. 그게 맞다면 엄청 편리한건 확실한 것 같다.\n\n### 7. Middleware API Updates\n\n초기 API 디자인에 대한 피드백을 듣고 개발자 경험을 개선하고 강력한 새 기능을 추가하기 위해 몇 가지 추가 사항을 추가되었다. <br>\n→ 미들웨어를 사용해본적이 없어 정확한 개념이 부족한것 같아 이부분은 공부를 더 해봐야겠다.\n\n```js\n// middleware.ts\nimport { NextResponse } from \"next/server\"\nimport type { NextRequest } from \"next/server\"\n\nexport function middleware(request: NextRequest) {\n  const requestHeaders = new Headers(request.headers)\n  requestHeaders.set(\"x-version\", \"13\")\n\n  const response = NextResponse.next({\n    request: {\n      headers: requestHeaders,\n    },\n  })\n\n  response.headers.set(\"x-version\", \"13\")\n  return response\n}\n\n// middleware.ts\nimport { NextRequest, NextResponse } from \"next/server\"\nimport { isAuthenticated } from \"@lib/auth\"\n\nexport const config = {\n  matcher: \"/api/:function*\",\n}\n\nexport function middleware(request: NextRequest) {\n  if (!isAuthenticated(request)) {\n    return NextResponse.json(\n      {\n        success: false,\n        message: \"Auth failed\",\n      },\n      {\n        status: 401,\n      }\n    )\n  }\n}\n\n// next.config.js\nconst nextConfig = {\n  experimental: {\n    allowMiddlewareResponseBody: true,\n  },\n}\n```\n\n대표적인 업데이트에 관해서 정리해보았는데 정말 나는 최소한만 사용한다는걸 알게되었달까.. react Next.js에 대해 좀더 깊게 공부해야겠다고 생각하는 계기가 되었다.\n\n<div class=\"from add\">\n    <ul>\n        <li>참고 : <a href=\"https://news.hada.io/topic?id=7665\" target=\"_blank\">https://news.hada.io/topic?id=7665</a></li>\n        <li><a href=\"https://nextjs.org/blog/next-13\" target=\"_blank\">https://nextjs.org/blog/next-13</a></li>\n         <li><a href=\"https://www.youtube.com/watch?v=5BRFGMs1v_o&t=1s\" target=\"_blank\">코딩 애플님 유튜브</a></li>\n    </ul>\n</div>\n"},{"excerpt":"회사의 새로운 프로젝트에서 React query와 함께 Recoil을 써보고 싶다는 생각이 들었다. \n우리 회사는 전역적으로 관리할 상태들이 많지 않아 쉽게사용할 수 있는 Context API를 사용하고 있다. \n나는 React를 공부할때 Redux를 사용해봤기 때문에 Redux의 복잡한 코드가 너무 싫었다. 전역적으로 사용하기 위한 초기 세팅도 복잡하고…","fields":{"slug":"/2022-08-15-recoil/"},"frontmatter":{"date":"August 15, 2022","title":"[react] Recoil 상태관리 라이브러리","tags":["react","recoil"]},"rawMarkdownBody":"\n회사의 새로운 프로젝트에서 React query와 함께 Recoil을 써보고 싶다는 생각이 들었다. <br>\n우리 회사는 전역적으로 관리할 상태들이 많지 않아 쉽게사용할 수 있는 Context API를 사용하고 있다. <br>\n나는 React를 공부할때 Redux를 사용해봤기 때문에 Redux의 복잡한 코드가 너무 싫었다. 전역적으로 사용하기 위한 초기 세팅도 복잡하고 여러모로 나와 맞지 않는다는 생각이 들었다. devtools가 잘 되어있기 때문에 어떤 액션이 취해졌고 데이터가 어떻게 변경되었는지에 대한 디버깅이 유리하다는 큰 장점이 있지만 많은 상태관리가 필요하지 않은 우리 회사의 상황에서 좋아하지도 않는 Redux를 사용하고 싶지는 않았다. <br>\nContext API를 사용해도 되지만 React query와 Recoil의 궁합이 좋다는 글을 Recoil을 써볼까라고 쉽게한 생각이 Recoil의 가벼움과 React스러운 부분이 마음에 들어 공부해서 꼭 사용해보자고 생각하는 계기가 되었다.\n\n## Recoil?\n\n> `A state management library for React.` - React를 위한 상태관리 라이브러리 <br> 1. 작고 React스러운 <br> 2. 데이터 흐름 그래프 <br> 3.\n> 교차하는 앱 관찰 <br>\n\nRecoil은 React를 만든 메타(페이스북)에서 만든 상태관리 라이브러리이다. React를 만든 회사에서 직접 상태관리 라이브러리를 만들어 주었으니 React스러운건 당연하다고 할 수 밖에 없다.\n유명한 상태관리 라이브러리인 Redux, Mobx 등이 있지만 상대적으로 후발 주자인 Recoil을 선택한 이유를 나열해 보자면, <br>\n\n1. React를 사용해본 개발자라면 상대적으로 배우기 쉽다. <br>\n   특히 Hooks를 사용하는 프론트 개발자들이라면! Redux가 초기 세팅부터 숨이 막히는 반면 Recoil은 RecoilRoot로 최상위에 감싸기만 하면 되는 등 사용이 비교적 쉽다.\n2. Redux에서 비동기통신의 Success/fail의 결과에 따른 state를 관리하기 위해선 redux-thunk, redux-saga같은 미들웨어를 사용하여 구현해야 하는데, Recoil은 미들웨어의 사용없이 쉽게 비동기 로직을 구현할 수 있다.(Suspense에 위임하여 비동기 처리)\n3. React스럽다. <br>\n   state의 값을 읽고 쓰기위해 useState와 비슷한 [get, set] 형태를 사용하며 빠르고 유연한 상태를 유지한다.\n4. 자체 캐싱기능으로 빠른 비동기 데이터 처리가 가능하다.\n5. 상태를 분산적으로 둘 수 있기 때문에 코드 스플리팅이 가능하다.\n\n## Recoil 시작하기\n\n```js\n// recoil 설치\nnpm install recoil\nyarn add recoil\n\n// recoil 시작 - index.jsx\nimport React from 'react';\nimport ReactDOM from \"react-dom/client\";\nimport { RecoilRoot } from 'recoil';\nimport App from \"./App\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n  <RecoilRoot>\n    <App />\n  </RecoilRoot>\n);\n```\n\n## Recoil 핵심 개념\n\nRecoil에는 다양한 API가 존재하지만 공식문서에서 소개하는 기본 API는 크게 2가지가 있다. 바로 <a href=\"https://recoiljs.org/ko/docs/basic-tutorial/atoms\" target=\"_blank\">Atoms</a>와 <a href=\"https://recoiljs.org/ko/docs/basic-tutorial/selectors\" target=\"_blank\">Selectors</a>다.\n<img src=\"https://ichi.pro/assets/images/max/724/0*k18qFfsSO5qk27Vc.png\">\n<small class=\"from\">이미지 출처 : <a href=\"https://ichi.pro/ko/recoil-js-dansunhwa-doen-reactleul-wihan-goseongneung-sangtae-gwanli-223553121461863\" target=\"_blank\">https://ichi.pro/ko/recoil-js-dansunhwa-doen-reactleul-wihan-goseongneung-sangtae-gwanli-223553121461863</a></small> <br>\nRecoil은 방향이 있는 그래프가 직교한 형태로 리액트 컴포넌트 트리에 붙어있게 만들어 준다. 이 그래프의 루트에서부터 상태 변화가 일어나는데 이 루트를 우리는 아톰(atom)이라고 한다. 그리고 이 과정은 순수함수를 통해서 일어나며 이를 선택자(selector)라고 한다.\n\n### 1. Atoms\n\n![Atom - https://www.youtube.com/watch?v=_ISAA_Jt9kI](img/2022-08-15-recoil.png)\n\nAtom은 **하나의 작은 상태 단위**로 **업데이트 및 구독이 가능**하다. <br>\nAtom이 업데이트 되면 구독하고 있는 컴포넌트들은 리렌더링이 일어나며 하나의 Atom을 구독하는 컴포넌트가 여러개라면 그 컴포넌트들은 상태를 공유한다. <br>\n(Atom은 비눗방울로 추상화 할 수 있는데 React 애플리케이션의 상단에 Atom이 비눗방울처럼 떠나닌다고 생각해보자. 개발을 하다가 어떤 비눗방울 (상태)이 필요하다면 해당하는 비눗방울만 선택해서 사용할 수 있다.) <br>\n\n전역적으로 사용될 state인 비눗방울(atom)을 생성하려면,\n\n```js\n// state 파일 - store.js\nimport { atom } from \"recoil\"\n\nexport const textState = atom({\n  key: \"textState\", // unique key\n  default: \"\",\n})\n```\n\n```js\n// TodoList.jsx\nimport { useSetRecoilState } from \"recoil\"\n\nconst TextInput = () => {\n  const [text, setText] = useRecoilState(textState)\n\n  const onChange = event => {\n    setText(event.target.value)\n  }\n\n  return (\n    <div>\n      <input type=\"text\" value={text} onChange={onChange} />\n      <br />\n      Echo: {text}\n    </div>\n  )\n}\n\nexport default TextInput\n```\n\n`atom`에 고유한 key와 default값을 설정하고 컴포넌트에서 `useRecoilState`를 사용하여 해당 state를 [get, set] 할 수 있다. (이때 여러 컴포넌트에서 textState를 구독하고 있다면 해당 컴포넌트들은 상태를 공유한다.) <br><br>\n\n```js\n// TodoList.jsx\nimport { useSetRecoilState, useRecoilValue } from \"recoil\"\n\nconst TextInput = () => {\n  const setText = useRecoilState(textState)\n  const text = useRecoilValue(textState)\n\n  const onChange = event => {\n    setText(event.target.value)\n  }\n\n  return (\n    <div>\n      <input type=\"text\" value={text} onChange={onChange} />\n      <br />\n      Echo: {text}\n    </div>\n  )\n}\n\nexport default TextInput\n```\n\n`useSetRecoilState`로 [get, set]을 모두 사용할 수 있지만, `useRcoilValue`를 사용하면 get과 set을 분리 할 수 있다. <br>\n특정 state의 값을 참고만 할때 `useRcoilValue`를 사용하자.\n\n### 2. Selectors\n\n`selector`는 `atom`이나 다른 `selector`들을 구독해서 `파생된 상태(derived state)`를 리턴하는 순수 함수이다. <br>\n파생된 상태 : `atom`을 원하는대로 변형해 유도된 새로운 값.\n\n```js\n// store.js\nexport const purchasedBreadAtom = atom({\n  key: \"purchased Bread\",\n  default: {\n    price: 000,\n    // ....\n  },\n})\n\nexport const purchasedBeverageAtom = atom({\n  key: \"purchased Beverage\",\n  default: {\n    price: 000,\n    // ....\n  },\n})\n```\n\n```js\n// PriceResult.jsx\nimport { selector, useRecoilValue } from \"recoil\"\n\nconst priceSelector = selector({\n  key: \"priceSelector\",\n  get: ({ get }) => {\n    const bread = get(purchasedBreadAtom)\n    const beverage = get(purchasedBeverageAtom)\n\n    return (bread?.price || 0) + (beverage?.price || 0)\n  },\n})\n```\n\n`selector`는 내부적으로 함수에서 get을 매개변수로 넘겨서 사용할 수 있는데, get 메서드는 `atom`과 다른 `selector`에 접근할 수 있다. <br>\n다른 `atom`이나 `selector`에 접근할 때 마다 의존성 관계가 만들어져서 다른 `atom`을 업데이트하거나 `selector`가 다시 계산이 되기도 한다. `selector`는 `useRecoilValue`로 값을 읽을 수 있다.\n\n```js\nconst PriceResult = () => {\n  const priceReulsts = useRecoilValue(priceSelector)\n\n  return (\n    <div>\n      <p>bread Price + beverage Price = {priceReulsts}</p>\n    </div>\n  )\n}\n\nexport default PriceResult\n```\n\n기본적인 Recoil API에 대해 알아보았다. 다음에는 로그인했을 때 사용자의 정보를 Recoil을 이용해 전역 상태로 유지하는 방법에 대해 공부해 봐야 겠다.<br>\n\n<small class=\"from add\">참고 : <a href=\"https://recoiljs.org/ko/\" target=\"_blank\">https://recoiljs.org/ko/</a><br>\n<a href=\"https://devowen.com/366\" taget=\"_blank\">https://devowen.com/366</a><br>\n<a href=\"https://tech.osci.kr/2022/06/16/recoil-state-management-of-react/\" target=\"_blank\">https://tech.osci.kr/2022/06/16/recoil-state-management-of-react/</a><br>\n<a href=\"https://blog.bitsrc.io/react-trying-recoil-js-d505214373c6\" target=\"_blank\">https://blog.bitsrc.io/react-trying-recoil-js-d505214373c6</a>\n</small>\n"},{"excerpt":"커머스 인하우스 신입 프론트엔드 개발자로 취업한지 2달정도 되었다. 현재 회사는 3개의 사이트를 가지고 있는데 1개만 자체솔루션이고 2개는 쇼핑몰 웹 솔루션을 사용하고 있다. 일반 솔루션을 사용하면 개발에 한정적이고 재고를 정확하게 관리하기 힘들기 때문에 하반기에 자체 솔루션 개발 계획이 있었다. 어쩌다보니 입사하고 3개월도 안되어 새롭게 구축하는 자체 …","fields":{"slug":"/2022-08-06-react-query/"},"frontmatter":{"date":"August 06, 2022","title":"[react] React Query 기초","tags":["react"]},"rawMarkdownBody":"\n커머스 인하우스 신입 프론트엔드 개발자로 취업한지 2달정도 되었다. 현재 회사는 3개의 사이트를 가지고 있는데 1개만 자체솔루션이고 2개는 쇼핑몰 웹 솔루션을 사용하고 있다. 일반 솔루션을 사용하면 개발에 한정적이고 재고를 정확하게 관리하기 힘들기 때문에 하반기에 자체 솔루션 개발 계획이 있었다. 어쩌다보니 입사하고 3개월도 안되어 새롭게 구축하는 자체 솔루션 사이트의 웹 프론트 페이지 전체 구현을 맡게 되었다. 🤣 <br>\n사수님이 내가 원하는 스택을 마음껏 사용해도 된다고 해서 어떤 라이브러리를 사용할까 고민해보다가 많은 회사들이 Reacy Query라는 것을 사용해 프론트와 서버의 상태관리를 분리 시키는 작업을 한다는 것을 알게 되었고, 나도 새로운 트렌드를 따라가보고 싶어 사용을 결정하게 되었다 <br>\n실서비스에 적용하기에 앞서 최소한의 지식을 습득하고자 React Query가 무엇인지에 대해 공부해 보았다.\n\n## React Query?\n\n> `React Query is often described as the missing data-fetching library for React, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your React applications a breeze.` <br> React Query는 종종 누락된 데이터를 가져오기 위한 React 라이브러리로 설명되지만, React(클라이언트)에서 서버의 값을 가져오거나 캐싱, 동기화, 업데이트할 수 있도록 해준다. <br>\n\n위는 React Query의 <a href=\"https://tanstack.com/query/v4/docs/overview\" target=\"_blank\">공식문서</a>에 나와있는 설명으로 대충 요약하자면 클라이언트에서 서버의 값을 핸들링하기 쉽게 만들어 준다는 말이다.\n\n#### 그렇다면 이전 방식보다 나은점은 무엇일까?\n\nReact Query 이전에는 서버의 값을 핸들링하기 위해서는 loading, error, fetch 등 서버값을 다루기 위한 동작들을 개발자가 직접 구현해줘야 했었다. 실제로 Redux에서 서버값을 받아온다면 try/catch 구문을 써야 하는 등 코드가 장황하게 길어지는 순간들이 발생한다. <br>\n또한 React Query는 자체적으로 캐싱 기능이 있기 때문에 개발자가 직접 구현하지 않아도 되며 Hooks를 기반으로한 리액트스러운 라이브러리이기 때문에 리액트 개발자가 사용하기 쉽다는 장점이 있다. (심지어 자체 devtools가 있다.)<br>\n캐싱, get한 데이터의 자동 updating 지원, 중복 호출 컨트롤 지원, 무한 스크롤, 쉬운 비동기 관리 등등..\n\n## React Query의 Server State\n\n<img src=\"https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F0hY1V%2FbtrFXYgkiWB%2Frp8XSWeQMdcS0KmKODimoK%2Fimg.jpg\">\n<small class=\"from\">이미지 출처 : <a href=\"https://freestrokes.tistory.com/170\" target=\"_blank\">https://freestrokes.tistory.com/170</a></small> <br>\n\n- **Fetching** - 데이터를 요청하는 초기 상태.\n- **Fresh** - 데이터가 만료되지 않은 상태. 새로고침 시 다시 Fetching됨.\n- **Stale** - 데이터가 만료된 상태. 데이터의 최신화가 필요하기 때문에 Fetching을 통해 Fresh상태 유지. <br>\n  &nbsp; &nbsp; fresh에서 stale로 변경되는 시간 : staleTime(기본값: 0)\n- **Inactive** - 애플리케이션에서 사용하지 않는 데이터에 대한 상태. 가비지 컬렉터에 의해 제거 됨. <br>\n  &nbsp; &nbsp; 캐싱된 상태로 남아있는 시간: cacheTime(기본값: 5분)\n- **Delete** - Inactive 데이터가 가비지 컬렉터에 의해 캐시에서 삭제된 상태.\n\nex) ['data']라는 query key로 데이터를 `Fetching `<br>\n→ ['data']라는 query key를 가진 값이 캐싱 됨<br>\n→ ['data']가 `Fresh` 상태에서 `staleTime` 이후 `Stale` 상태가 됨<br>\n→ `cacheTime`이 지난 후 가비지 컬렉터에 수거되고 `Delete`됨.<br>\n(cacheTime 이전에 새롭게 mount되면, Fetching이 실행되고 Fresh한 값을 설정하는 동안 캐싱된 데이터가 보여짐)\n\n## Reacy Query 기본 사용\n\nReact Query에서 많이 사용되는 기본 API에 대해 알아보자\n\n### 1. useQuery (query key), useQueries\n\n일반적으로 프론트 개발자가 코딩할 때 가장 많이 쓰는 API 메서드가 get이라고 생각되는데 useQuery는 데이터를 get 하기 위한 api다. <br>\n동기적으로 실행하고 싶다면 `enabled`옵션을 사용하면 된다.\n\n```js\n// useQuery 옵션\nuseQuery(queryKey, queryFn?, {\n  cacheTime,\n  enabled,\n  networkMode,\n  initialData,\n  initialDataUpdatedAt,\n  isDataEqual,\n  keepPreviousData,\n  meta,\n  notifyOnChangeProps,\n  onError,\n  onSettled,\n  onSuccess,\n  placeholderData,\n  queryKeyHashFn,\n  refetchInterval,\n  refetchIntervalInBackground,\n  refetchOnMount,\n  refetchOnReconnect,\n  refetchOnWindowFocus,\n  retry,\n  retryOnMount,\n  retryDelay,\n  select,\n  staleTime,\n  structuralSharing,\n  suspense,\n  useErrorBoundary,\n})\n```\n\n**· 첫번째 파라미터** : Array형태의 query Key(unique key). <br>\n(이전에는 string, array이 였는데 업데이트 되면서 string만 입력하면 에러가 뜨는걸 보니 array형태의 값이어야 하는 것 같다.)<br>\n**· 두번째 파라미터** : query Function. 즉 api를 요청하는 Promise 기반의 비동기 함수. <br>\n**· 그 외 옵션** : {} 안에서 사용할 수 있는 유용한 프러퍼티들. <br>\n(onError, onSuccess 등 비동기 요청에 대한 성공 실패를 쉽게 다룰 수 있다.)\n\nuseQuery는 기본적으로 비동기로 동작하기 때문에 여러개의 useQuery가 존재한다면 여러개가 동시에 실행된다. (여러개가 존재한다면 useQueries 사용)\n\n```js\n// 여러 useQuerie - 가독성 및 불필요한 코드 증가\nconst query1 = useQuery([\"data1\"], fetchData1)\nconst query2 = useQuery([\"data2\"], fetchData2)\nconst query3 = useQuery([\"data3\"], fetchData3)\n\n// useQueries 사용\nconst results = useQueries({\n  queries: [\n    { queryKey: [\"post\", 1], queryFn: fetchPost, staleTime: Infinity },\n    { queryKey: [\"post\", 2], queryFn: fetchPost, staleTime: Infinity },\n  ],\n})\n```\n\n### 2. useMutation\n\nuseMutation은 서버의 데이터를 바꿀때 (create, update, delete) 사용하는 api다. <br>\nmutation에 대한 다양한 프러퍼티를 제공한다.\n\n```js\nconst {\n  data,\n  error,\n  isError,\n  isIdle,\n  isLoading,\n  isPaused,\n  isSuccess,\n  mutate,\n  mutateAsync,\n  reset,\n  status,\n} = useMutation(mutationFn, {\n  cacheTime,\n  mutationKey,\n  networkMode,\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess,\n  retry,\n  retryDelay,\n  useErrorBoundary,\n  meta,\n})\n\n// mutate 함수를 호출하여 mutation을 실행\nmutate(variables, {\n  onError,\n  onSettled,\n  onSuccess,\n})\n```\n\n```js\n// WritePost.js\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\n\nconst WritePost = () => {\n  const addPost = (data) => {\n    return axios.post(`https://jsonplaceholder.typicode.com/posts`, data);\n  };\n\n  const mutation = useMutation((data) => addPost(data), {\n    onMutate: (variables) => {\n      console.log('onMutate', variables);\n      // variable : { title: `title`, body: `body`, userId: 1 }\n    },\n    onError: (error, variables, context) => {\n      console.log('onError', context);\n    },\n    onSuccess: (data, variables, context) => {\n      console.log('onSuccess', data);\n\n      // update후에 query key의 get 함수를 재실행\n      queryClient.invalidateQueries(query key);\n\n      // mutation에서 return된 값으로 get 함수의 파라미터를 변경해야할 경우 setQueryData 사용\n      queryClient.setQueryData([query key, { userId: 1 }], data);\n    },\n    onSettled: (data, error, variables, context) => {\n      console.log('onSettled', data);\n    },\n  });\n\n  const handleSubmit = () => {\n    mutation.mutate({ title: `title`, body: `body`, userId: 1 });\n  };\n\n  return (\n    <div>\n      <button type=\"button\" onClick={handleSubmit}>\n        Add to Post\n      </button>\n      {mutation.isLoading && 'loading...'}\n      {mutation.isSuccess && 'post update success!!'}\n    </div>\n  );\n};\n\nexport default WritePost;\n```\n\n### 3. useQuery의 Query Options\n\n자주 쓰이는 Query Option에 대해 알아보자 (더 많은 옵션들은 <a href=\"https://tanstack.com/query/v4/docs/overview\" target=\"_blank\">공식문서</a>에서..)\n\n1. **enabled (boolean)** <br>\n   동기로 바꿔주어 자동으로 실행되지 않게 설정하는 옵션\n2. **retry (boolean | number | (failureCount: number, error))**<br>\n   요청이 실패했는 때 재시도 횟수를 정하는 옵션으로, 기본값은 3번이다.\n3. **staleTime (number)** <br>\n   데이터가 Fresh 상태로 유지되는 시간이다. 기본값은 0이며 이후 Stale 상태가 된다.\n4. **cacheTime (number)** <br>\n   Inactive 상태에서 캐시 데이터가 메모리에 남아있는 시간이다. (기본 5분) 이후 가비지 컬렉터에 수거되고 Delete 상태가 된다.\n5. **onSuccess (data)** <br>\n   쿼리 성공 시 실행되는 함수로 서버에서 넘어오는 값을 useState로 설정하기 좋다.\n6. **onError (error)** <br>\n   쿼리 실패 시 실행되는 함수로 에러에 대한 처리를 할 수 있다.\n7. **initialData** <br>\n   쿼리가 아직 생성되기 전에 해당 쿼리값을 불러오도록 코딩하면 참조 에러가 발생하는데 이때 쿼리 캐시의 초기 데이터를 설정한다. (초기 데이터는 기본적으로 Stale 상태임)\n\n## useQuery를 이용한 get 예시\n\n#### 기본설정\n\n먼저 사용하고 있는 React 프로젝트에 Reacy Query를 설치한다. (devtools를 사용하고 싶다면 같이 설치해준다.)\n\n```js\n$ npm i @tanstack/react-query\n// or\n$ yarn add @tanstack/react-query\n\n// devtools\n$ npm i @tanstack/react-query-devtools\n// or\n$ yarn add @tanstack/react-query-devtools\n```\n\n**QueryClientProvider?** <br>\n리액트에서 비동기 요청을 처리하기 위한 Context Provider로 하위 컴포넌트들에서 QueryClient를 사용할 수 있게 해줍니다. (최상위에 위치한다면 전역적으로 사용할 수 있다.)<br>\n\n```js\n// -index.jsx\nimport React from \"react\"\nimport ReactDOM from \"react-dom/client\"\nimport \"./index.css\"\nimport App from \"./App\"\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\"\nimport { ReactQueryDevtools } from \"@tanstack/react-query-devtools\"\n\nconst queryClient = new QueryClient()\nconst rootNode = document.getElementById(\"root\")\n\nReactDOM.createRoot(rootNode).render(\n  <React.StrictMode>\n    <QueryClientProvider client={queryClient}>\n      <App />\n      {/* devtools */}\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  </React.StrictMode>\n)\n```\n\n#### 기본 API를 사용하여 상품 목록 불러오기\n\n![상품목록](img/2022-08-06-react-query.png) <br>\nhttps://fakestoreapi.com 쇼핑몰 api를 사용하여 상품 목록을 불러와보자.\n\n```js\n// ProductList.jsx\nimport React, { useState } from \"react\"\nimport { useQuery } from \"@tanstack/react-query\"\nimport ListProductItem from \"../../ui/Product/ListProductItem\"\nimport { Props, Apis } from \"../../../utils/lib/api\"\n\nconst ProductList = () => {\n  const [products, setProducts] = useState([])\n  const [listType, setListType] = useState(\"list\")\n\n  const { error, status, isLoading } = useQuery(\n    [\"products\"],\n    () => Apis.get(\"/products\"),\n    {\n      onSuccess: data => setProducts(data),\n    }\n  )\n\n  return (\n    <div>\n      {isLoading && <p>isLoading...</p>}\n\n      {products.length > 0 && (\n        <ul>\n          <ListProductItem products={products} />\n        </ul>\n      )}\n    </div>\n  )\n}\n\nexport default ProductList\n```\n\n```js\n// api.js\nimport axios from \"axios\"\n\nconst api = axios.create({\n  baseURL: \"https://fakestoreapi.com/\",\n  headers: {\n    \"Content-type\": \"application/json; charset=UTF-8\",\n    accept: \"application/json,\",\n  },\n})\n\nexport const Apis = {\n  get: (url: string) => api.get(url).then(res => res.data),\n  // post, patch, delete 구현..\n}\n```\n\nReact Query를 처음 사용했을때는 fetch 함수를 작성해야 하는데 (api를 요청하는 부분) 왜 굳이 useQuery를 또 써야하지에 대한 의문점이 생겼었는데 계속 공부를 하다보니 데이터를 좀 더 직관적이고 쉽게 다둘 수 있어 좋다고 생각되는 라이브러리다. error, loading 및 재요청 횟수, 캐시 시간설정까지 옵션을 사용하면 쉽게 데이터를 다룰 수 있어 편하다고 생각되었고 왜 많은 개발회사들이 React Query를 사용하는지 알 수 있었다. <br>\n다가오는 새 프로젝트에서 자유자재로 React Query를 사용하는 그날까지 더 열심히 공부해야겠다. (udemy에 reacy Query에 대한 강의를 보면서 공부했었는데 굳이 강의를 보지 않아도 될정도로 쉽게 배울 수 있는 라이브러리라고 생각된다.)\n"},{"excerpt":"나는 나이많은 비전공자 개발자이기 때문에 항상 어떻게 해야 더 빨리 더 효율적으로 좋은 개발자가 될 지 고민하고 있다. 개발자는 평생 공부해야 하는 직업이기 때문에 입사 전 월요일에는 뭐 공부하고 주말에는 뭐 공부하자라는 식으로 세세한 계획을 세웠었다. 현실은 출퇴근 여행자라 긴 출퇴근 시간에 완벽하게 적응하지 못했고 퇴근하면 4시간 정도후에 잠들어야 한…","fields":{"slug":"/2022-06-12/"},"frontmatter":{"date":"June 12, 2022","title":"[diary] 성장하는 개발자","tags":["diary"]},"rawMarkdownBody":"\n나는 나이많은 비전공자 개발자이기 때문에 항상 어떻게 해야 더 빨리 더 효율적으로 좋은 개발자가 될 지 고민하고 있다. 개발자는 평생 공부해야 하는 직업이기 때문에 입사 전 월요일에는 뭐 공부하고 주말에는 뭐 공부하자라는 식으로 세세한 계획을 세웠었다. 현실은 출퇴근 여행자라 긴 출퇴근 시간에 완벽하게 적응하지 못했고 퇴근하면 4시간 정도후에 잠들어야 한다. (워라벨 붕괴) 또한 출퇴근 길에 공부를 하려고 했으나, 지하철 소음에 적응하지 못해 공부에 집중이 되지 않고 있어 공부에 진척이 없어 초초한 마음이 생겼다. 😨 (이건 익숙해지면 시간이 해결해 줄 거라고 믿는다.)\n\n스타트업 개발자로 일하면서 개발만 잘하는 것이 아닌 사람과 사람사이의 커뮤니케이션이 중요하다는 것을 다시 한번 깨닫게 되었다. 우리 회사 대표님왈) 개발팀 PM님은 개발도 잘하지만 타 부서의 일에 대한 지식도 높아 커뮤니케이션 능력이 뛰어나고 공감능력도 좋아 두루두루 잘 어울리는 사람이라고 하셨다.\n\nPM님은 어린아이 아빠신데 육아도 하시고 직장생활도 잘하시는 체력과 마인드, 정신력?이 대단하다고 생각했다. 아직 근로계약서에 잉크도 안마른 신입이 보기에 정말 대단해 보인다. 특히 사소한걸 여쭤봐도 굉장히 친절하셔서 덤벙거리는 내가 질문을 할 때 굉장히 감사하다. 🙏 <br>\n\n입사한지 이제 2주를 넘겼지만 이렇게 출퇴근 시간에 집중하지 못하고 퇴근후에 공부하지 못하는 내가 답답하고 초조한 마음에 어떻게 하면 더 성장하는 개발자가 될 수 있을까 고민하던 차에 평소 즐겨보는 드림코딩 엘리님의 영상중 <a href=\"https://www.youtube.com/watch?v=T7y6Hl0YZ14\" target=\"_blank\">성장하는 개발자 (시니어 개발자, 테크 리더로 성장한 개발 노트공개) 📓🖋</a>라는 영상을 다시 보고 마음을 잡아보는 계기를 가지려고 한다. (예전에 봤었다.)\n\n영상에서는 총 5가지를 제안하고 있다.\n\n1. 실수를 통해 배우고 성장하자\n2. 멘토를 찾아라 - 멘토찾기는 어렵기 때문에 좀 더 지켜봐야 겠다.\n3. 피드백을 받아라 - 아직 일한지 얼마 되지 않아 받을 피드백이 없을 것 같다.\n4. 성장 다이어리를 통해 방향 설정\n5. 일관성, 엄청난 컴파운딩 효과 - 별거 아닌 것처럼 보이는 작은 것들이 매일매일 모이면 엄청난 효과를 가지고 오는것으로 포기하지 않고 매일 꾸준히 하면 엄청나져 있을 것!!\n\n이 중, 나에게 적용할 수 있는게 무엇인지 생각해 보았고 총 2가지를 실천해 보기로 마음먹었다.\n\n## 1. 실수를 통해 배우고 성장하자\n\n- 실수는 누구나 할 수 있지만 대부분의 사람들은 내가 어떤 실수를 했는지 모르고 지나가거나 또는 너무 부끄러워서 빨리 잊어버리려고만 한다. <br>\n- 실수를 통해서 내가 어떻게 더 개선해 볼 수 있을지 생각해 보고 또 그 실수를 통해서 배워 가겠다는 도전적인 마음가짐이 있다면 더 빠르게 성장할 수 있다. <br>\n- ⭐ 아무리 급하더라도 정확하게 문제를 분석하고 문제를 해결한 다음에는 꼼꼼하게 문제를 검증하는 시간을 가져야 겠다. (성격 급한 나에게 정말 필요한 요소)\n\n![실수들](img/mistakes.jpg)\n내가 노션에 기록한 실수들이다. 일을 시작하기 전부터 쓴건데 그땐 혼자개발공부를 할 때라 딱히 실수 인지도 몰랐던 부분이 많아 기록이 많이 없다. (요즘은 일하면서 매일 반성한다 😂)\n\n## 2. 성장 다이어리를 통해 방향 설정\n\n영상에서는 내가 원하는 것을 명확하게 찾는 것과 다른 사람과의 대화를 통해서 인상이 깊거나 가슴을 뛰게 만드는 그런 순간들을 기록해 둔다고 하셨는데 내가 종이 다이어리에 기록하는 것과 비슷하기 때문에 <u>평소 기술관련 계획이나 스케줄 관리 기록 등</u>이 나의 성장다이어리라고 생각되었다.\n\n![성장](img/grow.jpg)\n![성장](img/grow-2.jpg)\n\n위의 2가지와 꾸준한 스터디를 통해 개발자의 소양을 기른다면 5번의 컴파운딩 효과로 인해 꾸준히 성장하는 주니어 개발자가 될 수 있다고 믿는다. <br>\n오랜만에 하는 포스팅도 새로운 계기가 된 것 같다. (꾸준히 올리자..) <br>\n앞으로 내 실수를 통해 깨우침을 느끼고 성장 다이어리로 내 성장력의 방향성과 원동력을 끌어올려봐야 겠다.\n"},{"excerpt":"주소창에 URL을 입력하면, DNS 서버 검색 \n브라우저는 DNS(Domain Name System)를 운영하는 서버를 통해 서버의 실제 주소인 IP 주소를 요청한다. 매핑되는 IP 주소가 있다면 사용자가 입력한 URL 정보와 함께 전달한다. 브라우저는 IP 주소를 이용해서 서버에 요청을 보낸다. \n페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로…","fields":{"slug":"/2022-04-25-url-web/"},"frontmatter":{"date":"April 25, 2022","title":"[web] 브라우저에 URL을 입력했을 때 발생하는 일들","tags":["web"]},"rawMarkdownBody":"\r\n주소창에 URL을 입력하면,\r\n\r\n1. **DNS 서버 검색** <br>\r\n   브라우저는 DNS(Domain Name System)를 운영하는 서버를 통해 서버의 실제 주소인 IP 주소를 요청한다. 매핑되는 IP 주소가 있다면 사용자가 입력한 URL 정보와 함께 전달한다.\r\n2. **브라우저는 IP 주소를 이용해서 서버에 요청을 보낸다.** <br>\r\n   페이지 URL 정보와 전달받은 IP 주소는 HTTP 프로토콜을 사용하여 HTTP 요청 메시지를 생성하고, 이렇게 생성된 HTTP 요청 메시지는 TCP 프로토콜을 사용하여 인터넷을 거쳐 해당 IP 주소의 컴퓨터로 전송된다. 이렇게 도착한 HTTP 요청 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 URL 정보로 변환되어 웹 페이지 URL 정보에 해당하는 데이터를 검색한다.\r\n3. **서버는 요청에 대한 응답을 보내준다.** <br>\r\n   검색된 웹 페이지 데이터는 또 다시 HTTP 프로토콜을 사용하여 HTTP 응답 메시지를 생성하고 TCP 프로토콜을 사용하여 인터넷을 거쳐 원래 컴퓨터로 전송된다.\r\n4. **브라우저는 응답 결과를 렌더링 한다.**<br>\r\n   도착한 HTTP 응답 메시지는 HTTP 프로토콜을 사용하여 웹 페이지 데이터로 변환되어 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 된다.\r\n\r\n<br>\r\n\r\n<img src=\"https://media.vlpt.us/images/woo0_hooo/post/e119383c-61cc-46d5-a85d-b27b65ddee1e/Untitled.png\">\r\n\r\n<small class=\"from add\">참고 : <a href=\"https://sophia2730.tistory.com/entry/DNS-주소창에-wwwnavercom을-치면-일어나는-일\" tearget=\"_blank\">https://sophia2730.tistory.com/entry/DNS-주소창에-wwwnavercom을-치면-일어나는-일</a><br><a href=\"https://velog.io/@woo0_hooo/네트워크-웹-통신의-흐름\" target=\"_blank\">https://velog.io/@woo0_hooo/네트워크-웹-통신의-흐름</a>\r\n</small>\r\n"},{"excerpt":"Redux의 미들웨어 라이브러리 중 한 개로 Redux-thunk, Redux-toolkit 등 다양한 라이브러리가 존재하지만 Redux-saga를 사용하는 기업이 많다. \nRedux-saga는 다른 라이브러리에 비해 더 복잡한 비동기 처리를 할 수 있다는 장점이 있다. \n단점은 러닝커브가 높고 제네레이터라는 문법에 익숙하지 않다면 어색하게 느껴 질 수 …","fields":{"slug":"/2022-04-25-redux-saga/"},"frontmatter":{"date":"April 25, 2022","title":"[redux] Redux Saga","tags":["redux"]},"rawMarkdownBody":"\r\nRedux의 미들웨어 라이브러리 중 한 개로 Redux-thunk, Redux-toolkit 등 다양한 라이브러리가 존재하지만 Redux-saga를 사용하는 기업이 많다. <br>\r\nRedux-saga는 다른 라이브러리에 비해 더 복잡한 비동기 처리를 할 수 있다는 장점이 있다. <br>\r\n단점은 러닝커브가 높고 제네레이터라는 문법에 익숙하지 않다면 어색하게 느껴 질 수 있다. 또한 코드가 길어져 복잡해질 수 있다. <br>\r\n(최근엔 toolkit도 많이 쓰이며 saga의 기능을 설치하여 연동 가능하다고 하니 toolkit도 공부하면 좋을 것 같다.)\r\n\r\n## 선수지식 - 제너레이터 (Generator)\r\n\r\n- 함수에 \\*를 붙이고, yield라는 문법을 사용\r\n- next()를 이용하여 다음 yield를 호출\r\n\r\n```js\r\nconst gen = function* () {\r\n  console.log(1)\r\n  yield\r\n  console.log(2)\r\n  yield\r\n  console.log(3)\r\n}\r\nconst gener = gen()\r\ngener().next() // 1\r\ngener().next() // 2\r\ngener().next() // 3\r\ngener().next() // undifined\r\n```\r\n\r\n## Redux-saga 주요 Effects\r\n\r\n### 1. fork\r\n\r\n`fork`는 함수의 비동기적인 호출을 할 때 사용하며 순서 상관없이 실행할 때 사용한다.\r\n\r\n```js\r\nexport default function* cartSagas() {\r\n  yield all([\r\n    fork(watchCartList),\r\n    fork(watchAddToCart),\r\n    fork(watchIncrementItem),\r\n    fork(watchDecrementItem),\r\n    fork(watchRemoveItem),\r\n  ])\r\n}\r\n```\r\n\r\n### 2. call\r\n\r\n`call`은 동기 실행을 보장하며 순서대로 함수를 실행해야하는 API 요청 같은 곳에 사용한다. <br>\r\n함수의 첫 번째 파라미터는 함수, 나머지 파라미터는 해당 함수에 넣을 인수다.\r\n\r\n```js\r\n// 장바구니 상품 조회\r\nconst cartListAPI = async payload => {\r\n  await fetch(`${url}/cart-items`, {\r\n    method: \"GET\",\r\n    headers: header,\r\n  })\r\n  return payload\r\n}\r\n\r\nfunction* cartList(action) {\r\n  try {\r\n    const result = yield call(cartListAPI, action.payload)\r\n    const json = yield call([result, \"json\"])\r\n    yield put({\r\n      type: CART_LIST_SUCCESS,\r\n      payload: json,\r\n    })\r\n  } catch (e) {\r\n    yield put({\r\n      type: FAILURE,\r\n      payload: result.statusText,\r\n    })\r\n  }\r\n}\r\n\r\nfunction* watchCartList() {\r\n  yield takeLatest(CART_LIST_REQUEST, cartList)\r\n}\r\n```\r\n\r\n### 3. put\r\n\r\n특정 액션을 dispatch하도록 한다.\r\n\r\n```js\r\nfunction* loadComments(action) {\r\n  try {\r\n    const result = yield call(loadCommentsAPI, action.payload)\r\n    yield put({\r\n      type: COMMENT_LOADING_SUCCESS,\r\n      payload: result.data,\r\n    })\r\n  } catch (e) {\r\n    yield put({\r\n      type: COMMENT_LOADING_FAILURE,\r\n      payload: e,\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n### 4. takeEvery\r\n\r\n`takeEvery`는 모든 액션에 대해 특정 작업을 처리해준다. <br>\r\nwhile(true)로 감싸는 효과가 있다.\r\n\r\n```js\r\nfunction* watchLoadComments() {\r\n  yield takeEvery(COMMENT_LOADING_REQUEST, loadComments)\r\n  // → 들어오는 모든 COMMENT_LOADING_REQUEST 액션에 대해 loadComments 함수 실행\r\n}\r\n```\r\n\r\n### 5. takeLatest\r\n\r\n같은 종류의 액션이 여러 번 요청된다면 취소 처리하고 가장 마지막 액션 작업만 수행된다.\r\n\r\n- `takeEvery`는 모든 액션을 처리하고 `takeLatest` 가장 마지막 액션만 처리\r\n- ex) 특정 버튼을 여러 번 클릭하는 경우에 사용\r\n\r\n```js\r\nfunction* watchCartList() {\r\n  yield takeLatest(CART_LIST_REQUEST, cartList)\r\n  // → 들어오는 모든 CART_LIST_REQUEST 액션에서 가장 마지막 cartList 함수 실행\r\n}\r\n```\r\n\r\n### 6. delay\r\n\r\n설정된 시간 이후에 resolve 하는 Promise 객체를 리턴한다. <br>\r\n보통 일정 시간 후 다음 함수 단계 실행하도록 한다.\r\n\r\n```js\r\nfunction* upLoadComments(action) {\r\n  try {\r\n    const result = yield call(upLoadCommentsAPI, action.payload)\r\n    yield delay(1000) // 1초 후 COMMENT_UPLOADING_SUCCESS 액션 실행\r\n    yield put({\r\n      type: COMMENT_UPLOADING_SUCCESS,\r\n      payload: result.data,\r\n    })\r\n  } catch (e) {}\r\n}\r\n```\r\n\r\n<small class=\"from add\">참고 : <a href=\"https://kyounghwan01.github.io/blog/React/redux/redux-saga/#%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB-%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%B2\" tearget=\"_blank\">https://kyounghwan01.github.io/blog/React/redux/redux-saga/#사용하는-이유</a>\r\n</small>\r\n"},{"excerpt":"Hooks란? 리액트 16.8 이전 버전에서는 function 컴포넌트에서는 상태(state)를 관리할 수가 없었다. 16.8 버전에서 Hooks 라는 기능이 도입되면서 function 컴포넌트에서도 상태를 관리할 수 있게 되었다. function 컴포넌트의 Hooks를 사용하면 class 컴포넌트에서만 사용할 수 있었던 라이프사이클을 사용할 수 있으며 …","fields":{"slug":"/2022-04-25-hooks/"},"frontmatter":{"date":"April 25, 2022","title":"[react] React Hooks (리액트 훅스)","tags":["react"]},"rawMarkdownBody":"\r\n## Hooks란?\r\n\r\n리액트 16.8 이전 버전에서는 function 컴포넌트에서는 상태(state)를 관리할 수가 없었다. 16.8 버전에서 Hooks 라는 기능이 도입되면서 function 컴포넌트에서도 상태를 관리할 수 있게 되었다. function 컴포넌트의 Hooks를 사용하면 class 컴포넌트에서만 사용할 수 있었던 라이프사이클을 사용할 수 있으며 React의 여러 기능을 함수형 프로그래밍으로 사용할 수 있게 해준다.\r\n\r\n<table class=\"ph_tbl\">\r\n  <tr>\r\n    <th>useState</th>\r\n    <td>컴포넌트의 상태(state)를 관리 할 수 있다.</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useEffect</th>\r\n    <td>의존성 배열에 적힌 값이 변경될 때마다, 특정기능이 작동하도록 할 수 있다.</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useRef</th>\r\n    <td>특정 DOM을 선택하거나 변수를 관리할 수 있다.</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useMemo</th>\r\n    <td>의존성 배열에 적힌 값이 변할 때만 값을 다시 정의할 수 있다.</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useCallback</th>\r\n    <td>의존성 배열에 적힌 값이 변할 때만 함수를 다시 정의할 수 있다.</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useContext</th>\r\n    <td>여러개의 컴포넌트에서 사용할 수 있는 값을(변수, 함수 등) 만들 수 있다</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useReducer</th>\r\n    <td>상태(state) 업데이트 로직을 reducer 함수에 따로 분리 할 수 있다.</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useImperativeHandle <br> (+ forwardedRef)</th>\r\n    <td>useRef로 만든 래퍼런스를 상위 컴포넌트로 전달할 수 있다. <br>\r\n   (useImperativeHandle와 forwardedRef를 활용하면 부모 컴포넌트가 자식 컴포넌트의 함수를 호출하거나 값을 가져올 수 있다.)</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useLayoutEffect</th>\r\n    <td>useEffect와 비슷하지만, 모든 DOM 변경 후 브라우저가 화면을 그리기(render)전에 실행되는 기능을 정할 수 있다는 차이점이 있다.</td>\r\n  </tr>\r\n  <tr>\r\n    <th>useDebugValue</th>\r\n    <td>리액트 개발자도구에서 사용자 Hook 레이블을 표시하는 데에 사용할 수 있다. (사용자 정의 Hook의 디버깅을 도와준다.)</td>\r\n  </tr>\r\n</table>\r\n\r\n## useState\r\n\r\n리액트는 state나 props의 값이 변경되면 이를 감지하고 리렌더링을 한다. state는 화면을 바꿔주기위해 사용되는 트리거역할을 하는 값이며 `useState`는 state의 값을 변경해주는 Hook이다.\r\n\r\n**const [state, setState] = useState(기본값);**\r\n\r\n```js\r\n// 수량 변경 예시\r\nimport React, { useState } from \"react\"\r\n\r\nconst Sample = () => {\r\n  const [number, setNumber] = useState(0)\r\n\r\n  const increase = () => setNumber(prev => prev + 1)\r\n  const decrease = () => setNumber(prev => prev - 1)\r\n\r\n  return (\r\n    <div>\r\n      <h1>{number}</h1>\r\n      <button type=\"button\" onClick={increase}>\r\n        +1\r\n      </button>\r\n      <button type=\"button\" onClick={decrease}>\r\n        -1\r\n      </button>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Sample\r\n```\r\n\r\n## useEffect\r\n\r\n`useEffect`는 컴포넌트가 마운트 됐을 때 (처음 나타났을 때), 언마운트 됐을 때 (사라질 때), 그리고 업데이트 될 때 (특정 props가 바뀔 때) 특정 작업을 처리할 수 있다. <br>\r\n`useEffect`는 class 컴포넌트의 라이프 사이클 메서드인 componentDidMount(), componentWillUnmount(), componentDidUpdate()가 합쳐진 것으로 생각하면 된다.\r\n\r\n- clean-up을 이용하지 않는 Effect: **useEffect(() => {}, [])** <br>\r\n- clean-up을 이용하는 Effect: **useEffect(() => { 특정작업 return () => {} }, [])**\r\n  <br>\r\n\r\nclean-up이란? <br>파라미터로 넣은 함수의 return 함수이다. 컴포넌트가 Unmount 될 때만 cleanup 함수를 실행시키고 싶다면 deps에 빈 배열을, 특정 값이 업데이트되기 직전에 cleanup 함수를 실행시키고 싶다면 deps에 해당 값을 넣어주면 된다. (class 라이프 사이클의 componentWillUnmount와 비슷)\r\n\r\n```js\r\nimport React, { useState, useEffect } from \"react\"\r\n\r\nconst Sample = props => {\r\n  const [isOnline, setIsOnline] = useState(null)\r\n\r\n  useEffect(() => {\r\n    const handleStatusChange = status => setIsOnline(status.isOnline)\r\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange)\r\n\r\n    // effect 이후에 어떻게 정리(clean-up)할 것인지 표시\r\n    return () => {\r\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange)\r\n    }\r\n  }, [])\r\n\r\n  if (isOnline === null) return \"Loading...\"\r\n\r\n  return isOnline ? \"Online\" : \"Offline\"\r\n}\r\nexport default Sample\r\n```\r\n\r\n## useRef\r\n\r\n일반적으로 JS에서 DOM을 선택해야 하는 상황에선 `getElementById`, `querySelector`와 같은 DOM selector 함수를 사용해서 특정 DOM을 선택한다. 리액트에서도 DOM을 선택해야 하는 상황이 발생할 수 있으며 `useRef`를 사용한다.\r\nRef 객체의 .current 값으로 원하는 DOM을 선택한다.\r\n\r\n```js\r\nimport React, { useRef } from \"react\"\r\n\r\nconst Sample = () => {\r\n  const name = useRef()\r\n  const onClick = () => {\r\n    name.current.focus()\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <input name=\"name\" placeholder=\"이름을 입력해주세요.\" ref={name} />\r\n      <button onClick={onClick}>input값에 foucs!</button>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default Sample\r\n```\r\n\r\nuseRef는 일반적으로 컴포넌트에서 특정 DOM을 선택해야 할때 사용하지만 컴포넌트 안에서 <u>조회 및 수정 할 수 있는 변수를 관리</u>할 때도 사용할 수 있다. useRef로 관리하는 변수는 값이 바뀐다고 해서 컴포넌트가 리렌더링 되지 않는다.\r\n\r\n- setTimeout, setInterval\r\n- scroll 위치\r\n\r\n```js\r\n/* https://microcephalus7.github.io/react/js/377 */\r\n\r\n// 1. useState를 사용했을 때\r\nconst [number, setNumber] = useState(0)\r\n\r\nlet timer = setInterval(() => {\r\n  setNumber(number + 1)\r\n  console.log(number) // 0 0 0 0 0 ...\r\n}, 1000)\r\n\r\n// 2. useRef를 사용했을 때\r\nconst number = useRef(0)\r\n\r\nlet timer = setInterval(() => {\r\n  number.current = number.current + 1\r\n  console.log(number) // 0 1 2 3 4 ...\r\n}, 1000)\r\n```\r\n\r\n리액트에서 `useState`를 사용했을 때 prevState와 nextState를 비교하여 값을 변경한다. <br>\r\nsetInterval의 내부 callback의 closure는 prevState를 참조하며 참조로 인하여 prevState는 메모리에 남게되고 가비지 컬렉터의 영향을 받지 않는다. <br>\r\nsetStae로 state를 변경하더라도 closure에 의해 state 값은 변경되지 않고 console에는 같은 값이 찍힌다. (0 0 0 ...) <br>\r\n\r\n리액트에서 `useRef`를 사용하면 순수한 JS 객체를 생성한다. <br>`useState`처럼 값을 비교하는 과정이 없으며 .current로 값을 변경하면 JS 객체도 그대로 변경된다. <br>\r\nsetInterval의 내부 callback의 closure에는 변경되는 .current를 참조한다. <br>\r\n.current로 값을 변경 시 값이 변경되면서 console에는 다른 값이 찍히게 된다. (1 2 3 ...) <br>\r\n\r\n**setInterval, setTimeout 및 리렌더링에 영향을 주지않는 값들은 useRef를 참조하여 값을 변경한다.**\r\n\r\n## useMemo\r\n\r\n`useMemo`는 <a href=\"https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98\" target=\"_blank\">메모이제이션</a>된 값을 return하는 Hook으로 성능최적화에 쓰인다. `useMemo`는 두번째 인자(deps)로 준 인자 중에 하나라도 변경되면 값을 재계산하며 컴포넌트가 리렌더링 될 때마다 소요되는 불필요한 계산을 피할 수 있다. <br>\r\n만약 deps에 아무것도 전달하지 않는다면, 렌더시마다 항상 값을 새롭게 계산하여 return한다.<br>\r\n`useMemo`로 전달된 함수는 렌더링 중에 실행되므로, 렌더링 중에 하지 않는 것을 이 함수 내에서 처리하면 안되고 `useEffect` 내에서 처리해야 한다.\r\n\r\n**useMemo(() => {}, []);**\r\n\r\n```js\r\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b])\r\n```\r\n\r\n### useMemo vs React.memo\r\n\r\n`React.memo`?\r\n\r\n- 컴포넌트를 인자로 받아 새로운 컴포넌트롤 다시 return해주는 Higher-Order Components(HOC)\r\n- 컴포넌트가 같은 props를 받을 때 같은 결과를 렌더링한다면 React.memo를 사용하여 불필요한 컴포넌트 렌더링을 방지할 수 있다.\r\n- 같은 props가 들어온다면 리렌더링을 방지하고 마지막 결과를 재사용한다.\r\n- React.memo는 오직 props가 변경됐는지 아닌지만 체크한다.\r\n- 만약 React.memo에 감싸진 함수형 컴포넌트가 함수 내부에서 useState나 useContext같은 훅을 사용하고 있다면, state나 context가 변경될 때마다 리렌더링된다.\r\n\r\n```js\r\nconst MyComponent = (props) => {\r\n  /* props를 사용하여 렌더링 */\r\n};\r\ncosnt function areEqual = (prevProps, nextProps)  =>{\r\n  /*\r\n  nextProps가 prevProps와 동일한 값을 가지면 true를 반환하고, 그렇지 않다면 false를 반환\r\n  */\r\n}\r\nexport default React.memo(MyComponent, areEqual);\r\n```\r\n\r\n**useMemo와 React.memo의 공통점**<br>\r\n`React.memo`와 `useMemo` 모두 props가 변하지 않으면 인자로 넘긴 함수는 재실행되지 않고, 이전의 메모이즈된 결과를 사용한다.\r\n\r\n**useMemo와 React.memo의 차이점**\r\n\r\n1. React.memo는 HOC, useMemo는 hook이다. <br>\r\n2. React.memo는 HOC이기 때문에 클래스형 컴포넌트, 함수형 컴포넌트 모두 사용 가능하지만, useMemo는 hook이기 때문에 오직 함수형 컴포넌트 안에서만 사용 가능하다.\r\n\r\n## useCallback\r\n\r\n`useCallback`은 useMemo와 비슷한 Hook으로 성능최적화에 사용되는 메모제이션 Hook이다. <br>\r\n`useMemo`는 <u>특정 결과값</u>을 재사용 할 때 사용하는 반면, `useCallback`은 <u>특정 함수</u>를 새로 만들지 않고 재사용하고 싶을때 사용한다.\r\n\r\n**useCallback(() => {}, []);**\r\n\r\n```js\r\n// 함수 안에서 사용하는 상태 혹은 props 가 있다면 꼭, deps 배열안에 포함시켜야 한다.\r\n// props 로 받아온 함수가 있다면, 이 또한 deps에 꼭 포함시켜야 함.\r\nconst memoizedCallback = useCallback(() => doSomething(a, b), [a, b])\r\n```\r\n\r\n## useContext\r\n\r\n리액트는 state를 상위 컴포넌트에서 관리하고 해당 state를 하위 컴포넌트 props로 내려주는데 하위 컴포넌트가 많아질 수록 props를 통해 하위로 계속 전달해야 하기 때문에 컴포넌트가 복잡해 지고 코딩이 불편해진다. <br>\r\n리액트의 기본 기능인 context API를 사용하면 모든 컴포넌트가 context에 있는 state를 자유롭게 사용할 수 있어 편리해진다. (Redux가 contextAPI 기반으로 만들어졌다고 한다.) <br>\r\n`useContext`는 props를 아무 컴포넌트에서도 조회할 수 있게 도와주는 Hook이다. context 객체를 받아 해당 context의 현재 값을 반환한다. <br>\r\nProvider로 감싼 하위 컴포넌트에 props를 전달하지 않아도 어디서든 state에 접근을 할 수 있게 된다.\r\n\r\n```js\r\nconst themes = {\r\n  light: {\r\n    foreground: \"#000000\",\r\n    background: \"#eeeeee\",\r\n  },\r\n  dark: {\r\n    foreground: \"#ffffff\",\r\n    background: \"#222222\",\r\n  },\r\n}\r\n\r\nconst ThemeContext = React.createContext(themes.light)\r\n\r\n// Context.Provider와 useContext를 같이 사용\r\nconst App = () => {\r\n  return (\r\n    <ThemeContext.Provider value={themes.dark}>\r\n      <Toolbar />\r\n    </ThemeContext.Provider>\r\n  )\r\n}\r\n\r\nconst Toolbar = props => {\r\n  return (\r\n    <div>\r\n      <ThemedButton />\r\n    </div>\r\n  )\r\n}\r\n\r\nconst ThemedButton = () => {\r\n  const theme = useContext(ThemeContext)\r\n  return (\r\n    <button style={{ background: theme.background, color: theme.foreground }}>\r\n      I am styled by theme context!\r\n    </button>\r\n  )\r\n}\r\n```\r\n\r\n## useReducer\r\n\r\n`useReducer`는 `useContext`로 내려받은 state에 대해서 state관리를 할 수 있게 된다. <br>\r\n`useReducer`를 사용하면 컴포넌트의 상태 업데이트 로직을 컴포넌트에서 분리시킬 수 있으며 상태 업데이트 로직을 컴포넌트 바깥에 작성 할 수도 있고, 다른 파일에 작성 후 불러와서 사용 할 수도 있다. <br>\r\n`useState`의 대체 함수이며 (state, action) => newState의 형태로 reducer를 받고 dispatch 메서드와 짝의 형태로 현재 state를 반환한다. <br>\r\n\r\n**const [state, dispatch] = useReducer(reducer, 초기값);**\r\n\r\n**reducer?** <br>\r\nreducer는 현재 상태와 액션 객체를 파라미터로 받아와서 새로운 상태를 반환해주는 함수다.\r\n\r\n```js\r\nconst initialState = { count: 0 }\r\n\r\nconst reducer = (state, action) => {\r\n  switch (action.type) {\r\n    case \"increment\":\r\n      return { count: state.count + 1 }\r\n    case \"decrement\":\r\n      return { count: state.count - 1 }\r\n    default:\r\n      throw new Error()\r\n  }\r\n}\r\n\r\nconst Counter = () => {\r\n  const [state, dispatch] = useReducer(reducer, initialState)\r\n  return (\r\n    <>\r\n      Count: {state.count}\r\n      <button onClick={() => dispatch({ type: \"decrement\" })}>-</button>\r\n      <button onClick={() => dispatch({ type: \"increment\" })}>+</button>\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n## Custom Hooks\r\n\r\n리액트의 함수형 컴포넌트에서 로직을 쉽게 재사용하기 위해 Custom Hook을 만들 수 있다. 주로 재사용 되는 로직들을 커스텀 훅으로 만들어 사용한다고 한다. <br>\r\n**자주사용하는 Custom Hook** (1~14번까지는 npm으로 설치 가능)\r\n\r\n1. useTitle: react document의 title을 몇개의 hooks와 함께 바꾸는 것\r\n2. useInput: input 역할\r\n3. usePageLeave: 유저가 페이지를 벗어나는 시점을 발견하고 함수를 실행\r\n4. useClick: 누군가 element를 클릭하는 시점을 발견해 함수 실행\r\n5. useFadeIn: 어떤 element든 상관없이 애니메이션을 element 안으로 서서히 사라지게 만듦\r\n6. useFullscreen: 어떤 element든 풀스크린으로 만들거나 일반화면으로 돌아갈 수 있도록 함\r\n7. useHover: 어떤 것에 마우스를 올렸을 때를 감지\r\n8. useNetwork: online, offline 확인\r\n9. useNotification: notification API 사용할 때 유저에게 알림을 보내줌\r\n10. useScroll: 스크롤을 사용할 때를 감지하여 알려줌\r\n11. useTabs: 웹사이트에 메뉴 또는 무엇이든간에 tab을 사용하기 매우 쉽게 만들어줌\r\n12. usePreventLeave: 유저가 변경사항이나 무엇이든간에 저장하지 않고 페이지를 벗어나길 원할 때 확인\r\n13. useConfirm: 위와 비슷\r\n14. useAxios, useFetch: HTTP requests client axios을 위한 wrapper 같은 것\r\n15. useLocalStorage : 로컬스토리지 쉽게 사용할 수 있도록 함\r\n16. useEventListener\r\n17. useMediaQuery\r\n18. useDarkMode : 다크 모드 관련\r\n    <br>\r\n\r\n이 외에도 <a href=\"https://nikgraf.github.io/react-hooks/\" target=\"_blank\">https://nikgraf.github.io/react-hooks/</a>에서 다양한 custom hook을 확인할 수 있다. <br><br>\r\n\r\n<small class=\"from add\">참고 : <a href=\"https://microcephalus7.github.io/react/js/377/\" tearget=\"_blank\">https://microcephalus7.github.io/react/js/377/</a><br>\r\n<a href=\"https://react.vlpt.us/\" target=\"_blank\">https://react.vlpt.us/</a><br>\r\n<a href=\"https://defineall.tistory.com/900\" target=\"_blank\">https://defineall.tistory.com/900</a><br>\r\n<a href=\"https://sustainable-dev.tistory.com/137\" target=\"_blank\">https://sustainable-dev.tistory.com/137</a><br>\r\n<a href=\"https://ko.reactjs.org/\" target=\"_blank\">https://ko.reactjs.org/</a><br>\r\n<a href=\"https://velog.io/@goyou123/Custom-Hook\" target=\"_blank\">https://velog.io/@goyou123/Custom-Hook</a>\r\n</small>\r\n"},{"excerpt":"리액트를 사용하면서 virtual dom(VDOM)과 관련된 글을 많이 보게 되었다. \nvirtual dom, 직역하면' 가상의 dom'이란 뜻인데 의미만으론 정확한 개념을 알수가 없었다. \nVDOM엔 대해 알기위해서 팔요한 선행지식에 대해 알아보자 브라우저 workflow Virtual DOM을 사용하는 이유를 알기 위해서는 우리가 사용하는 브라우저가 …","fields":{"slug":"/2022-04-25-virtual-dom/"},"frontmatter":{"date":"April 25, 2022","title":"[react] Virtual Dom (가상 돔)","tags":["react"]},"rawMarkdownBody":"\r\n리액트를 사용하면서 virtual dom(VDOM)과 관련된 글을 많이 보게 되었다. <br>\r\nvirtual dom, 직역하면' 가상의 dom'이란 뜻인데 의미만으론 정확한 개념을 알수가 없었다. <br>\r\nVDOM엔 대해 알기위해서 팔요한 선행지식에 대해 알아보자\r\n\r\n## 브라우저 workflow\r\n\r\nVirtual DOM을 사용하는 이유를 알기 위해서는 우리가 사용하는 브라우저가 어떻게 동작하는지 알아야 할 필요가 있다.\r\n\r\n<h4>렌더링 엔진의 동작 과정</h4><br>\r\n\r\n<img src=\"https://d2.naver.com/content/images/2015/06/helloworld-59361-2.png\"><br><br><br>\r\n<img src=\"https://d2.naver.com/content/images/2015/06/helloworld-59361-3.png\">\r\n<small class=\"from\">이미지 출처 : <a href=\"https://d2.naver.com/helloworld/59361\" target=\"_blank\">브라우저는 어떻게 동작하는가?</a></small>\r\n\r\n### DOM Tree 생성\r\n\r\n브라우저가 서버에서 HTML을 전달받으면, 렌더링 엔진이 HTML을 파싱하고, DOM의 Node로 이루어진 트리를 만든다. (Node는 html 엘리먼트와 연관)\r\n\r\n### Render Tree 생성\r\n\r\ncss파일과 각 엘리먼트의 inline 스타일을 파싱하고 CSSOM을 생성한다. (노드의 스타일을 처리하는 과정 : 어테치먼트)\r\n→ DOM Tree와 CSSOM을 결합하여 새로운 **Render Tree**를 생성한다.\r\n\r\n### Layout (=Reflow)\r\n\r\n생성된 렌더트리의 각 노드들이 스크린상의 좌표가 주어지고, 어느 공간에 위치해야 하는지가 결정된다. <br>\r\n(position이나 size 등이 여기서 계산된다)\r\n\r\n### Painting\r\n\r\n구성된 레이아웃을 화면에 그리는 과정이 진행된다. 트리의 각 노드들을 거쳐가면서 화면이 스크린에 나타난다. <br>\r\nDOM을 임의적으로 조작을 하면 이 과정들이 반복된다.  \r\n<br>\r\n\r\n## Virtual DOM\r\n\r\nDOM에 하나라도 변화가 생기면 렌더트리 재생성~~페인팅 과정이 반복된다. 이 과정들이 반복될수록 브라우저가 많은 연산을 하게되고 전체적인 성능이 떨어지고 속도가 느려지게 된다.\r\n\r\n리액트는 SPA(Single Page Application)로써, SPA로 만들어진 페이지의 DOM 객체는 매우 많고 복잡하다. DOM이 많아진 만큼 DOM의 조작이 많이 발생하게 되기때문에 비효율적인 프로세스가 만들어진다.\r\n\r\nVirtual DOM은 DOM의 변화가 실제 DOM에 적용되기 전의 변화들을 감지한다. 변경사항을 메모리에 올라간 가상 DOM을 수정하고 실제 DOM과 비교하여 변경된 부분만 실제 DOM에 반영한다. <br> 이로 인해 더 반응성이 빠른 웹을 구현할 수 있다.\r\n\r\nVirtual DOM은 실제 DOM의 복사본이다. 리액트는 Virtual DOM을 두고 개발자는 직접 DOM을 제어하지 않고 Virtual DOM을 제어한다. (React가 DOM과 Virtual DOM을 비교하여 반영한다.)\r\n\r\n## 리액트는 이전과 현재의 Virtual DOM을 어떻게 비교할까?\r\n\r\n리액트는 render() 함수를 통해 리액트 엘리먼트들의 트리를 만든다. 리액트의 state값이 바뀌면서 리렌더링이 발생하면 render() 함수는 새로운 리액트 엘리먼트 트리를 생성해서 리턴해줘야 한다. 하나의 트리가 N개의 엘리먼트를 가지고 있을때 새로운 엘리먼트 트리로 변환하는데는 O(n³)시간이 소요되는 적지않는 시간이 소요된다. <br>\r\n그래서 리액트의 Virtual DOM은 이전과 VDOM과 현재의 VDOM을 비교해서 바뀐 부분만 변경한다. (최적화에 유리)<br>\r\n리액트에서 가장 효과적으로 업데이트된 부분만을 찾아서 갱신하는 방법으로 `Reconciliation`이 있다.\r\n\r\n- Reconciliation : 직전에 렌더링된 엘리먼트와 새로 반환된 엘리먼트를 비교하여 두 엘리먼트가 일치하지 않으면 리액트는 새로운 요소로 DOM을 업데이트하는 프로세스.\r\n\r\n↓ Reconciliation은 리액트 공식문서에 자세히 나와있으니 참고\r\n\r\n<iframe src=\"https://ko.reactjs.org/docs/reconciliation.html\" style=\"width:100%; height:400px; border: 1px solid #ddd\"></iframe>\r\n<a href=\"https://ko.reactjs.org/docs/reconciliation.html\" traget=\"_blank\">https://ko.reactjs.org/docs/reconciliation.html</a>\r\n"},{"excerpt":"async/await는 ES8에서 채택되었으며 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기처럼 동작하도록 구현할 수 있다. \n프로미스를 기반으로 동작하며 프로미스의 then/catch/finally 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수…","fields":{"slug":"/2022-04-25-async-await/"},"frontmatter":{"date":"April 25, 2022","title":"[javascript] Async await","tags":["javascript"]},"rawMarkdownBody":"\r\nasync/await는 ES8에서 채택되었으며 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기처럼 동작하도록 구현할 수 있다. <br>\r\n프로미스를 기반으로 동작하며 프로미스의 then/catch/finally 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.\r\n\r\n## 제너레이터 (Generator)\r\n\r\nEs6에서 도입된 제너레이터는 코드 블록의 실행을 일시 중지시켰다가 필요한 시점에 재개할 수 있는 특수한 함수다. <br>\r\n제너레이터는 이터레이터를 발생시키는 함수로 사용되면 function\\* 키워드로 선언한다. <br>\r\n제너레이터 함수는 화살표 함수로 정의하 수없으며 new 연산자와 함께 생성자 함수로 호출할 수 없다. <br>\r\n**\\*이터레이터(iterator)?** {value, done} 객체를 리턴하는 next()를 가진 값 <br>\r\n\r\n```js\r\n// 제너레이터 함수 선언문\r\nfunction* generatorFunc() {\r\n  yield 1\r\n}\r\n// 제너레이터 메서드\r\nconst obj = {\r\n  *genObjMethod() {\r\n    yield 1\r\n  },\r\n}\r\n// 제너레이터 클래스 메서드\r\nclass GenClass {\r\n  *genClsMethod() {\r\n    yield 1\r\n  }\r\n}\r\n```\r\n\r\n### \\*제너레이터 vs 일반함수\r\n\r\n1. **제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.** <br>\r\n   일반 함수를 호출하면 제어권이 함수에게 넘어가고 함수 코드를 일괄 실행한다. (호출 이후 함수 실행을 제어할 수 없다.)<br>\r\n   제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다. (함수 제어권을 호출자에게 양도 할 수 있다.)\r\n2. **제너레이터 함수는 함수 호출자와 함수의 상태를 주고 받을 수 있다.** <br>\r\n   일반함수는 함수가 실행되고 있는 동안에는 함수 외부에서 함수 내부로 값을 전달하여 함수의 상태를 변경할 수 없다.<br>\r\n   제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 양방향으로 상태를 전달받을 수도 있다.\r\n3. **제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.**\r\n   일반 함수를 호출하면 함수 코드를 일관 실행하고 값을 반환한다.<br>\r\n   제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.\r\n\r\n**\\*이터러블(iterable)?** iterator를 리턴하는 \\[Symbol.iterator]() 를 가진 값 <br>\\*비동기 처리를 동기처리처럼 구현\r\n\r\n```js\r\n// 제너레이터 실행기\r\nconst async = generatorFunc => {\r\n  const generator = generatorFunc()\r\n\r\n  const onResolved = arg => {\r\n    const result = generator.next(arg)\r\n\r\n    return result.done\r\n      ? result.value\r\n      : result.value.then(res => onResolved(res))\r\n  }\r\n  return onResolve\r\n}\r\n\r\nasync(function* fetchTodo() {\r\n  const url = \"https://jsonplaceholder.typicode.com/todos/1\"\r\n\r\n  const response = yield fetch(url)\r\n  const todo = yield response.json()\r\n  console.log(todo)\r\n  // {userId: 1, id: 1, title: 'delecus aut autem', completed: false}\r\n})()\r\n```\r\n\r\n## async/await\r\n\r\n제너레이터를 사용해서 비동기 처리를 동기 처리처럼 동작하도록 구현했지만 코드가 장황해지고 가독성이 나쁘다. 이는 async/await를 사용하면 해결할 수 있다.\r\n\r\n### async 함수\r\n\r\nawait 키워드는 반드시 async 함수 내부에서 사용해야 한다. async 함수는 언제나 프로미스를 반환한다. async 함수가 명시적으로 프로미스를 반환하지 않더라도 async 함수는 암묵적으로 반환값을 resolve하는 프로미스를 반환한다.\r\n\r\n```js\r\n// async 함수 선언문\r\nasync function foo(n) {\r\n  return n\r\n}\r\nfoo(1).then(v => conole.log(v)) // 1\r\n\r\n// async 함수 표현식\r\nconst bar = async function (n) {\r\n  return n\r\n}\r\nbar(2).then(v => conole.log(v)) // 2\r\n\r\n// async 화살표 함수\r\nconst baz = async n => n\r\nbaz(3).then(v => console.log(v)) // 3\r\n\r\n// async 메서드\r\nconst obj = {\r\n  async foo(n) {\r\n    return n\r\n  },\r\n}\r\nobj.foo(4).then(v => console.log(v)) // 4\r\n\r\n// async 클래스 메서드\r\nclass MyClass {\r\n  async bar(n) {\r\n    return n\r\n  }\r\n}\r\n\r\nconst myClass = new MyClass()\r\nmyClass.bar(5).then(v => conole.log(v)) // 5\r\n```\r\n\r\n클래스의 constructor 메서드는 async 메서드가 될 수 없다. 클래스의 constructor 메서드는 인스턴스를 반환해야 하지만 async 함수는 언제나 프로미스를 반환해야 한다. <br><br>\r\n\r\n### await 키워드\r\n\r\nawait 키워드는 프로미스가 settled 상태(비동기처리가 수행된 상태)가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환한다. await 키워드는 반드시 프로미스 앞에서 사용해야 한다.\r\n\r\n```js\r\nconst getGithubUserName = async id => {\r\n  // fetch 함수가 수행한 HTTP 요청에 대한 서버의 응답이 도책해서 반환된 프로미스가 settled 상태가 될때까지 대기\r\n  const res = await fetch(`https://api.github.com/user/${id}`)\r\n\r\n  // 이후 프로미스가 settled 상태가 되면 프로미스가 resolve한 처리 결과가 res 변수에 할당된다.\r\n  const { name } = await res.json()\r\n  console.log(name)\r\n}\r\ngetGithubUserName(\"phrygia\")\r\n```\r\n\r\n```js\r\nasync function foo() {\r\n  const a = await new Promise(resolve => setTimeout(() => resolve(1), 3000))\r\n  const b = await new Promise(resolve => setTimeout(() => resolve(2), 2000))\r\n  const c = await new Promise(resolve => setTimeout(() => resolve(3), 1000))\r\n\r\n  console.log([a, b, c]) // [1, 2, 3]\r\n}\r\nfoo() // 6초 소요\r\n```\r\n\r\n### 에러 처리\r\n\r\n비동기 처리를 위한 콜백 패턴의 단점 중 가장 심각한 것은 에러 처리가 곤란하다는 것이다. 하지만 async/await는 try...catch문을 사용할 수 있다. 콜백 함수를 인수로 전달받는 비동기 함수와는 달리 프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있다. <br>\r\n\r\n```js\r\nconst foo = async () => {\r\n  try {\r\n    const wrongUrl = \"https://wrong.url\"\r\n\r\n    const response = await fetch(wrongUrl)\r\n    const data = await response.json()\r\n    console.log(data)\r\n  } catch (err) {\r\n    console.error(err)\r\n  }\r\n}\r\n```\r\n\r\n**async 함수 내에서 catch 문을 사용해서 에러 처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환한다.** 따라서 async 함수를 호출하고 Promise.prototype.catch 후속 처리 메서드를 사용해 에러를 캐치할 수도 있다.\r\n\r\n```js\r\nconst foo = async  () => {\r\n\tconst wrongUrl  = \"https://wrong.url\";\r\n\r\n\tconst response = await fetch(wrongUrl);\r\n\tconst data = await response.json();\r\n\treturn data;\r\n}\r\n\r\nfoo().\r\n\t.then(console.log)\r\n\t.catch(console.error);\r\n```\r\n\r\n#### 에러 처리의 필요성\r\n\r\n에러가 발생하지 않는 코드를 작성하는 것은 불가능하다. 따라서 에러는 언제나 발생할 수 있다. 발생한 에러에 대해 대처하지 않고 방치하면 프로그램은 강제 종료된다. <br>\r\ntry/catch 문을 사용해 발생한 에러에 적절하게 대응하면 프로그램이 강제 종료되지 않고 계속해서 코드를 실행시킬 수 있다.\r\n\r\n```js\r\n// 1. 에러 발생상황\r\nconsole.log(\"[Start]\")\r\n\r\nfoo() // ReferenceError: foo is not defined\r\n// 에러에 의해 프로그램이 강제 종료된다.\r\n\r\n// 프로그램의 종료로 인해 End는 출력되지 않는다.\r\ncosnole.log(\"[End]\")\r\n\r\n// 2. try/catch\r\nconsole.log(\"[Start]\")\r\ntry {\r\n  foo()\r\n} catch (err) {\r\n  console.error(\"[에러 발생]\", err)\r\n  // [에러 발생] ReferenceError: foo is not defined\r\n}\r\n\r\n// 발생한 에러에 적절한 대응을 하면 프로그램이 강제 종료되지 않는다.\r\ncosnole.log(\"[End]\")\r\n\r\n// 3. DOM에 button 요소가 존재하지 않으면 querySelector 메서드는 에러를 발생시키지 않고 null을 반환한다.\r\nconst $button = document.querySelector(\"button\") // null\r\n\r\n// 옵셔널 체이닝 연산자 (?.)를 사용하지 않으면 TypeError가 발생한다.\r\n$button?.classList.add(\"disabled\")\r\n```\r\n"},{"excerpt":"자바스크립트는 싱글 스레드로 한번에 한개의 작업만을 다룰 수 있는 동기식 언어이다. \n  *싱글 스레드 : 하나의 프로그램에서 하나의 코드만 실행할 수 있다는 뜻이다. 하나의 작업이 끝나야 다음 작업을 시작할 수 있다. 자바스크립트 런타임이란? 런타임이란 프로그래밍 언어가 구동되는 환경을 말한다. 자바스크립트 런타임은 자바스크립트가 구동되는 환경 종류 :…","fields":{"slug":"/2022-04-25-js-runtime/"},"frontmatter":{"date":"April 25, 2022","title":"[javascript] 자바스크립트 런타임","tags":["javascript"]},"rawMarkdownBody":"\r\n**자바스크립트는 싱글 스레드로 한번에 한개의 작업만을 다룰 수 있는 동기식 언어이다.** <br>\r\n&nbsp; \\*싱글 스레드 : 하나의 프로그램에서 하나의 코드만 실행할 수 있다는 뜻이다. 하나의 작업이 끝나야 다음 작업을 시작할 수 있다.\r\n\r\n## 자바스크립트 런타임이란?\r\n\r\n- 런타임이란 프로그래밍 언어가 구동되는 환경을 말한다.\r\n- 자바스크립트 런타임은 자바스크립트가 구동되는 환경\r\n- 종류 : 웹 브라우저 (크롬, 파이어폭스 등), Node.js\r\n- 런타임 환경 : Memory heap, call stack, web Apis(setTimeout, DOM, AJAX), callback queue, event loop\r\n\r\n**구글의 v8 자바스크립트 엔진 영역**\r\n\r\n1. 콜 스택(call stack) : 소스코드 (전역, 함수 등) 평가 과정에서 생성된 실행 컨텍스트가 추가 및 제거되는 곳이다.\r\n2. 힙(heap) : 객체가 저장되는 메모리 공간. 콜 스택의 실행 컨텍스트는 여기에 저장된 객체를 참조한다.\r\n\r\n**브라우저 환경 및 Node.js 제공**\r\n\r\n1. 콜백 큐(callback queue/event queue/task queue) : setTimeout이나 setInterval과 같은 비동기 함수나 이벤트 핸들러가 일시적으로 보관되는 영역이다.\r\n2. 이벤트 루프(event loop) : 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 콜백 큐에 대기 중인 함수가 있는지 반복해서 확인한다. <br>\r\n   · 비어있는 콜스택 & 콜백 큐에 대기중인 함수가 있을 때 : 이벤트 루프는 **순차적(FIFO)으로 콜백 큐에 대기 중인 함수를 콜 스택으로 이동**시킨다.\r\n\r\n## 어떻게 작동할까?\r\n\r\n```js\r\nfunction foo() {\r\n  console.log(\"foo\")\r\n}\r\n\r\nfunction bar() {\r\n  console.log(\"bar\")\r\n}\r\n\r\nsetTimeout(foo, 0)\r\nbar()\r\n```\r\n\r\n![런타임 구성요소](./img/runtime2.png)\r\n\r\n위의 예제를 보면 setTimeout을 0초로 설정했기때문에 console.log(\"foo\")가 먼저 출력되고 console.log(\"bar\")가 실행된다고 생각한다. 하지만 실제로는 console.log(\"bar\")가 먼저 출력된다.\r\n\r\n1. setTimeout 함수의 실행 컨텍스트가 생성되고 콜스택에 푸시된다. (setTimeout callstack push)\r\n2. setTimeout 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜스택에서 팝(pop)된다. (setTimeout callstack pop)\r\n3. 브라우저 또는 Node.js가 타이머를 설정하고 타이머의 만료를 기다린다. (호출 스케줄링)\r\n4. 타이머가 만료되면 콜백 함수 foo가 콜백 큐에 푸시되고 대기하게 된다. (최소 4ms 후에 setTimeout callback queue push)\r\n5. bar 함수의 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 실행중인 컨텍스트가 된다. (setTimeout callstack push)\r\n6. bar 함수가 종료되고 콜 스택에서 팝된다. (bar callstack pop)\r\n7. 콜 스택의 모든 실행 컨텍스트가 종료되어 <u>비어있다면</u> 이벤트 루프가 감지한다.\r\n8. 태스크 큐에서 대기 중인 foo가 이벤트 루프에 의해 콜 스택에 푸시되고 실행된후 종료되어 팝된다. (foo callstack push/pop)\r\n\r\n<h4 style=\"line-height: 1.6;\">\r\n- 콜 스택에 푸시되는 함수가 많아질수록 속도는 느려진다. <br>\r\n- 콜 스택에 너무 어려운 연산이 실행되면 속도가 느려지며 연산을 처리하는 동안 다른 이벤트의 작동이 멈춘다 (click 이벤트 등이 제대로 작동하지 않을 수 있다.) <br>\r\n<small>&nbsp;&nbsp;&nbsp;→ 처리 시간이 오래 걸리는 연산으로 코딩하면 안된다.</small><br>\r\n- 콜백 큐에 들어가는 이벤트 (onClick 등) 하나에 너무 많은 연산 및 실행 이벤트를 처리하면 안된다. <br>\r\n<small>&nbsp;&nbsp;&nbsp;→ 콜 스택으로 푸시될때의 속도가 저하된다.</small>\r\n</h4>\r\n"},{"excerpt":"자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 비동기에서 사용되던 콜백 패턴은 계속되는 콜백으로 인해 콜백 지옥(Callback Hell)에 빠질 확률이 높다. 콜백 지옥에 빠지면 코드의 가독성이 떨어지고 비동기 처리 중 발생한 에러를 처리하는데 많은 노력이 필요하며 여러 개의 비동기 처리를 한번에 처리하는 데도 한계가 …","fields":{"slug":"/2022-04-25-promise/"},"frontmatter":{"date":"April 25, 2022","title":"[javascript] Promise","tags":["javascript"]},"rawMarkdownBody":"\r\n자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 비동기에서 사용되던 콜백 패턴은 계속되는 콜백으로 인해 콜백 지옥(Callback Hell)에 빠질 확률이 높다. 콜백 지옥에 빠지면 코드의 가독성이 떨어지고 비동기 처리 중 발생한 에러를 처리하는데 많은 노력이 필요하며 여러 개의 비동기 처리를 한번에 처리하는 데도 한계가 있다. <br>\r\nEs6에서는 비동기 처리를 위한 패턴으로 프로미스(Promise)를 도입했다. 프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있어 비동기 처리가 간결하다는 장점이 있다.<br>\r\n또한 프로미스는 HTTP 요청 전송이 가능한 Web API인 fetch함수를 지원한다. 이 포스팅에서는 Promise 뿐만 아니라 콜백과 fetch에 관해서도 간단하게 다룬다.\r\n\r\n## 콜백 함수(Callback Function)란?\r\n\r\n콜백 함수란 파라미터(인자)에 함수를 전달받아 해당 함수의 내부에서 실행하는 함수다. 콜백 지옥에 빠지는 대표적인 사례는 비동기 처리 로직을 위해 콜백 함수를 연속해서 사용했을 때이다.<br>\r\n비동기 처리를 위한 콜백 패턴의 가장 큰 문제점은 에러 처리가 어렵다는 점이다.\r\n\r\n```js\r\n// 콜백을 사용한 Get 비동기 요청\r\nconst get = (url, callback) => {\r\n  const xhr = new XMLHeepRequest()\r\n  xhr.open(\"GET\", url)\r\n  xhr.send()\r\n\r\n  xhr.onload = () => {\r\n    if (xhr.status === 200) {\r\n      callback(JSON.parse(xhr.response))\r\n    } else {\r\n      console.error(`${xhr.status} ${xhr.statusText}`)\r\n    }\r\n  }\r\n}\r\n\r\nget(\"/step1\", a => {\r\n  get(`/step2/${a}`, b => {\r\n    get(`/step3/${b}`, c => {\r\n      get(`/step4/${c}`, d => {\r\n        console.log(d)\r\n      })\r\n    })\r\n  })\r\n})\r\n```\r\n\r\n**\\*콜백 지옥이란?** 비동기 프로그래밍 중 함수의 매개변수로 전달하는 콜백함수가 중첩되는 현상을 말한다.\r\n\r\n## 프로미스 (Promise) 생성\r\n\r\n- Promise 생성자 함수를 new 연산자와 호출하여 생성한다.\r\n- Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는다.\r\n- 전달받은 인수는 resolve(성공), reject(실패)가 있다.\r\n\r\n```js\r\n// Promise 생성\r\nconst promise = new Promise((resolve, reject) => {\r\n  // 비동기 작업 수행\r\n\r\n  if (/* 비동기 성공 */) {\r\n    resolve('성공 결과');\r\n  } else { /* 비동기 실패 */\r\n    reject('실패 이유');\r\n  }\r\n});\r\n```\r\n\r\n```js\r\n// Promise를 사용한 Get 비동기 요청\r\nconst promiseGet = url => {\r\n  return new Promise((resolve, reject) => {\r\n    const xhr = new XMLHttpRequest()\r\n    xhr.open(\"GET\", url)\r\n    xhr.send()\r\n\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) {\r\n        // 성공 resolve 호출\r\n        resolve(JSON.parse(xhr.response))\r\n      } else {\r\n        // 실패 - reject로 에러 처리\r\n        reject(new Error(xhr.status))\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\npromiseGet(\"https://~~~\")\r\n```\r\n\r\n## 프로미스 상태 (Promise state)\r\n\r\n**Promise는 비동기 처리 상태와 처리 결과는 관리하는 객체다.**<br>\r\n\r\n<table class=\"ph_tbl\">\r\n  <tr>\r\n    <th>promise 상태</th>\r\n    <th>의미</th>\r\n    <th>상태 변경 조건</th>\r\n    <th></th>\r\n  </tr>\r\n  <tr>\r\n    <th>pending</th>\r\n    <td>비동기 처리가 아직 수행되지 않은 상태 <b>(기본)</b></td>\r\n    <td>프로미스가 생성된 직후 기본 상태</td>\r\n    <td>- ststus : pending <br> - result : undefined</td>\r\n  </tr>\r\n  <tr>\r\n    <th>fulfilled</th>\r\n    <td>비동기 처리가 수행된 상태 <b>(성공)</b></td>\r\n    <td>resolve 함수 호출</td>\r\n    <td>- ststus : fulfilled <br> - result : value</td>\r\n  </tr>\r\n  <tr>\r\n    <th>rejected</th>\r\n    <td>비동기 처리가 수행된 상태 <b>(실패)</b></td>\r\n    <td>reject 함수 호출</td>\r\n    <td>- ststus : rejected <br> - result : error</td>\r\n  </tr>\r\n</table>\r\n\r\n## 프로미스 후속 처리 메서드\r\n\r\n프로미스의 처리 상태가 변화하면 이에 따른 후속 처리를 해야 한다. 후속 메서드는 then, catch, finally를 제공한다. <br>\r\n**프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다.** <br>\r\n모든 후속 처리 메서드는 프로미스를 반환하며, 비동기로 동작한다. <br>\r\n또한 모든 후속 처리 메서드는 언제나 프로미스를 반환한다.\r\n\r\n### 1. Promise.prototype.then\r\n\r\nthen 메서드는 두 개의 콜백 함수를 인수로 전달받는다.\r\n\r\n1. 비동기 처리가 성공했을 때(fulfilled) 호출 : 프로미스의 비동기 처리 결과를 인수로 전달받음\r\n2. 비동기 처리가 실패했을 때(rejected) 호출 : 프로미스릐 에러를 인수로 전달받음\r\n\r\n```js\r\n// fulfilled\r\nnew Promise(resolve => resolve(\"fulfilled\")).then(\r\n  v => console.log(v),\r\n  e => console.error(e)\r\n) // fulfilled\r\n\r\n// rejected\r\nnew Promise((_, reject) => reject(new Error(\"rejected\"))).then(\r\n  v => console.log(v),\r\n  e => console.error(e)\r\n) // Error: rejected\r\n```\r\n\r\n### 2. Promise.prototype.catch\r\n\r\ncatch 메서드는 비동기 처리에서 발생한 에러를 처리할 수 있다. <br>\r\n한 개의 콜백 함수를 인수로 전달받으며 rejected 상태인 경우만 호출된다. <br>\r\n\r\n\\*then(undefined, onRejected) : then 메서드의 두 번째 콜백 함수는 첫 번째 콜백 함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해져 가독성이 좋지 않다. catch 메서드를 모든 then 메서드를 호출한 이후에 호출하면 비동기 처리에서 발생한 모든 에러뿐만 아니라 then 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있기때문에 에러 처리시에 catch 메서드를 사용하자\r\n\r\n```js\r\n// rejected\r\nnew Promise((_, reject) => reject(new Error(\"rejected\"))).catch(e =>\r\n  console.log(e)\r\n) // Error: rejected\r\n```\r\n\r\n### 3. Promise.prototype.finally\r\n\r\nfinally 메서드는 한 개의 콜백 함수를 인수로 전달받으며 프로미스의 성공과 실패에 관계없이 무조건 한 번만 호출된다. <br> 따라서 finally 메서드는 프로미스의 상태와 상관없이 공통적으로 수행해야 할 처리 내용이 있을 때 유용하다.\r\n\r\n```js\r\nnew Promise(() => {}).finally(() => console.log(\"finally\")) // finally\r\n```\r\n\r\n```js\r\n// Promise 후속처리 메서드를 사용한 Get 비동기 요청\r\nconst promiseGet = (url) => {\r\n  return new Promise((resolve, reject) => {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\", url);\r\n    xhr.send();\r\n\r\n    xhr.onload = () => {\r\n      if (xhr.status === 200) {\r\n        // 성공 resolve 호출\r\n        resolve(JSON.parse(xhr.response));\r\n      } else {\r\n        // 실패 - reject로 에러 처리\r\n        reject(new Error(xhr.status));\r\n      }\r\n    };\r\n  });\r\n};\r\n\r\npromiseGet(\"https://~~~\")\r\n  .then(res => console.log(res))\r\n  .catch(err = > console.error(err))\r\n  .finally(() => conosle.log('Finish!'));\r\n```\r\n\r\n## 프로미스 체이닝(Promise Chaining)\r\n\r\nthen, catch, finally 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있는데 이를 프로미스 체이닝이라 한다. <br>\r\n프로미스 체이닝을 통해 비동기 처리 결과를 전달받아 후속 처리를 하므로 비동기 처리를 위한 콜백 패턴에서 발생하던 콜백 헬이 발생하지 않지만, 프로미스도 콜백 패턴을 사용하므로 콜백 함수를 사용한다. <br>\r\n(\\*콜백패턴은 가독성에 좋지 않기 때문에 async await를 사용하면 좋다.)\r\n\r\n```js\r\npromiseGet(`${url}/posts/1`)\r\n  .then(({ userId }) => promiseGet(`${url}/users/${userId}`)) // 인수 : post가 1인 id값\r\n  .then(userInfo => console.log(userInfo)) // 인수 : post의 userId로 취득한 user 정보\r\n  .catch(err => console.error(err)) // 에러가 발생하지 않으면 호출되지 않는다.\r\n```\r\n\r\n## 프로미스의 정적 메서드\r\n\r\nPromise는 주로 생성자 함수로 사용되지만 함수도 객체이므로 메서드를 가질 수 있다.\r\n\r\n### 1. Promise.resolve / Promise.reject\r\n\r\n- 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다. <br>\r\n- Promise.resolve 메서드는 인수로 전달받은 값을 resolve하는 프로미스를 생성한다.<br>\r\n- Promise.reject 메서드는 인수로 전달받은 값을 reject 하는 프로미스를 생성한다.<br>\r\n\r\n```js\r\n// resolve\r\nconst resolvedPromise = Promise.resolve([1, 2, 3])\r\nresolvedPromise.then(console.log) // [1, 2, 3]\r\n\r\n// reject\r\nconst resolvedPromise = Promise.reject(new Error(\"Error\"))\r\nresolvedPromise.catch(console.log) // Error: Error\r\n```\r\n\r\n### 2. Promise.all\r\n\r\n- 여러 개의 비동기 처리를 모두 병렬 처리할때 사용한다.\r\n- 모든 프로미스가 fulfilled 상태가 되는 것을 기다린다.\r\n- 하나라도 rejected 상태가 되면 에러를 reject하는 새로운 프로미스를 반환한다.\r\n- 인수로 이터러블을 전달하여 사용한다.\r\n- 인수로 전달받은 이터러블의 요소가 프로미스가 아닌 경우 Promise.resolve 메서드를 통해 프로미스로 래핑한다.\r\n\r\n```js\r\nconst requestData1 = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(1), 3000))\r\nconst requestData2 = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(2), 2000))\r\nconst requestData3 = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))\r\n\r\n// 세 개의 비동기 처리를 순차적으로 처리\r\nconst res = []\r\nrequestData1()\r\n  .then(data => {\r\n    // 3초 소요\r\n    res.push(data)\r\n    return requestData2()\r\n  })\r\n  .then(data => {\r\n    // 2초 소요\r\n    res.push(data)\r\n    return requestData3()\r\n  })\r\n  .then(data => {\r\n    // 1초 소요\r\n    res.push(data)\r\n    console.log(res) // [1, 2, 3] => 약 6초 소요\r\n  })\r\n  .catch(console.error)\r\n```\r\n\r\n프로미스를 순차적으로 비동기를 처리한다. 앞선 처리가 완료되면 다음 비동기 처리를 수행한다.<br>\r\n하지만 위 예제에서 사용된 3개의 비동기 처리는 서로 의존하지 않고 개별적으로 수행된다. 즉, 앞선 비동기 처리 결과를 다음 비동기 처리가 사용하지 않는다. 따라서 위 예제의 경우 세 개의 비동기 처리를 순차적으로 처리할 필요가 없다. <br>\r\nPromise.all을 사용하여 여러 개의 비동기를 모두 병렬 처리하는 코드로 수정해보자\r\n\r\n```js\r\nconst requestData1 = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(1), 3000))\r\nconst requestData2 = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(2), 2000))\r\nconst requestData3 = () =>\r\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))\r\n\r\n// 세 개의 비동기 처리를 순차적으로 처리\r\nconst res = []\r\nrequestData1()\r\n  .all([requestData1(), requestData2(), requestData3()])\r\n  .then(console.log) // [1, 2, 3] => 약 3초 소요\r\n  .catch(console.error)\r\n```\r\n\r\n### 3. Promise.race\r\n\r\n- 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve 하는 새로운 프로미스를 반환한다.\r\n- 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.\r\n- 하나라도 rejected 상태가 되면 에러를 reject하는 새로운 프로미스를 반환한다.\r\n\r\n```js\r\nPromise.race([\r\n  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1\r\n  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2\r\n  new Promise(resolve => setTimeout(() => resolve(3), 1000)), // 3\r\n])\r\n  .then(console.log) // 3\r\n  .catch(console.log)\r\n```\r\n\r\n### 4. Promise.allSettled\r\n\r\n- 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다.\r\n- 전달받은 프로미스가 모두 settled 상태(비동기 처리가 수행된 상태, 즉, fufilled 또는 rejected 상태)가 되면 처리 결과를 배열로 반환한다.\r\n- ES11에 도입되었으며 익스플로러에서는 지원하지 않는다.\r\n\r\n```js\r\nPromise.allSettled([\r\n  new Promise(resolve => setTimeout(() => resolve(1), 2000)),\r\n  new Promise((_, reject) =>\r\n    setTimeout(() => reject(new Error(\"Error!\")), 1000)\r\n  ),\r\n]).then(console.log)\r\n/*\r\n[\r\n    {status: \"fufilled\", value: 1},\r\n    {status: \"rejected\", reason: Error: Error! at <anonymous>},\r\n]\r\n*/\r\n```\r\n\r\n## 마이크로태스크 큐\r\n\r\n브라우저 및 node.js에서 제공하는 Task Queue(Callback Queue)는 마이크로 태스크큐(Event Queue)와 매크로 태스크큐(Job Queue)로 나뉜다. <br>\r\n요청 API에 따라 마이크로태스크 큐를 사용하거나, 매크로태스크 큐를 사용한다. <br>\r\n이벤트 루프는 마이크로태스크 큐의 모든 태스크들을 처리한 다음, 태스크 큐의 태스크들을 처리한다. 따라서, Promise의 콜백함수가 setTimeout()의 콜백함수보다 먼저 처리된다. <br>\r\n\r\n<div class=\"blockquote\">\r\n<b>매크로 큐</b>: setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI 렌더링 <br>\r\n<b>마이크로 큐</b>: process.nextTick, <u>Promises</u>, Object.observe, MutationObserver\r\n</div>\r\n\r\n```js\r\nsetTimeout(() => console.log(1), 0) // 1\r\n\r\nPromise.resolve()\r\n  .then(() => console.log(2)) // 2\r\n  .then(() => console.log(3)) // 3\r\n```\r\n\r\n위의 예제에서 1 → 2 → 3의 순서로 출력될 것 처럼 보이지만 실제로는 2 → 3 → 1의 순으로 출력된다. 그 이유는 프로미스가 마이크로태스크 큐에에 저장되기 때문이다. <br>\r\n마이크로태스크 큐에는 프로미스의 후속 처리 메서드의 콜백 함수가 일시 저장된다. 그 외의 비동기 함수의 콜백 함수나 이벤트 핸들러는 매크로 큐에 일시 저장된다. <br>\r\n**마이크로태스크 큐의 우선순위가 매크로 큐보다 높기때문에** 이벤트 루프는 마이크로태스크 큐에서 대기하고 있는 Promise를 더 먼저 가져와 실행한다. <br>\r\n\r\n## fetch\r\n\r\nfetch 함수는 XMLHttpRequest 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 Web API다. <br>\r\n프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다는 장점이 있다. <br>\r\n비교적 최근에 추가된 API이기 때문에 익스플로러를 제외한 대부분의 브라우저에서 사용할 수 있다.\r\n\r\n<div class=\"blockquote\">const promise = fetch(url, [, options])</div>\r\n\r\n**fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다.**\r\n\r\n```js\r\nfetch(\"https://jsonplaceholder.typicode.com/todos/1\")\r\n  .then(response => response.json()) // 1. resolve한 Response 객체를 전달 받을 수 있다.\r\n  .then(json => console.log(json)) // 2\r\n```\r\n\r\n![promise console](./img/promise.jpg)\r\n\r\n1. fetch 요청을 보냈을때 fulfilled한 상태가 된다면, then을 통해 Response 객체를 전달 받을 수 있다. Response.prototype에는 HTTP 응답을 나타내는 다양한 프로퍼티를 제공한다.\r\n2. fetch 함수가 반환된 프로미스의 MIME 타입이 appliaction/json인 응답 몸체를 사용하려면 Response.prototype.json 메서드를 사용하면 된다. <br> (많은 코드에서 response.json()을 사용하는 이유가 이거였구나!)\r\n   \\*Response.prototype.json : Response 객체에서 HTTP 응답 몸체 (response.body)를 취득하여 역직렬화 한다.\r\n   <br>\r\n\r\n**\\*MIME 타입이란?** &nbsp;클라이언트에게 전송된 문서의 다양성을 알려주기 위한 메커니즘 <br>\r\n&nbsp;&nbsp;→ 더 자세히 공부하기 : <a href=\"https://developer.mozilla.org/ko/docs/Web/HTTP/Basics_of_HTTP/MIME_Types\" target=\"_blank\">HTTP MIME 타입</a> <br>\r\n**\\*역직렬화(Deserialization)란?** &nbsp;string 타입의 JSON 데이터를 자바스크립트 객체로 변환하는 것 - JSON.parse() <br>\r\n&nbsp;&nbsp;↔ 직렬화(Serialization) : 자바스크립트 객체를 string 타입의 JSON 데이터로 변환하는 것 - JSON.stringify()\r\n\r\n```js\r\n// fetch로 GET, POST, PATCH, DELETE 요청하기\r\nconst request = {\r\n  get(url) {\r\n    return getch(url)\r\n  },\r\n  post(url, payload) {\r\n    return fetch(url, {\r\n      method: \"POST\",\r\n      headers: { \"content-Type\": \"application/json\" },\r\n      body: JSON.stringify(payload),\r\n    })\r\n  },\r\n  patch(url, payload) {\r\n    return fetch(url, {\r\n      method: \"PATCH\",\r\n      headers: { \"content-Type\": \"application/json\" },\r\n      body: JSON.stringify(payload),\r\n    })\r\n  },\r\n  delete(url) {\r\n    return fetch(url, { method: \"DELETE\" })\r\n  },\r\n}\r\n\r\n// GET\r\nrequest\r\n  .get(\"https://jsonplaceholder.typicode.com/todos/1\")\r\n  .then(response => response.jons())\r\n  .then(todos => console.log(todos))\r\n  .catch(err => console.error(err))\r\n// {userId: 1, id: 1, title: \"delectus aut autem\", completed: false}\r\n\r\n// POST\r\nrequest\r\n  .post(\"https://jsonplaceholder.typicode.com/todos\", {\r\n    userId: 1,\r\n    title: \"Javascript\",\r\n    completed: false,\r\n  })\r\n  .then(response => response.jons())\r\n  .then(todos => console.log(todos))\r\n  .catch(err => console.error(err))\r\n// {userId: 1, id: 1, title: \"Javascript\", completed: false, id: 201}\r\n\r\n// PATCH\r\nrequest\r\n  .patch(\"https://jsonplaceholder.typicode.com/todos/1\", {\r\n    completed: true,\r\n  })\r\n  .then(response => response.jons())\r\n  .then(todos => console.log(todos))\r\n  .catch(err => console.error(err))\r\n// {userId: 1, id: 1, title: \"delectus aut autem\", completed: true}\r\n\r\n// DELETE\r\nrequest\r\n  .delete(\"https://jsonplaceholder.typicode.com/todos/1\")\r\n  .then(response => response.jons())\r\n  .then(todos => console.log(todos))\r\n  .catch(err => console.error(err))\r\n// {}\r\n```\r\n\r\n<small class=\"from add\">참고 : 모던 자바스크립트 Deep Dive\r\n</small>\r\n"},{"excerpt":"scroll 이벤트를 사용하면 스크롤을 올리거나 내리는 짧은 시간동안 많은 이벤트가 발생한다. 복잡한 작업의 scroll 이벤트를 처리한다면 빈번하게 실행되는 이벤트 때문에 성능이 저하되고 렉이 걸릴 확률이 높아진다. \n이처럼 짧은 시간 간격으로 연속해서 발생하는 이벤트의 과도한 이벤트 핸들러 호출을 방지하기 위해 스로틀과 디바운스를 사용하면 성능향상에 …","fields":{"slug":"/2022-04-25-throttle-debounce/"},"frontmatter":{"date":"April 25, 2022","title":"[javascript] throttling과 debouncing","tags":["javascript"]},"rawMarkdownBody":"\r\nscroll 이벤트를 사용하면 스크롤을 올리거나 내리는 짧은 시간동안 많은 이벤트가 발생한다. 복잡한 작업의 scroll 이벤트를 처리한다면 빈번하게 실행되는 이벤트 때문에 성능이 저하되고 렉이 걸릴 확률이 높아진다. <br>\r\n이처럼 짧은 시간 간격으로 연속해서 발생하는 이벤트의 과도한 이벤트 핸들러 호출을 방지하기 위해 스로틀과 디바운스를 사용하면 성능향상에 도움이 된다.\r\n\r\n## 스로틀 (throttle)\r\n\r\n짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 <u>**일정 시간 간격**으로 이벤트 핸들러가 **최대 한 번만 호출**되도록</u> 한다.\r\n즉, 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그릅화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.\r\n\r\n\\*실무에서는 <a href=\"https://underscorejs.org/#throttle\" target=\"_blank\">Underscore의 throttle 함수</a>나 <a href=\"https://www.geeksforgeeks.org/lodash-_-throttle-method/\" target=\"_blank\">Lodash의 throttle 함수</a>를 사용하는것을 권장한다.\r\n\r\n```js\r\n// Underscore\r\nvar throttled = _.throttle(updatePosition, 100)\r\n$(window).scroll(throttled)\r\n\r\n// Lodash\r\n_.throttle(func, wait, options)\r\n```\r\n\r\n## 디바운스 (debounce)\r\n\r\n짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 <u>**일정 시간이 경과한 이후에** 이벤트 핸들러가 **한 번만 호출**되도록 한다.</u>\r\n즉, 디바운스는 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다.\r\n\r\n\\*실무에서는 <a href=\"https://underscorejs.org/#debounce\" target=\"_blank\">Underscore의 debounce 함수</a>나 <a href=\"https://www.geeksforgeeks.org/lodash-_-debounce-method/\" target=\"_blank\">Lodash의 debounce 함수</a>를 사용하는것을 권장한다.\r\n\r\n```js\r\n// Underscore\r\nvar lazyLayout = _.debounce(calculateLayout, 300)\r\n$(window).resize(lazyLayout)\r\n\r\n// Lodash\r\n_.debounce(func, wait, options)\r\n```\r\n\r\n## 스로틀 vs 디바운스\r\n\r\nscroll 이벤트로 스로틀과 디바운스를 비교해보자\r\n\r\n![스로틀디바운스-스크롤-비교](./img/throttle-debounce.gif)\r\n\r\n- 스로틀 : 일정한 시간이 지날 때마다(500ms) 카운터 증가\r\n- 디바운스 : 스크롤이 멈추고(특정 시간 사이에 어떤 이벤트도 발생하지 않았을 때) 500ms후에 카운터 증가\r\n\r\n```html\r\n<ul>\r\n  <li>일반 스크롤 이벤트 카운터 <span class=\"normal-msg\">0</span></li>\r\n  <li>디바운스 스크롤 이벤트 카운터 <span class=\"debounce-msg\">0</span></li>\r\n  <li>스로틀 스크롤 이벤트 카운터 <span class=\"throttle-msg\">0</span></li>\r\n</ul>\r\n\r\n<script>\r\n  const $button = document.querySelector(\"button\")\r\n  const $normalMsg = document.querySelector(\".normal-msg\")\r\n  const $debounceMsg = document.querySelector(\".debounce-msg\")\r\n  const $throttleMsg = document.querySelector(\".throttle-msg\")\r\n\r\n  // 디바운스\r\n  const debounce = (callback, delay) => {\r\n    let timerId\r\n    return event => {\r\n      // delay가 경과하기 이전에 이벤트가 발생하면 이전 타이머를 취소하고 새로운 타이머를 재설정\r\n      // delay보다 짧은 간격으로 이벤트가 발생하면 callback은 호출되지 않는다.\r\n      if (timerId) clearTimeout(timerId)\r\n      timerId = setTimeout(callback, delay, event)\r\n    }\r\n  }\r\n\r\n  // 스로틀\r\n  const throttle = (callback, delay) => {\r\n    let timerId\r\n    return event => {\r\n      // delay가 경과하기 전에 이벤트가 발생하면 아무동작도 하지 않는다.\r\n      // delay가 경과했을 때 이벤트가 발생하면서 새로운 타이머를 재설정한다.\r\n      // 따라서 delay 간격으로 callback이 호출된다.\r\n      if (timerId) return\r\n      timerId = setTimeout(\r\n        () => {\r\n          callback(event)\r\n          timerId = null\r\n        },\r\n        delay,\r\n        event\r\n      )\r\n    }\r\n  }\r\n\r\n  window.addEventListener(\"scroll\", () => {\r\n    $normalMsg.textContent = +$normalMsg.textContent + 1\r\n  })\r\n\r\n  // 500ms 동안 스크롤 이벤트가 발생하지 않으면 한번만 호출한다.\r\n  window.addEventListener(\r\n    \"scroll\",\r\n    debounce(() => {\r\n      $debounceMsg.textContent = +$debounceMsg.textContent + 1\r\n    }, 500)\r\n  )\r\n\r\n  //\r\n  window.addEventListener(\r\n    \"scroll\",\r\n    throttle(() => {\r\n      $throttleMsg.textContent = +$throttleMsg.textContent + 1\r\n    }, 500)\r\n  )\r\n</script>\r\n```\r\n"},{"excerpt":"브라우저 저장소 (Web Storage) 웹의 데이터를 클라이언트에 저장할 수 있는 자료구조다.\nHTML5에서는 웹 사이트의 데이터를 클라이언트에 저장할 수 있는 새로운 자료구조인 Web Storage 스펙이 포함되어있다.\n 쌍으로 데이터를 저장하고 를 기반으로 데이터를 조회하는 패턴이다. \n내부적으로는 영구저장소(LocalStorage)와 임시저장소(S…","fields":{"slug":"/2022-04-25-browsers-repository/"},"frontmatter":{"date":"April 25, 2022","title":"[web] Storage vs Cookie","tags":["web"]},"rawMarkdownBody":"\r\n## 브라우저 저장소 (Web Storage)\r\n\r\n웹의 <u>데이터를 클라이언트에 저장할 수 있는</u> 자료구조다.\r\nHTML5에서는 웹 사이트의 데이터를 클라이언트에 저장할 수 있는 새로운 자료구조인 Web Storage 스펙이 포함되어있다.<br>\r\n`key:value` 쌍으로 데이터를 저장하고 `key`를 기반으로 데이터를 조회하는 패턴이다. <br>\r\n내부적으로는 영구저장소(LocalStorage)와 임시저장소(SessionStorage)가 분리되어 데이터 지속성에 따라 구분할 수 있어 응용 환경에 맞는 선택이 가능하다. <br>\r\nWeb Storage는 Local Storage와 Session Storage 두 가지 방식이 있다.\r\n\r\n### Web Storage의 특징\r\n\r\n1. 서버 전송이 없다 : 데이터를 서버로 전송하지 않기 때문에 트래픽 비용을 아낄 수 있다.\r\n2. 브라우저별 용량제한이 다르다.\r\n3. 영구적으로 저장이 가능하다 : 만료기간 없이 영구적으로 데이터를 저장할 수도 있다.<br>\r\n   (Local Storage = 만료기한 없음, Session Storage = 세션 종료 시 만료)\r\n4. 키와 값은 문자열로 변환되어 저장된다.\r\n5. 쿠키 보다 보안이 우수하며 많은 정보를 담을 수 있다.\r\n\r\n- 장점 : 서버에 불필요한 데이터를 저장을 안 하고, 저장할 수 있는 용량이 크다.\r\n- 단점 : HTML5를 지원되는 브라우저에서 사용이 가능하다.\r\n\r\n### 1. 로컬 스토리지 (Local Storage)\r\n\r\n- 저장한 데이터 영구적으로 보관가능 (브라우저 종료하더라도 데이터가 남아있다.)\r\n- 도메인 마다 별도로 localStorage가 생성된다.\r\n- Windows 전역 객체의 LocalStorage라는 컬렉션을 통해 저장/조회가 이루어 진다.\r\n- Session Storage와 Cookie에 비해 저장 공간이 크다. (최대 5MB까지)\r\n\r\n```js\r\n// localStorage 저장\r\nlocalStorage.setItem(\"token\", \"XXXXXXXX\")\r\nlocalStorage.setItem(\"token\", JSON.stringfy(value))\r\n\r\n// localStorage 조회\r\nlocalStorage.getItem(\"token\")\r\nJSON.parse(localStorage.getItem(\"token\"))\r\n\r\n// localStorage 설정된 키로 삭제\r\nlocalStorage.removeItem(\"token\")\r\n\r\n// localStorage 전체 삭제\r\nlocalStorage.clear()\r\n```\r\n\r\n### 2. 세션 스토리지 (Session Storage)\r\n\r\n- 데이터가 지속적으로 보관되지 않는다. 현재 페이지가 브라우징 되고 있는 브라우저 컨텍스트 내에서만 데이터가 유지된다. <br>\r\n  (브라우저가 종료되면 데이터도 같이 지워진다.)\r\n- Windows 전역 객체의 sessionStorage 컬렉션을 통해 저장/조회가 이루어진다.\r\n- 도메인별로 생성된다.<br>\r\n  (브라우저 컨텍스트가 다르기 때문 같은 도메인/사이트라 하더라도 브라우저가 다르면 서로 다른 영역이된다.)\r\n- 브라우저를 하나 더 실행해서 동일한 페이지를 열었을 때, 두페이지의 sessionStorage는 별개의 영역으로 서로 침범하지 못한다.\r\n\r\n```js\r\n// sessionStorage 저장\r\nsessionStorage.setItem(\"token\", \"XXXXXXXX\")\r\nsessionStorage.setItem(\"token\", JSON.stringfy(value))\r\n\r\n// sessionStorage 조회\r\nsessionStorage.getItem(\"token\")\r\nJSON.parse(sessionStorage.getItem(\"token\"))\r\n\r\n// sessionStorage 설정된 키로 삭제\r\nsessionStorage.removeItem(\"token\")\r\n\r\n// sessionStorage 전체 삭제\r\nsessionStorage.clear()\r\n```\r\n\r\n## Cookie\r\n\r\n- 쿠키를 설정하면 쿠키 정보를 포함하여 서버로 보내진다. <br>\r\n  쿠키에 사용자의 정보를 담아서 서버로 전송하면 서버에서 사용자를 확인할 수 있다. 서버와 클라이언트 간의 지속적인 데이터 교환을 위해 만들어 졌기 때문에 서버로 계속 전송된다.\r\n- 서버에서 데이터 만료일을 설정하고 관리한다.\r\n- 4KB 이하의 아주 작은 데이터를 보관한다.\r\n- 클라이언트에서 읽을 수 있지만, 보통 서버 사이드에서 읽는 데이터 이다.\r\n- 클라이언트에서 쿠키 접급을 방지할 수 있다. (httpOnly= true)\r\n- 종류 : persistent cookies, session cookies\r\n- persistent cookies: 브라우저나 탭이 열려있는 동안에만 저장되며 만료일이 포함되지 않는다 - ex) 은행의 자격 증명 등\r\n- session cookies: 만료일까지 사용자의 브라우저에 저장되고 만료일이 지나면 삭제된다 - ex) 사용자의 행동 기록 등\r\n\r\n**\\*cookie property**\r\n\r\n<table class=\"ph_tbl\">\r\n  <tr>\r\n    <th>property</th>\r\n    <th>설명</th>\r\n  </tr>\r\n  <tr>\r\n    <td>name=</td>\r\n    <td>쿠키의 이름과 값을 설정</td>\r\n  </tr>\r\n  <tr>\r\n    <td>expires= </td>\r\n    <td>쿠키가 만료일 설정 (expires 값이 없으면 브라우저를 닫을때 소멸)</td>\r\n  </tr>\r\n  <tr>\r\n    <td>path=</td>\r\n    <td>쿠키가 적용될 사이트의 패스를 지정하고자 하는 경우 사용</td>\r\n  </tr>\r\n  <tr>\r\n    <td>domain= </td>\r\n    <td>쿠키를 사용할 도메인을 지정</td>\r\n  </tr>\r\n  <tr>\r\n    <td>httpOnly</td>\r\n    <td>자바스크립트에서 쿠키에 접근할 수 없다.</td>\r\n  </tr>\r\n</table>\r\n\r\n```js\r\n// 쿠키 생성하기\r\nconst setCookie = (name, value, expiredays) => {\r\n  const today = new Date()\r\n  today.setDate(today.getDate() + expiredays)\r\n  document.cookie = `${name}=${escape(\r\n    value\r\n  )}; path=/; expires=${today.toGMTString()};`\r\n}\r\n\r\n// 쿠키 조회하기\r\nconst getCookie = key => {\r\n  let result = null\r\n  const cookie = document.cookie.split(\";\")\r\n  cookie.some(val => {\r\n    val = val.replace(\" \", \"\")\r\n    const dic = val.split(\"=\")\r\n    if (key === dic[0]) return (result = dic[1])\r\n  })\r\n  return result\r\n}\r\n\r\nsetCookie(\"쿠키생성\", \"여기는 내용\", 1) // 만료일 : 1일\r\ngetCookie(\"쿠키생성\")\r\n```\r\n\r\n## Web Storage vs Cookie\r\n\r\n<table class=\"ph_tbl\">\r\n  <tr>\r\n    <th></th>\r\n    <th>Local Storage</th>\r\n    <th>Session Storage</th>\r\n    <th>Cookie</th>\r\n  </tr>\r\n  <tr>\r\n    <th>저장 위치</th>\r\n    <td>클라이언트에 존재 (서버 전송 X)</td>\r\n    <td>클라이언트에 존재 (서버 전송 X)</td>\r\n    <td>매번 서버로 전송되어 서버에 저장</td>\r\n  </tr>\r\n  <tr>\r\n    <th>데이터 유지 측면</th>\r\n    <td>영구보관</td>\r\n    <td>브라우저 종료시 삭제됨</td>\r\n    <td>반영구 (만료일 설정)</td>\r\n  </tr>\r\n  <tr>\r\n    <th>데이터 범위 측면</th>\r\n    <td>도메인만 같으면 전역적으로 공유 가능</td>\r\n    <td>도메인별로 별도로 생성 (공유 x)</td>\r\n    <td></td>\r\n  </tr>\r\n  <tr>\r\n    <th>지원</th>\r\n    <td>html5 지원 브라우저</td>\r\n    <td>html5 지원 브라우저</td>\r\n    <td>대부분의 브라우저 지원</td>\r\n  </tr>\r\n  <tr>\r\n    <th>용량</th>\r\n    <td>5MB</td>\r\n    <td>5MB</td>\r\n    <td>최대 쿠키 수: 20개, 최대쿠키 크기: 4KB</td>\r\n  </tr>\r\n  <tr>\r\n    <th>추천 상황</th>\r\n    <td>자동 로그인, 다크/라이트 모드</td>\r\n    <td>입력 폼 정보, 비로그인 장바구니, 페이지 이동 시 스크롤 위치 값</td>\r\n    <td>팝업 창</td>\r\n  </tr>\r\n</table>\r\n"},{"excerpt":"기본 명령어 브랜치 생성하여 작업하고 공통 브랜치에서 변경사항 다운받기 좋은 커밋 메시지를 작성하는 7가지 규칙 주제와 본문을 빈줄로 분리하기 주제는 50자로 제한하기 주제의 첫 글자는 대문자로 쓰기 주제에 마침표를 넣지 않기 주제는 명령으로 작성하기 본문은 72자에 줄바꿈하기 how 보단 what과 why를 설명하기 커밋 메시지의 구조 subject의 …","fields":{"slug":"/2022-04-25-git-basic/"},"frontmatter":{"date":"April 25, 2022","title":"[git] git 기본 사용법","tags":["git"]},"rawMarkdownBody":"\r\n## 기본 명령어\r\n\r\n```bash\r\n\r\n# git 저장소 생성 (.git 디렉토리 생성)\r\ngit init\r\n\r\n# repo_url의 저장소를 원격 저장소로 설정\r\ngit remote add origin [repo_url]\r\n\r\n# git repository 로컬에 내려받기\r\ngit clone [repo_url]\r\n\r\n# repository 상태 표시\r\ngit status\r\n\r\n# 스테이지에 선택적 파일 추가 (index.html만 올리기)\r\ngit add index.html\r\n\r\n# 스테이지에 전체 파일 추가\r\ngit add *\r\ngit add .\r\ngit add -A\r\n\r\n# git add + git commit 동시에\r\ngit commit -am \"commit_message\"\r\n\r\n# 스테이지 영역의 파일을 repository 변경사항에 반영\r\n# -m : message\r\ngit commit -m \"commit_message\"\r\n\r\n# 커밋 메시지 여러줄 작성\r\ngit commit -m \"message 1\r\nmessage 2\r\nmessage 3\r\n...\r\nmessage last\"\r\n\r\n# 마지막 커밋 메시지 수정\r\ngit commit --amend -m \"edit commit_message\"\r\n\r\n# branch 목록보기\r\ngit branch\r\n\r\n# 새로운 branch 생성하기\r\ngit branch [branch]\r\n\r\n# 선택한 branch로 변경하기\r\ngit checkout [branch]\r\n\r\n# 새로운 branch 생성후 전환하기\r\ngit checkout -b [branch]\r\n\r\n# 원격 저장소의 branch를 새로 만든 branch로 체크아웃\r\ngit checkout -b [branch] origin/[branch]\r\n\r\n# 선택한 branch 삭제하기\r\ngit branch -d [branch]\r\n\r\n# 로컬 branch와 원격 branch 모두 표시\r\ngit branch -a\r\n\r\n# 현재 브랜치에 push\r\ngit push\r\n\r\n# 원격 저장소의 master 브랜치에 push\r\ngit push origin master\r\n\r\n# git push의 기본값을 origin의 master 브랜치로 지정\r\n# -u : upstream (업스트림을 설정하여 저장소를 중앙 저장소로 연결하기 위함)\r\ngit push -u origin master\r\n\r\n# 현재 브랜치의 변경사항을 로컬에 업데이트\r\ngit pull\r\n\r\n# origin remote의 변경사항을 로컬에 업데이트\r\ngit pull origin master\r\n\r\n# Log 보기\r\ngit log\r\n\r\n# 커밋에서 Log 및 변경된 내용 확인\r\ngit log -p\r\n\r\n# 브랜치를 그래프로 확인\r\ngit log --graph\r\n\r\n# 가장 최근에 수행한 작업부터 repository에서 진행된 모든 로그 볼 수 있음\r\ngit reflog\r\n\r\n# 현재 브랜치의 마지막 커밋과 차이점 비교\r\ngit diff\r\n\r\n# 최신 commit과의 차이점 비교\r\n# HEAD : 현재 브랜치에서 가장 최신의 커밋을 나타내는 키워드\r\ngit diff HEAD\r\n\r\n# 특정 커밋과 특정 파일의 차이점 비교\r\ngit diff [commit_ID] -- [파일 경로]\r\n\r\n# 현재 브랜치와 다른 branch로부터 변경사항 합치기\r\ngit merge [branch]\r\n\r\n# 현재 브랜치에서 [branch]브랜치를 합침\r\ngit merge --no--ff [branch]\r\n\r\n# 이전의 커밋 해시버전으로 복원\r\n# --hard : 돌아가려는 이력이후의 모든 내용 및 이력을 삭제\r\n# --soft : 돌아가려 했던 이력으로 돌아가지만, 이후의 변경 이력은 모두 삭제되지만 내용이 지워지지 않고 인덱스 or 스테이지는 남아있음\r\n# --mixed : 돌아가려 했던 이력으로 돌아가고 이후의 변경 이력은 모두 삭제되지만 변경 내용은 지워지지 않는다. 인덱스는 초기화됨\r\ngit reset 옵션 [commig_hash]\r\n\r\n# 지정한 커밋 해시버전을 최상단 커밋으로 올리면서 돌아가기 (revert 히스토리가 남음)\r\n# reset과 다른점은 커밋을 삭제하는 것이 아닌 커밋을 추가함\r\ngit revert [commig_hash]\r\n\r\n# 작업도중 다른 branch로 체크아웃을 해야 하는데 커밋할 수 없을때 임시로 branch의 작업내용을 보존하기 위해 사용\r\ngit stash\r\n\r\n# 임시 작업내용 복원\r\ngit stash apply\r\n```\r\n\r\n## 브랜치 생성하여 작업하고 공통 브랜치에서 변경사항 다운받기\r\n\r\n```bash\r\n# 공통 브랜치 : main 일때\r\n\r\n# 새로운 branch 생성하고 체크아웃\r\ngit checkout -b [branch]\r\ngit status\r\n\r\n# 새로운 branch에 변경사항 commit하기\r\ngit add .\r\ngit commit -m \"commit_message\"\r\ngit push origin [branch]\r\n\r\n# main branch로 이동하여 내 branch의 변경사항을 main에 병합하기\r\ngit checkout main\r\ngit pull\r\ngit merge [branch]\r\n\r\n# 내 branch로 이동하여 수정사항 commit하기\r\ngit checkout [branch]\r\ngit add .\r\ngit commit -m \"commit_message\"\r\n\r\n# 원격 저장소의 main branch에 push하기\r\ngit push -u origin main\r\n#이후\r\ngit push 가능\r\n```\r\n\r\n## 좋은 커밋 메시지를 작성하는 7가지 규칙\r\n\r\n1. 주제와 본문을 빈줄로 분리하기\r\n2. 주제는 50자로 제한하기\r\n3. 주제의 첫 글자는 대문자로 쓰기\r\n4. 주제에 마침표를 넣지 않기\r\n5. 주제는 명령으로 작성하기\r\n6. 본문은 72자에 줄바꿈하기\r\n7. how 보단 what과 why를 설명하기\r\n\r\n## 커밋 메시지의 구조\r\n\r\n```bash\r\n$ <type>: <subject>   -- 헤더 (주제)\r\n<blank>                        -- 빈줄\r\n<body>                         -- 본문(생략 가능)\r\n<blank>                        -- 빈줄\r\n<footer>                       -- 바닥글/꼬리말\r\n```\r\n\r\n## subject의 type은 커밋의 성격을 나타낸다.\r\n\r\n<table class=\"ph_tbl\">\r\n   <thead>\r\n    <tr>\r\n        <th>type명</th>\r\n        <th>설명</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n        <td>feat</td>\r\n        <td>새로운 기능</td>\r\n    </tr>\r\n    <tr>\r\n        <td>fix</td>\r\n        <td>버그 수정</td>\r\n    </tr>\r\n    <tr>\r\n        <td>docs</td>\r\n        <td>문서 수정</td>\r\n    </tr>\r\n    <tr>\r\n        <td>style</td>\r\n        <td>코드 포맷 변경, 세미 콜론 누락, 코드 수정이 없는 경우</td>\r\n    </tr>\r\n    <tr>\r\n        <td>design</td>\r\n        <td>css 등 사용자 UI 디자인 변경</td>\r\n    </tr>\r\n    <tr>\r\n        <td>test</td>\r\n        <td>테스트 코드, 리펙토링 테스트 코드 추가</td>\r\n    </tr>\r\n    <tr>\r\n        <td>refactor</td>\r\n        <td>프로덕션 코드 리펙토링</td>\r\n    </tr>\r\n    <tr>\r\n        <td>build</td>\r\n        <td>빌드 관련 파일 수정사항</td>\r\n    </tr>\r\n    <tr>\r\n        <td>chore</td>\r\n        <td>빌드 테스트 업데이트, 패키지 매니저를 설정하는 경우</td>\r\n    </tr>\r\n    <tr>\r\n        <td>ci</td>\r\n        <td>CI관련 설정 수정</td>\r\n    </tr>\r\n    <tr>\r\n        <td>rename</td>\r\n        <td>파일/ 폴더명을 수정하거나 옮기기만 하는 경우</td>\r\n    </tr>\r\n    <tr>\r\n        <td>remove</td>\r\n        <td>파일을 삭제만 하는 경우</td>\r\n    </tr>\r\n    <tr>\r\n        <td>!BREAKING CHANGE</td>\r\n        <td>커다란 API 변경</td>\r\n    </tr>\r\n    <tr>\r\n        <td>!HOTFIX</td>\r\n        <td>치명적인 버그를 고치는 경우</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n## 바닥글/꼬리말\r\n\r\n- 꼬리말은 \"type: #이슈 번호\" 형식\r\n- 이슈 번호는 쉼표(,)로 구분\r\n\r\n<table>\r\n  <thead>\r\n    <tr>\r\n        <th>type명</th>\r\n        <th>설명</th>\r\n    </tr>\r\n  </thead>\r\n  <tbody>\r\n    <tr>\r\n        <td>Fixes</td>\r\n        <td>이슈 수정중 (미해결)</td>\r\n    </tr>\r\n    <tr>\r\n        <td>Resolves</td>\r\n        <td>이슈 수정완료</td>\r\n    </tr>\r\n    <tr>\r\n        <td>Ref</td>\r\n        <td>참고할 이슈가 있을 때 </td>\r\n    </tr>\r\n    <tr>\r\n        <td>Related to</td>\r\n        <td>해당 커밋에 관련된 이슈번호 (미해결)</td>\r\n    </tr>\r\n  </tbody>\r\n</table>\r\n\r\n<br>\r\n\r\n## 커밋 구조를 적용한 예시\r\n\r\n```js\r\nFeat: \"쪽지알림 On/Off 기능 추가\" (#123)\r\n\r\n쪽지알림을 On/Off 할 수 있도록 기능을 추가함\r\n\r\nResolves : #123, #456\r\nRelated to: #100\r\n```\r\n"},{"excerpt":"2달동안의 구직활동을 마치고, 마침내 신입 프론트엔드 개발자로 합격했다. \n그동안 내가 많은 개발자분들의 블로그를 통해 도움을 받은 것 처럼, 내 글이 프론트엔드 개발자로 취업을 희망하는 신입개발자들에게 도움이 되길 바라는 마음으로 글을 썼다. 1월부터 신입 프론트엔드 개발자로 구직을 시작했다. \n하지만 며칠에 한번씩 한꺼번에 지원했었고, 본격적으로 구직…","fields":{"slug":"/2022-03-09/"},"frontmatter":{"date":"April 14, 2022","title":"[diary] 프론트엔드 신입 면접 준비하기","tags":["diary"]},"rawMarkdownBody":"\n> 2달동안의 구직활동을 마치고, 마침내 신입 프론트엔드 개발자로 합격했다. <br>\n> 그동안 내가 많은 개발자분들의 블로그를 통해 도움을 받은 것 처럼, 내 글이 프론트엔드 개발자로 취업을 희망하는 신입개발자들에게 도움이 되길 바라는 마음으로 글을 썼다.\n\n1월부터 신입 프론트엔드 개발자로 구직을 시작했다. <br>\n하지만 며칠에 한번씩 한꺼번에 지원했었고, 본격적으로 구직을 시작한건 2월 부터다. 나는 36곳을 지원했고 총 13군데를 서류합격했다. (나쁘지 않은 33%정도의 승률) <br>\n2번의 코딩테스트, 3번의 과제 테스트, 4번의 면접(대면, 비대면)을 봐서 2개의 회사에 최종 합격했다. <br><br>\n부끄럽지만 나란 사람이란,<br>\n\n1. 27살에 의류학과 석사 졸업\n2. 국비학원을 다닌 후, 29살에 퍼블리셔로 취업\n3. 에이전시 근무 및 프리랜서로 대략 **4년간의 퍼블리셔 경력** 보유<br>\n   (즉, **비전공자출신에 IT 경력은 있지만 개발직군 경력은 전무한 상황**)\n4. 현재 나이는 30대 중반\n5. 방통대 컴퓨터과학과 3학년으로 편입했으나 휴학중\n6. 5개의 자격증 (정처기, 컴퓨터그래픽스운용기능사, 웹디자인기능사, 컴활 2급, GTQ 1급) <br>\n   정처기는 퍼블리셔로 일하면서 땄고 나머지는 국비학원을 다니면서 독학해서 땄다. <br>\n   (많은 사람들이 자격증은 필요없다고 하지만 정처기는 우대하는 곳도 많기때문에 따면 좋고, 그 외의 것들은 질문을 받았을때 저런 자격증이 있어 할줄 안다로 대답하기도 했다.)\n   <br><br>\n\n## 포트폴리오, 지원 팁\n\n포트폴리오는 노션으로 만들었고 이력서는 pdf로 만들어서 제출했다. <br>\n\n포트폴리오는 개인프로젝트 3개 팀프로젝트 1개를 넣었는데 **팀 프로젝트는 필수라고 생각한다.** 특히 인성관련해서 팀 프로젝트 진행시를 예시로 들면서 설명할 수 있어 유리하다. (나 같은 경우는 okky에서 사이드프로젝트 팀원구하는 글을 보고 신청했다.) <br>\n\n잡코리아, 로켓펀치, 원티드, 사람인, 점핏, 프로그래머스를 통해 지원했고 원티드는 거의 경력위주로 뽑는 것 같아 초기에만 지원했다. 나의 경우 로켓펀치와 잡코리아에서 지원한 곳에 연락이 많이 왔다. <br> 특히 로켓펀치나 프로그래머스 같은 경우는 이력서를 등록해놓고 셀프구직중을 해놓으면 기업에서 면접제의를 받기도 하니까 정성스럽게 준비해놓자 😆 (실제로 여러곳에서 면접 제의를 받았다.)\n<br>\n\n초기에는 여기저기 넣었는데 막상 서류전형에 합격하면 에이전시가 많았다. 에이전시를 비추하는 개발자가 많았기 때문에 면접을 포기한 경우가 발생했다. <br>\n이후에는 잡플로 확인하면서 거른회사도 많았다. 별점 1점대 회사도 많고 4대보험도 안들어주는 회사도 있다더라.. (개인적으로 3점대 이상의 회사를 추천한다.)<br>\n화상면접인데 당일오전까지도 시간을 안알려주고 면접시간 10분전에 들어오라고 한 회사도 있어서 그런 회사는 걸렀다. (사실 그때 머리도 안감도 눈꼽도 안떼고 있었다.) <br>\n\n잡플을 100% 맹신해선 안되지만 어느정도 맞는다고 생각한다. 실제로 잡플후기대로 면접에서 매우 좋은 경험을 느낀 회사도 있었다.\n\n![지원회사](img/job-notion.jpg)\n\n## 면접 질문\n\n나는 퍼블리셔로 4년을 일했고, 에이전시 특성상 많은 클라이언트들을 만나기도 했다. 그래서 퍼블리셔 경력질문도 많았고 협업에 대한 질문이 많았다.\n\n### Frontend\n\n- HTTP란 뭔가요?\n- GET과 POST의 차이는 무엇인가요?\n- REST API란 무엇인가요?\n- 브라우저 렌더링 과정을 설명해주세요. <br>\n  → 설명 후, CSSOM의 작동원리는 뭔가요? (대답못했음)\n- CORS란 뭔가요?\n- 시멘틱 마크업이란 뭔가요?\n- css 박스모델이 뭔가요?\n- CSR과 SSR은 뭔가요? 장점과 단점, 차이점은 뭔가요?\n- SPA는 뭔가요? 단점은?\n- Webpack, Babel, Polyfill 이란 뭔가요? <br>\n  → preset-env가 뭔가요? <br>\n  → 번들 사이즈를 줄이려면 어떻게 하나요? <br>\n  → 일반 js파일 5개를 쓸때 파일의 크기가 더 작을때가 있는데 왜 번들은 하는지?\n- prettier, eslint를 사용해 봤나요?\n- Package Manager는 어떤 걸 사용하나요?\n- 프론트엔드 개발자에게 중요한점은 무엇인가요? <br>\n  → 협업능력은 꼭 말해야한다. <s>(디자이너-백엔드 사이에서 치이니까)</s> <br>\n  → 혼자 일하는게 아니기 때문에 협업능력을 최우선하는 회사가 많다.\n- 코딩을 하면서 에러를 만난다면 어떻게 해결하나요? 힘들었던 점은?\n- 오픈소스에 기여해보신적이 있나요? <br>\n  → 퍼블리셔였으니까 css같은 거라도..\n\n### Javascript\n\n- 클로저란 뭔가요?\n- 프로토타입 체인이란 뭔가요?\n- 호이스팅이란 뭔가요?\n- 실행컨텍스트란 뭔가요?\n- 비동기와 동기란 뭔가요? 둘의 차이점은?\n- 콜백 vs Promise vs async await란? <br>\n  → Promise의 3가지 상태는 뭔가요? <br>\n  → await 키워드는 무엇을 의미하나요?\n- 화살표 함수란 뭔가요?\n- use strict이 뭔가요? 왜 사용하나요?\n- 자바스크립트가 불안전한 언어라고 하셨는데 왜 그런가요? <br>\n  → 내가 설명을 하면서 이렇게 말했더니 나온 질문이다. <br> 나는 var가 재할당/재언선 되거나 컴파일 단계에서 오류를 뿜어내지 않는 등의 이유로 설명을 드렸고 납득하신 것 같았다.\n- 타입스크립트를 사용해봤나요? <br>\n  → 나는 공부를 시작한지 얼마되지 않았다고 대답하니 별다른 질문은 없었고 인강으로 공부중이라고 말씀드리니 인강은 몇시간정도냐고 물어보셨다. 😅\n\n### React\n\n- 리액트를 공부한 이유는 뭔가요?\n- 리액트에서 상태가 변경될때가 2가지 있는데 어떤 상황에서 변경되나요?\n- useMemo와 useCallback에 대해 아나요? <br>\n  → 메모제이션은 무엇인가요?\n- React.memo란 무엇이고 사용해보셨나요?\n- 리액트 동시성을 사용해보셨나요? (동시성 관련되서 말씀하셨는데 이 질문은 이해를 잘 못했다.)\n- 리액트에서 어떻게 성능최적화를 하나요? 해보셨나요?\n- hook이란 무엇인가요?\n- 커스텀훅을 사용해 봤나요?\n- HOC란?\n- useEffect란 무엇인가요?\n- useRef의 기능은 무엇인가요?\n- Redux란 무엇인가요? 사용한 이유와 단점은 무엇인가요?<br>\n  → 왜 리덕스를 사용했나요? <br>\n  → Redux-saga의 메서드 관련 질문 <br>\n  → Redux-persist 쓴 이유 <br>\n  → MobX나 Recoil등을 사용해 본적이 있나요? <br>\n- Styled-components 관련 질문\n\n### 인성 및 그외\n\n- 자기소개를 해주세요. (무조건 준비)\n- 저희 회사에 지원한 동기가 뭔가요? <br>\n  → 다른 회사도 많은데 우리회사를 지원한 동기는? <br>\n  → 나같은 경우는 해당 회사의 소개 페이지에서 인상깊었던 부분을 말씀드렸더니 그게 우리 회사가 추구하는 방식이라고 매우 좋아하셨다. **지원회사에 대한 조사는 정말정말 필수다.** 회사 관련되서 이런걸 봤고 이래서 지원했다 이러시면 좋아하신다.\n- 본인의 장점과 단점은 뭔가요? <br>\n  → 나의 단점은 성격이 급해져서 사소한 실수를 했던적이 있다고 했다. (실서비스에서 문제가 된적은 없다.) <br>\n  → 그럼 자신의 단점을 어떻게 극복할건가요? 라는 질문이 따라왔다. (난 나의 단점을 솔직하게 말씀드렸고 단점을 극복하기 위헤 어떻게 노력하는지 말씀드렸다.)\n- 주변에서 본인을 어떤 사람이라고 하나요?\n- 일하면서 중요하게 생각하는게 무엇인가요?\n- 일하고 싶지 않은 동료는 어떤 스타일인가요?\n- 동료와 의견이 충돌했을때 어떻게 해결하나요?<br>\n  → 팀 프로젝트 시 어려웠던 적이 있나요?\n- 프로젝트에서 어떤 업무를 당담하셨나요?\n- 본인은 리더형인가요 팔로워형인가요?\n- 패디과에서 퍼블리셔가 된 이유가 뭔가요? 퍼블리셔에서 개발자가 되려는 이유는? <br>\n  → 아마 나처럼 비전공자 출신들은 한번쯤은 물어볼만한 질문이다.\n- 자신의 가치관은 무엇인가요?\n- 애자일 방법으로 개발을 해보셨나요?\n- 자신이 만든 서비스를 사용해 본적이 있나요?\n- 입사 후 우리 회사에서 어떤 개발자가 되고 싶나요?\n- 자신은 10년후에 어떤 사람(개발자)가 되고 싶나요?\n- 프론트엔드 공부는 어떤식으로 하나요?\n- 현재 무엇을 공부하고 있나요?\n- 우리 회사 서비스에서 어떤 부분이 기억에 남나요? <br>\n  → 또는 아쉬운 부분이 있나요?\n- 새로운 기능을 개발한다고 했을 때 어떤 걸 개발하고 싶나요?<br>\n  → 또는 개발했던 것 중 기억에 남는 기능은?\n- 버전관리 시스템은 git을 사용해 보셨고.. <br>\n  → 나의 깃 주소를 보내드렸기 때문에 면접관님의 독백이 되버린 질문 ㅎㅎ\n- 퍼블리셔로 재직했을 때 프로젝트는 현재도 서비스되고 있나요?\n- UI/UX에 관심이 많은 것 같은데 우리 회사는 기능 위주이기 때문에 디자인적으로 크게 꾸미거나 그런게 없는데 어떻게 하실건가요? <br>\n  → 아마 내가 패디과를 졸업하고 퍼블을 했었고 포폴 프로젝트를 엄청 꾸며서 나온 질문같다. <br>\n  → 그 안에서의 최대한의 멋부림을 부린다고 말씀드렸다. (면접관님이 애니메이션 중요하죠라며 웃으셨다.)\n- SQL과 NoSQL의 차이점은 뭔가요? <br>\n  → 내 포트폴리오 중 한개가 mongoDB를 썼기때문에 나온 질문이다.\n- SQL을 공부한적이 있나요? <br>\n  → 정처기 공부할 때 조금해봤다고 말씀드렸다.\n- 디자인툴 (포토샵 등)을 사용할 줄 아시나요? <br>\n  → GTQ 자격증이 있어 포토샵, 일러스트레이터를 다룰 수 있다고 말씀드렸다.\n- 회사에 궁금한점은?\n\n이 외에도 신입으로써 대답하기 힘든 deep 질문도 많았고 거의 대답을 못했지만 예상하신 듯 했다.\n\n## 면접 TIP\n\n1. **꼭 면접말하기 연습을 하고 갔으면 좋겠다.** <br>\n   읽고 외우기만 하는것과 아는 내용을 말로 설명하는 건 천지차이다. 물론 이해를 해야 설명할 수 있기때문에 이해는 필수다. <br>\n2. 솔직히 신입의 기술면접은 거기서 거기다. **관건은 인성면접이다.** <br>\n   어떤 질문이 나올지도 모르고 기업이 추구하는 정확한 인재형을 파악해야하기 때문이다.\n   (그렇다고, 기술면접 소홀히 준비하면 광탈이다. 기술은 기본적으로 깔고 인성도 되야 뽑힐확률이 높다. 기술면접은 꼭 말하기 연습을 해야한다.)\n3. **나란사람이 추구하는 키워드를 결정한다.** <br>\n   내가 정한 나의 키워드는 '협업능력 및 소통'이다. 인성면접에서 퍼블리셔 경험을 풀어서 얘기하기도 하고 키워드를 중심으로 강조했고 대부분의 기업에서 좋게 봐주셨다.\n4. **스타트업은 자기일만 하는 사람을 좋아하지 않는다.** (지극히 개인적인 생각)<br>\n   대기업은 정해진 자기일만 열심히 하면 되지만 스타트업은 그렇지 않다. 다른 사람이 잘되야 나도 잘되고 그래야 기업이 커진다. <br>\n   요즘에는 워라벨이 잘 되어있는 회사도 많지만 그렇지 않는 회사도 여전히 존재한다.<br>\n   스타트업의 그런 특성을 잘 파악하고 지원을 해야 지원자도 면접자도 시간낭비하는 일을 줄일 수 있다. <br>\n5. **면접 분위기가 좋으려면 면접준비를 절대 소홀히 하지 마라.** <br>\n   처음 본 면접은 부끄럽지만 준비가 덜 되어 있었고 서류 합격한 회사의 인원이 4명정도인걸 알게 되어 면접을 포기할까 고민했었다. 그래도 화상면접이고 경험도 할겸 면접을 봤는데 확실히 회사에 대한 간절함이 떨어져서였을까 준비가 많이 부족했었다. 면접 분위기가 나쁘진 않았지만 화기애애할 정도는 아니었다. <br>\n   이후 면접 본 회사들은 합격하길 간절하게 원했기 때문에 열심히 준비를 했고 면접시간동안 분위기가 나쁘지 않았다. <br>\n   회사에 대한 나의 관심도도 높아 자료조사도 철저히 하고 기술면접 준비도 열심히 했기 때문이다.\n"},{"excerpt":"최근 면접을 보면서 나의 코딩 스타일에 대해 생각하게 되었다. \n나는 많은 인강을 보면서 react를 독학한 케이스인데 아무래도 인강 강사님의 코드 스타일을 따라가게 되었고 무의식적으로 그렇게 코딩을 했었다. \n면접관님이 코딩스타일은 다 다르지만 내가 사용한 코딩스타일은 값과 코드를 확인하기 위해 여러군데를 살펴봐야 하기때문에 본인은 선호하는 방식이 아니…","fields":{"slug":"/2022-04-05-react/"},"frontmatter":{"date":"April 05, 2022","title":"[react] react 코딩 컨벤션","tags":["react"]},"rawMarkdownBody":"\n최근 면접을 보면서 나의 코딩 스타일에 대해 생각하게 되었다. <br>\n나는 많은 인강을 보면서 react를 독학한 케이스인데 아무래도 인강 강사님의 코드 스타일을 따라가게 되었고 무의식적으로 그렇게 코딩을 했었다. <br>\n면접관님이 코딩스타일은 다 다르지만 내가 사용한 코딩스타일은 값과 코드를 확인하기 위해 여러군데를 살펴봐야 하기때문에 본인은 선호하는 방식이 아니라고 하셨다. (솔직히 생각해본적이 없어서 충격 😱) <br>\n\n신규 서비스를 개발하는 경우도 있지만 대부분의 개발은 기존코드를 유지보수 하는 경우가 많다. 이전 개발자가 코딩했던 스타일이 지극히 개인적이라면 어떻겠는가? 또는 동료 개발자가 내 스타일데로 코딩한 코드를 이해하지 못한다면? 개발자들은 자신이 코딩했던 코드도 까먹는 경우가 꽤 많다. 저 당시에 내가 왜 저렇게 코딩 했지?하는 경우를 많이 봤기 때문에 더더욱 개발자들 사이의 규칙이 중요한 것 같다. <br>\n현업에서 혼자 개발하는 개발자는 드물다. 그렇기 때문에 협업을 위한 코딩 스타일 규칙은 중요하다는 생각이 들었다.\n\n## 코딩 컨벤션이란?\n\n코딩 컨벤션은 협업 시 유지보수 및 가독성, 코드 이해를 위해 지켜지는 개발자들 사이의 규칙이다.\n효율적이고 관리하기 쉬운 코드를 만들기 위해(유지보수) 효율적으로 규칙을 정해야 한다.\n\n**\\*사용하는 이유?**\n\n1. **의미있는 코드** : 웹표준과 접근성, 크로스 브라우징 등에 맞춘 의미있는 코드\n2. **유지보수가 용이한 코드** : 시간과 비용 절약을 위해 타인이 봤을때도 금방 이해하고 수정하기 쉽게끔 작성\n3. **일관된 코드** : 모든 개발자가 각자의 규칙을 가지고 있기때문에 하나의 규칙을 정해 일관된 코드로 작성\n\n## react 코딩컨벤션\n\n### 1. NAMING CONVENTIONS\n\n1. components 이름은 `Pascal case`로 작성해라. <br>\n   pascal case : 첫 단어를 대문자로 시작하는 표기법\n   ```html\n   Header.js Footer.jsx MainBanner.js BlogList.jsx\n   ```\n2. Non-components 이름은 `Camel case`로 작성해라. <br>\n   Camel case : 띄어쓰기 대신 대문자로 단어를 구분하는 표기 방식\n   ```html\n   myUtilityFile.js cookieHelper.js fetchApi.js\n   ```\n3. Unit test 파일명은 대상 파일명과 동일하게 작성해라. <br>\n\n   ```html\n   MainBanner.js MainBanner.test.js BlogList.js BlogList.test.js\n   ```\n\n4. 속성명은 `Camel case`로 작성해라. <br>\n\n   ```html\n   className\n   <div className=\"\"></div>\n\n   onClick, onSubmit\n   <div onClick=\"{}\" onSubmit=\"{}\"></div>\n   ```\n\n5. inline 스타일은 `Camel case`로 작성해라.\n   ```js\n   <div style={{ fontSize: \"1rem\", fontWeight: \"700\" }}></div>\n   ```\n\n### 2. BUG AVOIDANCE\n\n1. `null` 또는 `undefined`일 수 있는 값은 optional chaining 연산자 (?.)를 사용한다.\n\n   ```js\n   obj?.prop\n   obj?.[expr]\n   arr?.[index]\n   func?.(args)\n   ```\n\n2. 전달된 매개변수가 유효한지 확인하기 위해 guard pattern/<a href=\"https://www.jondjones.com/frontend/react/react-tutorials/how-to-config-typescript-within-a-react-app/\" target=\"_blank\">prop types</a>/<a href=\"https://www.jondjones.com/frontend/react/react-tutorials/how-to-config-typescript-within-a-react-app/\" target=\"_blank\">typescript</a>를 사용한다. <br>\n3. side-effects를 피하기 위해 외부 데이터를 props로 받아서 사용한다.\n4. console.log()를 모두 지운다.\n5. props는 읽기 전용으로 사용하며, 직접 수정하지 않는다.\n\n### 3. ARCHITECTURE & CLEAN CODE\n\n1. 유틸리티 파일을 만들어 중복된 코드를 피한다.\n2. Presentational 컴포넌트와 Container 컴포넌트를 분리하여 사용한다. <a href=\"https://jeffgukang.github.io/react-native-tutorial/docs/state-tutorial/redux-tutorial/04-container-and-presentational/container-and-presentational-kr.html\" target=\"_blank\">Container 컴포넌트와 Presentational 컴포넌트</a>\n3. 고차 컴포넌트(Higher Order Components, HOC)는 적절하게 사용한다.\n4. JS, test, css로 파일을 분리한다.\n5. 반복되어 import되는 이름을 줄이기 위해 각 폴더에 index.js 파일을 만든다.\n\n```js\nimport { Nav } from \"./Nav.js\"\nimport { CookieBanner } from \"./CookieBanner.js\"\n\nexport { Nav, CookieBanner }\n```\n\n6. 하나의 파일에 하나의 React component만 만든다.\n7. 가능하다면 컴포넌트 안에서 함수를 생성하지 않는다.\n8. 부모 컴포넌트가 아닌 다른 컴포넌트의 함수를 사용하지 않는다. (의존성 역전을 피한다.)\n9. 불필요한 주석을 사용하지 않는다.\n10. 현재 화면보다 긴 코드는 더 작은 단위의 코드로 리팩토링 한다.\n11. 주석 처리된 코드는 커밋하지 말고 삭제한다.\n\n### 4. ES6\n\n1. spread 연산자를 사용한다.\n2. 구조 분해 할당을 사용한다.\n3. let과 const만 사용한다. (var 사용금지)\n4. 되도록 화살표 함수를 사용한다.\n5. 직접 null을 체크하기 보다 optional chaining 연산자 (?.)를 사용한다.\n\n### 5. TESTING\n\n1. 테스트를 작성한다.\n2. 적정 수준의 테스트 커버리지를 유지한다.\n3. 하나의 테스트 파일에서 하나만 테스트 한다.\n4. 테스트 코드안에서 로직을 사용하지 않는다.\n5. 테스트 클래슽는 하나의 클래스만 테스트 한다.\n6. 네트워크, 데이터 베이스와 직접 통신하지말고 가짜 함수를 사용한다.\n\n### 6. CSS\n\n1. inline css를 사용하지 않는다.\n2. 명명 규칙을 지킨다. (네이밍 컨벤션 - bem, SUIT 등)\n\n<small class=\"from add\">참고 : <a href=\"https://www.jondjones.com/frontend/react/react-tutorials/react-coding-standards-and-practices-to-level-up-your-code/\" tearget=\"_blank\">https://www.jondjones.com/frontend/react/react-tutorials/react-coding-standards-and-practices-to-level-up-your-code/</a><br>\n<a href=\"https://3-stack.tistory.com/53\" tearget=\"_blank\">https://3-stack.tistory.com/53</a>\n</small>\n"},{"excerpt":"내 블로그에서 가장 조회수가 높은 포스팅은 react 모달 포스팅이다. ([react] 모달 팝업창 만들기) \n전에 만들었던 Modal은 트랜지션이 적용되지 않았었다. 최근 프로젝트를 만들면서 트랜지션이 적용된 Modal을 만들어야 했었기에 트랜지션이 적용된 react Modal을 만들어 보기로 했다. \n(* Modal은 이전에 만들었던 코드에 트랜지션을…","fields":{"slug":"/2022-03-03-react-modal/"},"frontmatter":{"date":"March 03, 2022","title":"[react] transition이 적용된 Modal 만들기","tags":["react"]},"rawMarkdownBody":"\n<div style=\"text-align: left;\">\n\n![애널리틱스](img/2022-03-03-modal1.jpg)\n\n</div>\n\n내 블로그에서 가장 조회수가 높은 포스팅은 react 모달 포스팅이다. (<a href=\"https://phrygia.github.io/react/2021-09-21-react-modal/\" target=\"_blank\">[react] 모달 팝업창 만들기</a>) <br>\n전에 만들었던 Modal은 트랜지션이 적용되지 않았었다. 최근 프로젝트를 만들면서 트랜지션이 적용된 Modal을 만들어야 했었기에 트랜지션이 적용된 react Modal을 만들어 보기로 했다. <br>\n(\\* Modal은 이전에 만들었던 코드에 트랜지션을 추가 적용한다.)\n\n## 트랜지션이 적용된 Modal 컴포넌트 (함수형)\n\n<small class=\"from\">-완성된 모습-</small>\n\n![트랜지션 모달](img/2022-03-03-modal2.gif)\n\n**\\*파일구조** <br>\n\n![img/modal-1.jpg](img/modal-1.jpg)\n\n**- CSS**\n\n```css\n.modal {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 99;\n  background-color: rgba(0, 0, 0, 0.6);\n  animation: fadeOut 0.25s ease-out forwards;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.modal button {\n  outline: none;\n  cursor: pointer;\n  border: 0;\n}\n.modal.open {\n  animation-name: fadeIn;\n}\n.modal.open > section {\n  animation-name: slideUp;\n}\n.modal > section {\n  width: 90%;\n  max-width: 450px;\n  margin: 0 auto;\n  border-radius: 0.3rem;\n  background-color: #fff;\n  overflow: hidden;\n  animation: slideDown 0.25s ease-out forwards;\n}\n.modal > section > header {\n  position: relative;\n  padding: 16px 64px 16px 16px;\n  background-color: #f1f1f1;\n  font-weight: 700;\n}\n.modal > section > header button {\n  position: absolute;\n  top: 15px;\n  right: 15px;\n  width: 30px;\n  font-size: 21px;\n  font-weight: 700;\n  text-align: center;\n  color: #999;\n  background-color: transparent;\n}\n.modal > section > main {\n  padding: 16px;\n  border-bottom: 1px solid #dee2e6;\n  border-top: 1px solid #dee2e6;\n}\n.modal > section > footer {\n  padding: 12px 16px;\n  text-align: right;\n}\n.modal > section > footer button {\n  padding: 6px 12px;\n  color: #fff;\n  background-color: #6c757d;\n  border-radius: 5px;\n  font-size: 13px;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n@keyframes slideUp {\n  from {\n    transform: translateY(-100px);\n  }\n  to {\n    transform: translateY(0px);\n  }\n}\n@keyframes slideDown {\n  from {\n    transform: translateY(0px);\n  }\n  to {\n    transform: translateY(-100px);\n  }\n}\n```\n\n**- Modal.js**\n\n```js\nimport React, { useState, useEffect } from \"react\"\n\nconst Modal = props => {\n  // 열기, 닫기, 모달 헤더 텍스트를 부모로부터 받아옴\n  const { open, close, header } = props\n\n  // 현재 트랜지션 효과를 보여주고 있는 중이라는 상태 값\n  const [animate, setAnimate] = useState(false)\n  // 실제 컴포넌트가 사라지는 시점을 지연시키기 위한 값\n  const [visible, setVisible] = useState(open)\n\n  useEffect(() => {\n    setVisible(open)\n\n    // open 값이 true -> false 가 되는 것을 감지 (즉, 모달창을 닫을 때)\n    if (visible && !open) {\n      setAnimate(true)\n      setTimeout(() => setAnimate(false), 200)\n    }\n    return () => {\n      setVisible(false)\n    }\n  }, [visible, open])\n\n  if (!animate && !visible) return null\n\n  return (\n    // 모달의 open close클래스로 css animation을 구현\n    <div className={open ? \"modal open\" : \"modal\"}>\n      <section>\n        <header>\n          {header}\n          <button className=\"close\" onClick={close}>\n            &times;\n          </button>\n        </header>\n        <main>{props.children}</main>\n        <footer>\n          <button className=\"close\" onClick={close}>\n            close\n          </button>\n        </footer>\n      </section>\n    </div>\n  )\n}\n\nexport default Modal\n```\n\n**- App.js**\n\n```js\nimport React, { useState, useEffect } from \"react\"\n\nconst App = () => {\n  // useState를 사용하여 open상태를 변경한다. (open일때 true로 만들어 열리는 방식)\n  const [modalOpen, setModalOpen] = useState(false)\n\n  const openModal = () => {\n    setModalOpen(true)\n  }\n  const closeModal = () => {\n    setModalOpen(false)\n  }\n\n  return (\n    <React.Fragment>\n      <button onClick={openModal}>모달팝업</button>\n      <Modal open={modalOpen} close={closeModal} header=\"Modal heading\">\n        함수형 모달 팝업창입니다. 쉽게 만들 수 있어요. 같이 만들어봐요!\n      </Modal>\n    </React.Fragment>\n  )\n}\n\nexport default App\n```\n\n이전코드와 달라진점은 animate, visible 상태값을 추가하고 모달창을 열때와 닫을때의 상태를 체크하여 그에 맞는 css animation 값을 준다는 것이다. 특히, 모달창을 닫을때의 상태를 체크해서 setTimeout으로 애니메이션을 보여준다음 모달창을 사라지게 해야한다는 것이다.\n"},{"excerpt":"최근 구직활동을 시작하면서 사전과제를 받게 되었다. \n나의 포지션은 프론트엔드 개발자로 react 라이브러리를 사용하고 있기때문에 react로 자사 사이트 클론 코딩하고 api 요청에 대한 응답결과를 구현하는 과제였다. \n포트폴리오를 만들었을때는 CRA를 사용해서 리액트 프로젝트를 만들었었다. create-react-app 한줄만 입력하면 손쉽게 리액트 …","fields":{"slug":"/2022-02-18-react/"},"frontmatter":{"date":"February 18, 2022","title":"[react] CRA없이 React환경 구축하기 (웹팩, 바벨)","tags":["react"]},"rawMarkdownBody":"\n최근 구직활동을 시작하면서 사전과제를 받게 되었다. <br>\n나의 포지션은 프론트엔드 개발자로 react 라이브러리를 사용하고 있기때문에 react로 자사 사이트 클론 코딩하고 api 요청에 대한 응답결과를 구현하는 과제였다. <br>\n포트폴리오를 만들었을때는 CRA를 사용해서 리액트 프로젝트를 만들었었다. create-react-app 한줄만 입력하면 손쉽게 리액트 프로젝트를 만들 수 있었기 때문이다.<br>\n\n생각해보니 프론트엔드 자격요건이나 우대사항에 webpack & babel에 대한 이해나 지식을 요구하는 경우를 종종 보았는데 직접 설정해서 사용해본적은 인강으로 react를 배웠을때 정도였던 것 같다. 문득 **직접 프로젝트를 설정할 수 있지만 CRA를 사용하는 것과 모르고 사용하는 것의 차이는 매우 크다**는 생각이 들었다.<br>\n\n그래서 마침 사전과제도 요청받았겠다 과제도 하고 내 공부도 할 겸 (꿩먹고 알먹고😋) CRA없이 react 프로젝트를 만들고 프로젝트 환경을 설정해 보기로 했다.\n\n## 웹팩과 바벨\n\n설정을 시작하기 전에 바벨과 웹팩에 대해 간단하게 알아보자.\n\n### 웹팩\n\n![웹팩](img/2022-02-18-react.jpg)\n\n<div class=\"blockquote\">\n    웹팩은 자바스크립트 애플리케이션을 위해 여러개의 파일을 하나로 <b>묶어주는</b> 모듈 번들러이다.\n</div>\n\n웹팩은 여러 파일을 하나의 파일로 합치는 역할을 하며, 각 모듈간의 의존성을 분석하여 그룹화시켜준다. <br>\n(모듈을 하나의 파일이라고 생각하고 각 파일들을 하나로 합쳐준다고 생각하면 쉽다.)\n프로젝트에 사용되는 많은 라이브러리들을 빌드과정을 통해 html이 실행할 수 있는 하나의 파일로 합쳐준다.<br>\njs, jsx뿐만 아니라 css, 폰트, 이미지 등 다양한 파일을 번들링 할 수 있다.<br><br>\n\n**\\*웹팩이 필요한 이유**\n\n1. 파일 단위의 자바스크립트 모듈 관리의 필요성 : 전역변수 오염 방지\n2. 웹 개발 작업 자동화 도구 : 적용 → 새로고침의 문제 해결, 용량이 큰 파일 자동 압축 등\n3. 웹 애플리케이션의 빠른 로딩 속도와 높은 성능 → 로딩속도를 높여 사용자 이탈 방지 등\n\n### 바벨\n\n<div style=\"display:inline-block\">\n\n<img src=\"https://d33wubrfki0l68.cloudfront.net/7a197cfe44548cc1a3f581152af70a3051e11671/78df8/img/babel.svg\" style=\"max-width: 500px; width: 100%;\">\n\n</div>\n\n<div class=\"blockquote\">\n    바벨은 ES6+ 버전 이상의 자바스크립트 코드를 하위 버전의 자바스크립트 문법으로 <b>변환</b> 시켜준다. \n</div>\n\n바벨 웹사이트를 방문하면 `Babel is a Javascript compiler`이란 문구가 보인다. <br>\n문구 그대로 바벨은 자바스크립트 컴파일러다. 자바스크립트의 특정 문법, 타입스크립트, JSX 등의 문법은 웹 브라우저에서 지원하지 않는 경우가 많은데 호환 가능한 ES5이하의 문법으로 변환 해준다.\n\n**\\*바벨이 필요한 이유**\n\n1. 크로스 브라우징 (호환성) : 오래된 브라우저 유저들을 고려하고 모든 브라우저에서 동작하기 위해 사용\n2. 개발자를의 편리성: 브라우저의 호환여부를 따지지 않고 최신문법 사용이 자유롭기 때문에 개발의 효율성이 증가\n\n## 개발환경 구축\n\n### 1. package.json 생성 및 react 설치\n\n- react : 리액트 코어 라이브러리\n- react-dom : 리액트와 DOM을 연결\n\n```js\n// package.json 생성\nyarn init -y\n\nyarn add react react-dom\n```\n\n### 2. 바벨설치\n\n- @babel/core : 바벨 코어\n- @babel/preset-react : 리액트의 JSX 코드를 트랜스파일링\n- @babel/cpreset-env : ES6+ 코드를 ES5 코드로 트랜스파일링 (+폴리필 자동화)\n\n```js\nyarn add -D @babel/core @babel/preset-react @babel/preset-env\n```\n\n### 3. 웹팩과 관련 모듈(loader) 설치\n\n- webpack : 웹팩 코어\n- webpack-cli : 터미널의 커맨드라인에서 웹팩 사용\n- webpack-dev-server : 웹팩을 메모리 상으로만 빌드한 결과물을 개발 서버에 구동\n- babel-loader : ES6+, JSX 문법을 트랜스파일링\n- css-loader : CSS 코드를 JS로 변환\n- style-loader : 변환된 css파일을 index.hmtl의 &lt;style&gt;태그에 삽입\n- file-loader : 이미지, 폰트 등의 파일 로딩\n- json-loader : json 파일 로딩\n- dotenv : .env 파일을 환경변수에 대신 설정해줌\n\n```js\n// webpack 설치\nyarn add -D webpack webpack-cli webpack-dev-server\n\n// 관련모듈 설치\nyarn add -D babel-loader css-loader style-loader file-loader\n\n// 나는 프로젝트에서 json을 사용했기 때문에 추가로 설치했다. (선택)\nyarn add -D json-loader\n\n// .env 파일을 사용한다면 설치 (선택)\nyarn add dotenv\n```\n\n<br>\n\n웹팩으로 번들링 한 후의 파일에 적용할 플러그인을 설치한다.\n\n- html-webpack-plugin : html 파일에 번들링된 JS 코드를 삽입하고 dist 폴더에 번들링된 결과물을 옮겨줌\n- clean-webpack-plugin : 번들링을 할 때 마다 이전의 번들링 결과를 제거\n\n```js\nyarn add -D html-webpack-plugin clean-webpack-plugin\n```\n\n### 4. 바벨, 웹팩 설정\n\n프로젝트 루트에 `babel.config.js` 파일을 만들고 프리셋을 설정한다.\n\n```js\n// babel.config.js\nmodule.exports = {\n  presets: [\"@babel/preset-env\", \"@babel/preset-react\"],\n}\n```\n\n프로젝트 루트에 `webpack.config.js` 파일과 `.env`파일을 만든다. <br>\n(웹팩 설정에 따라 프로젝트 결과물이 달라질 수 있으며, 설정 옵션이 많기 때문에 webpack 사이트를 참고하면서 필요한 설정을 하면 된다.)\n\n```js\n//.env\nMODE = \"development\" // development(개발 모드), production(프로덕션 모드)\nPORT = \"3000\"\n```\n\n```js\n// webpack.config.js\nconst webpack = require(\"webpack\")\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\")\nconst { CleanWebpackPlugin } = require(\"clean-webpack-plugin\")\nconst dotenv = require(\"dotenv\").config()\n\nmodule.exports = {\n  mode: process.env.MODE, // 만약 환경변수를 사용하지 않는다면 직접 'development' 입력\n  entry: \"./src/index.js\",\n  output: {\n    // 번들링 결과 : /dist폴더\n    path: __dirname + \"/dist\",\n    // bundle.해쉬.js로 생성\n    filename: \"bundle.[hash].js\",\n    publicPath: \"/\",\n  },\n  resolve: {\n    // 번들링을 할 파일 설정\n    extensions: [\".js\", \".jsx\"],\n  },\n  module: {\n    // loader 설정 - 등록한 로더의 뒤의 요소부터 번들링에 반영\n    // node_modules 제외\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: \"/node_modules/\",\n        loader: \"babel-loader\",\n      },\n      {\n        test: /\\.css$/,\n        use: [{ loader: \"style-loader\" }, { loader: \"css-loader\" }],\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)$/i,\n        loader: \"file-loader\",\n        options: {\n          name: \"assets/[contenthash].[ext]\",\n        },\n      },\n    ],\n  },\n  plugins: [\n    // 빌드 이전 결과물을 제거\n    new CleanWebpackPlugin(),\n    // 번들한 css파일과 js파일을 html 파일에 link 태그, script태그로 추가\n    new HtmlWebpackPlugin({\n      template: \"public/index.html\",\n    }),\n    // 환경 정보를 제공\n    new webpack.DefinePlugin({\n      mode: process.env.MODE,\n      port: process.env.PORT,\n    }),\n  ],\n  devServer: {\n    host: \"localhost\",\n    port: process.env.PORT,\n    open: true,\n    historyApiFallback: true,\n    // hot : 모듈의 변화된 부분만 서버에 자동으로 반영\n    hot: true,\n  },\n}\n```\n\n- start : 개발서버에서 리액트 프로젝트 수행\n- build : dist 폴더에 번들링된 파일 생성\n\n```js\n// package.json\n\"scripts\": {\n  \"start\": \"webpack-dev-server --progress --mode development\",\n  \"build\": \"webpack --progress --mode production\"\n}\n```\n\n### 5. 리액트 컴포넌트 생성\n\n루트에 public 폴더를 만들고 index.html 파일을 만든다. <br>\n\n```html\n<!DOCTYPE html>\n<html lang=\"ko\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=divice-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>title</title>\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n```\n\nsrc 폴더를 생성하고 index.js와 App.js 파일을 만들고 다음과 같이 입력한다.\n\n```js\n// index.js\nimport React from \"react\"\nimport ReactDom from \"react-dom\"\nimport App from \"./App\"\n\n// public/index.html 파일에서 root아이디를 가진 DOM에 랜더\nReactDom.render(<App />, document.getElementById(\"root\"))\n```\n\n```js\n// App.js\nimport React from \"react\"\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <h1>Hello React World!</h1>\n    </div>\n  )\n}\nexport default App\n```\n\n`yarn start`로 프로젝트 실행하면 서버가 실행된다.\n\n![webpack dev 실행](img/2022-02-18-react2.jpg)\n\n`yarn build` 명령어를 실행하면 dist 파일에 번들링 된 결과물인 bundle.js와 index.html이 생성된다.\n\n## 포스팅을 마치며..\n\n처음에는 babel-loader와 css-loader style-loader만 설치해서 설정했었다. 근데 코딩하면서 import로 이미지를 불러오는 것도 json을 불러오는 것도 전부 설정이 필요하다는 것을 알게 되었다. <br>\n그동안 CRA가 한번에 설치해주는게 얼마나 편한지 알게되었고, webpack과 babel이 어렵다는 막연한 두려움을 해소해주는 계기가 되었다. 😉<br>\n(나중에 scss-loader도 웹팩에 추가해서 사용해봐야지...)<br>\n\n⚙ prettier나 es-lint까지 설정하면 개발 효율성이 더욱 높아질 것 같다.\n"},{"excerpt":"scss의 @for를 이용하면 반복적인 구문을 쉽게 처리할 수있다. \n인강에선 @for ~ through로 설명을 했는데 vs코드의 자동완성 코드는 @for ~ to였다. \n어떤 차이점이 있는걸까? @for 기본 사용법  $var : 변수명 \n<start> : 시작하는 숫자와 \n<end> : 끝나는 숫자 for ~ through end로 지장한 숫자까지 …","fields":{"slug":"/2022-02-06-scss-for/"},"frontmatter":{"date":"February 06, 2022","title":"[scss] @for ~ through / to 차이점","tags":["scss"]},"rawMarkdownBody":"\nscss의 @for를 이용하면 반복적인 구문을 쉽게 처리할 수있다. <br>\n인강에선 @for ~ through로 설명을 했는데 vs코드의 자동완성 코드는 @for ~ to였다. <br>\n어떤 차이점이 있는걸까?\n\n## @for 기본 사용법\n\n<div class=\"blockquote\">\n    @for $var from &lt;start&gt; through &lt;end&gt; <br>\n    @for $var from &lt;start&gt; to &lt;end&gt;\n</div>\n\n&nbsp;$var : 변수명 <br>\n&lt;start&gt; : 시작하는 숫자와 <br>\n&lt;end&gt; : 끝나는 숫자\n\n## for ~ through\n\nend로 지장한 숫자까지 반복\n\n<ul class=\"half_tag\">\n<li>\n<b>scss</b>\n\n```css\n@for $i from 1 through 5 {\n  .box:nth-child(#{$i}) {\n    width: 100px * $i;\n  }\n}\n```\n\n</li>\n<li>\n<b>css</b>\n\n```css\n.box:nth-child(1) {\n  width: 100px;\n}\n.box:nth-child(2) {\n  width: 200px;\n}\n.box:nth-child(3) {\n  width: 300px;\n}\n.box:nth-child(4) {\n  width: 400px;\n}\n.box:nth-child(5) {\n  width: 500px;\n}\n```\n\n</li>\n</ul>\n\n## for ~ to\n\nend로 지장한 숫자-1까지 반복\n\n<ul class=\"half_tag\">\n<li>\n<b>scss</b>\n\n```css\n@for $i from 1 to 5 {\n  .box:nth-child(#{$i}) {\n    width: 100px * $i;\n  }\n}\n```\n\n</li>\n<li>\n<b>css</b>\n\n```css\n.box:nth-child(1) {\n  width: 100px;\n}\n.box:nth-child(2) {\n  width: 200px;\n}\n.box:nth-child(3) {\n  width: 300px;\n}\n.box:nth-child(4) {\n  width: 400px;\n}\n```\n\n</li>\n</ul>\n\n솔직히 to가 왜있는지 모르겠다 😅 <br>\nscss가 자바스크립트랑 비슷한 개념이 많다보니까 js for문의 0인덱스에 익숙한 개발자들을 위해서 나온걸까? <br>\n나는 주로 through를 이용해서 코딩하는 습관을 길러야겠다. <br>\n(to / through를 동시다발적으로 사용하면 나중에 리뷰할 때 헷갈릴 것 같다.)\n"},{"excerpt":"react를 배우던 초창기에는 를 일일히 써주면서 코딩했던 기억이 있다. \n사이드 프로젝트에서 styled-components를 사용하고 있는데 저 코드를 일일히 썼을 때 디자이너분이 사이즈의 기준을 바꾸거나 하 코딩한 모든 컴포넌트를 수정해야 한다. \nreact로 여러가지 개인 프로젝트나 팀 프로젝트를 진행해보았기 때문에 저런 하드코딩적인 느낌을 지우고…","fields":{"slug":"/2022-01-27-styled-components/"},"frontmatter":{"date":"January 27, 2022","title":"[react] styled-components 반응형 스타일 설정하기","tags":["react"]},"rawMarkdownBody":"\nreact를 배우던 초창기에는 `@media (min-width: 768px) {} @media (max-width: 767px) {}`를 일일히 써주면서 코딩했던 기억이 있다. <br>\n사이드 프로젝트에서 styled-components를 사용하고 있는데 저 코드를 일일히 썼을 때 디자이너분이 사이즈의 기준을 바꾸거나 하 코딩한 모든 컴포넌트를 수정해야 한다. <br>\nreact로 여러가지 개인 프로젝트나 팀 프로젝트를 진행해보았기 때문에 저런 하드코딩적인 느낌을 지우고 싶었다. <br>\nstyled-components에는 `ThemeProvider`라는 속성을 사용해 공통으로 스타일을 관리해 줄 수 있다고 한다.\n\n## ThemeProvider\n\nContext API를 기반으로 작동하기 때문에 ThemeProvider로 감싸진 모든 하위 컴포넌트들은 전달받은 theme를 props로 사용할 수 있다.<br> \\*특히 color사용에 좋다 → 프로젝트를 진행하면서 메인컬러가 바뀌는 경우가 있는데 모든 컴포넌트를 수정하는건 너무 비효율적이다.\n\n\\/assets/style/theme.js\n\n```js\nconst size = {\n  mobile: \"767px\",\n  desktop: \"768px\",\n}\n\nconst theme = {\n  mainColor: \"#4748C6\",\n  subColor: \"#1B1B1B\",\n  mobile: `(max-width: ${size.mobile})`,\n  desktop: `(min-width: ${size.desktop})`,\n}\n\nexport default theme\n```\n\nApp.js (또는 index.js)\n\n```js\nimport { ThemeProvider } from \"styled-components\"\nimport theme from \"./assets/style/theme\"\n\nconst App = () => {\n  return (\n    <ThemeProvider theme={theme}>\n      <Router />\n    </ThemeProvider>\n  )\n}\n```\n\n## theme 사용하기\n\n#### 1. styled-component에서 사용하기\n\n\\${props => props.theme.속성명}으로 사용\n\n```js\nimport React from \"react\"\nimport styled from \"styled-components\"\n\nconst RegisterContainer = styled.section`\n  @media ${props => props.theme.desktop} {\n    background-color: ${props => props.theme.mainColor};\n  }\n  @media ${props => props.theme.mo} {\n    background-color: ${props => props.theme.subColor};\n  }\n`\n\nconst Register = () => {\n  return <RegisterContainer>...</RegisterContainer>\n}\nexport default Register\n```\n\n#### 2. Component의 props로 사용하기\n\nuseContext와 ThemeContext를 사용해서 theme의 값을 사용하여 컴포넌트의 props style로 전달하기\n\n```js\nimport React, { useContext } from \"react\"\nimport styled, { ThemeContext } from \"styled-components\"\n\nconst RegisterContainer = styled.section`\n  ...\n  background-color: ${props => (props.textColor ? props.textColor : \"#323232\")};\n`\n\nconst Register = () => {\n  const themeContext = useContext(ThemeContext)\n\n  return (\n    <RegisterContainer textColor={themeContext.mainColor}>\n      ...\n    </RegisterContainer>\n  )\n}\nexport default Register\n```\n\n## Global 스타일 설정하기\n\n모든 컴포넌트에서 쓰일 기본 스타일을 정의 할 수 있다.\n\n```js\n// assets/style/GlobalStyle.js\nimport { createGlobalStyle } from \"styled-components\"\n\nconst GlobalStyle = createGlobalStyle`\n  * {\n    margin: 0;\n    padding: 0;  \n    box-sizing: border-box;\n  }\n`\nexport default GlobalStyle\n\n// App.js\nconst App = () => {\n  return (\n    <ThemeProvider theme={theme}>\n      <Router />\n      <GlobalStyle />\n    </ThemeProvider>\n  )\n}\n```\n\ntheme.js 파일안에 공통된 font-size, color등을 설정하면 더욱 활용도가 높아질 것 같다.\n\n<small class=\"from add\">참고 : <a href=\"https://velog.io/@hoi/Styled-components-ThemeProvider를-활용한-스타일-환경-구축\" target=\"_blank\">https://velog.io/@hoi/Styled-components-ThemeProvider를-활용한-스타일-환경-구축</a>\n</small>\n"},{"excerpt":"맥을 사용하면 터미널로 쉽게 접속이 가능하지만 윈도우로는 터미널 만으로는 ec2 서버에 접속할 수 없다. \n(사실 맥을 주로 이용해서 윈도우는 안된다는 걸 몰랐었는데 집에있는 데스크탑으로 접속하려니 안되서 찾아보니 PuTTY를 이용하라 카더라..) 먼저 자신의 window 환경에 맞는 파일을 다운받는다. PuTTY 다운로드  msi 파일을 설치하면 PuT…","fields":{"slug":"/2022-01-02-aws/"},"frontmatter":{"date":"January 02, 2022","title":"[aws] PuTTY로 윈도우에서 aws ec2 ssh 접속하기","tags":["web"]},"rawMarkdownBody":"\n맥을 사용하면 터미널로 쉽게 접속이 가능하지만 윈도우로는 터미널 만으로는 ec2 서버에 접속할 수 없다. <br>\n(사실 맥을 주로 이용해서 윈도우는 안된다는 걸 몰랐었는데 집에있는 데스크탑으로 접속하려니 안되서 찾아보니 PuTTY를 이용하라 카더라..)\n\n먼저 자신의 window 환경에 맞는 파일을 다운받는다. <a href=\"https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html\" target=\"_blan\">PuTTY 다운로드</a>\n\n![PuTTY 다운로드](img/2022-01-02-aws-01.png)\n\nmsi 파일을 설치하면 PuTTY.exe 와 PuTTYgen.exe 2개의 파일이 설치된다.\n\n## PuTTYgen.exe 실행\n\n![PuTTYgen 실행](img/2022-01-02-aws-02.png)\n\n1. asw에서 인스턴스를 생성하면서 만들었던 pem 키를 Load한다.\n\n![PuTTYgen 실행](img/2022-01-02-aws-03.png)\n\n2. Save private key를 눌러 .ppk 파일을 생성한다.\n\n![PuTTYgen 실행](img/2022-01-02-aws-04.png)\n\n## PuTTY.exe 실행\n\n1. 카테고리 Session에서 Host Name을 설정한다. Host Name은 aws ec2 인스턴스에 연결 페이지에서 확인할 수 있다.\n\n![PuTTY](img/2022-01-02-aws-06.png)\n![PuTTY](img/2022-01-02-aws-05.png)\n\n2. 카테고리 Connection → SSH → Auth를 선택하고 PuTTYgen으로 만들었더 ppk 파일을 추가한다.\n\n![PuTTY](img/2022-01-02-aws-07.png)\n\n3. 다시 Sesstion으로 돌아온 후 Saved Sessions에 프로젝트 이름을 입력한 후 save한다.\n\n![PuTTY](img/2022-01-02-aws-8.png)\n\n4. 프로젝트를 선택하고 Open을 선택한다.\n\n![PuTTY](img/2022-01-02-aws-9.png)\n\n알림창이 나오면 Accept를 선택한다.\n\n![PuTTY](img/2022-01-02-aws-10.png)\n\n정상적으로 접속이 완료되었다.\n\n![PuTTY](img/2022-01-02-aws-11.png)\n\n**PuTTY에서 붙여넣기** : `shft + insert` (crtl + s는 작동 x) <br>\n간단한 설정만 거치면 쉽게 접속할 수 있다.\n"},{"excerpt":"현재 진행하고 있는 팀프로젝트에서 rudux와 redux-saga를 사용하고 있다. \n나 외에도 프론트엔드분이 한분 계신데 store에 어떻게 저장할까 하다가 를 사용해 보고 싶어 제안해 보았고 동의해 주셔서 redux-persist를 사용하기로 하였다. redux-persist란 ? react에서 많이 사용하고 있는 redux는 상태관리로 유명한 라이브…","fields":{"slug":"/2021-12-22-react-redux-persist/"},"frontmatter":{"date":"December 22, 2021","title":"[react] react프로젝트에 redux-persist 적용하기","tags":["react"]},"rawMarkdownBody":"\n현재 진행하고 있는 팀프로젝트에서 rudux와 redux-saga를 사용하고 있다. <br>\n나 외에도 프론트엔드분이 한분 계신데 store에 어떻게 저장할까 하다가 <a href=\"https://github.com/rt2zz/redux-persist\" target=\"_blank\">`redux-persist`</a>를 사용해 보고 싶어 제안해 보았고 동의해 주셔서 redux-persist를 사용하기로 하였다.\n\n## redux-persist란 ?\n\nreact에서 많이 사용하고 있는 redux는 상태관리로 유명한 라이브러리다. 하나의 store에서 데이터를 관리하면서 상태를 예측가능하게 만들고 유지보수 및 디버깅에 유리하기때문에 순수 js 및 js 라이브러리 및 프레임워크에서 많이 사용한다. <br>\n하지만 새로고침을 하면 store의 데이터가 날아가기 때문에, 새로고침을 해도 상태를 유지시키는 기능을 구현해야 한다.\n대표적으로 브라우저의 localStorage나 sessionStorage를 이용한 방법이 있는데 직접 코드를 작성해야 하고, store의 데이터가 많아지수록 코드가 복잡해진다는 단점이 있다. <br>\n\nredux-persist는 localstorage와 sessionstorage에 데이터를 저장하고 저장공간에 있는 데이터를 쉽게 불러오게 도와주는 라이브러리다. 초기 설정만 하면 쉽게 데이터를 저장할 수 있다.\n\n**\\*필요한 라이브러리**\n\n```js\nnpm i connected-react-router redux-devtools-extension redux-persist history\n// or\nyarn add connected-react-router redux-devtools-extension redux-persist history\n```\n\n## redux-persist 설정하기\n\n**\\*폴더 구조**\n\n```bash\nindex.js\nredux\n    └── reducers\n        └── index.js\n    └── sagas\n        └── index.js\n    └── store.js\n    └── types.js\n```\n\n나는 redux폴더 및에 reducers와 sagas를 나누고 store.js에 이를 통합하여 store를 생성하는 구조로 만들었다.\n\n**\\*reducers/index.js**\n\n```js\nimport { combineReducers } from 'redux';\nimport { connectRouter } from 'connected-react-router';\nimport { createBrowserHistory } from 'history';\nimport { persistReducer } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage\n// import storageSession from 'redux-persist/lib/storage/session';\n\nexport const history = createBrowserHistory();\n\nconst persistConfig = {\n  key: 'root',\n  storage: storage, // or storageSession\n  // whitelist: ['']   // 특정 reducer만 사용하고 싶을 때\n  // blacklist: [''],  // 특정 reducer를 제외하고 싶을때\n};\n\nconst rootReducer = combineReducers({\n  router: connectRouter(history),\n  auth: authReducer,\n  ...\n});\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nexport default persistedReducer;\n\n```\n\n- createBrowserHistory() : react-router를 사용하는 경우 history를 props로 전달한다면, 각각의 컴포넌트들은 history, location, match 객체를 props로 부터 제공받아 사용할 수 있다.\n- persistConfig = { storage } : localStorage와 storageSession를 선택할 수 있다.\n- persistConfig = { whitelist, blacklist } : 속성을 사용하면 store에 저장될 reducer를 설정할 수 있다. (설정하지 않으면 모든 reducer가 저장된다)\n\n**\\*reducers/store.js**\n\n```js\nimport { createStore, applyMiddleware } from \"redux\"\nimport createSagaMiddleware from \"redux-saga\"\nimport { composeWithDevTools } from \"redux-devtools-extension\"\nimport { persistStore } from \"redux-persist\"\nimport persistedReducer from \"./reducers\"\nimport rootSaga from \"./sagas\"\n\nconst sagaMiddleware = createSagaMiddleware()\n\nexport const store = createStore(\n  persistedReducer,\n  composeWithDevTools(applyMiddleware(sagaMiddleware))\n)\n\nsagaMiddleware.run(rootSaga)\n\nexport const persistor = persistStore(store)\n\nexport default { store, persistor }\n```\n\n- persistReducer(persistConfig, rootReducer) : persistConfig 가 추가된 rootReducer로 store를 생성한다.\n- persistStore : 새로고침을 하거나 브라우저가 종료되도 상태가 지속되는 store를 생성한다.\n\n**\\*index.js**\n\n```js\nimport React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport App from \"./App\"\nimport { Provider } from \"react-redux\"\nimport { ConnectedRouter } from \"connected-react-router\"\nimport { history } from \"./redux/reducers\"\nimport { PersistGate } from \"redux-persist/integration/react\"\nimport { store, persistor } from \"./redux/store\"\n\nReactDOM.render(\n  <Provider store={store}>\n    <ConnectedRouter history={history}>\n      <PersistGate loading={null} persistor={persistor}>\n        <App />\n      </PersistGate>\n    </ConnectedRouter>\n  </Provider>,\n  document.getElementById(\"root\")\n)\n```\n\n- ConnectedRouter : provider와 connectedRouter를 사용하면 history 객체를 받아서 사용할 수 있다.\n\n![redux 크롬 개발자](img/2021-12-22.react-redux-persist1.jpg)\n\n적용이 완료되었다면 Redux DevTools에서 확인이 가능하다. state에 하단처럼 \\_persist값이 생겼고 새로고침해도 데이터가 유지된다.\n\n**\\*사용해 보니 모든 데이터가 저장되기 때문에 저장이 필요없는 값까지 저장이 되버렸다. <br>이는 불필요한 메모리를 증가시킨다. 따라서 blackList를 설정하기 위해 blackList전용 reducer를 생성했다. <br>(이건 좀 귀찮은 방법이고 카테고리별로 나눈방법에 위배되는 방법이었다. 만약 큰 규모라면 카테고리별로 blackList reducer를 따로 만들었겠지만 나는 하나의 blacklist 파일만 만들어 몽땅 처리했다. <br> 이게 단점이라면 단점이지만 간단한 설정을 통해 자동으로 store에 저장해주는 기능은 정말 편리한 것 같다.**\n<br>\n"},{"excerpt":"MissingInteger. 문제 : codilit MissingInteger\nN개의 정수로 이루어진 배열 A가 있다. A에 존재하지 않는 가장 작은 양의 정수를 반환하는 함수를 작성하는 문제이다.\n(0보다 큰 양의 정수를 반환해야 한다.)\n예를들어, 배열 A가 −1, −3으로 주어졌을때 0보다 큰 1이 반환되어야 한다. Solution: 처음 내가 푼 …","fields":{"slug":"/2021-12-14-codility/"},"frontmatter":{"date":"December 14, 2021","title":"[algorithm] Codility Lesson 4. MissingInteger","tags":["algorithm","javascript"]},"rawMarkdownBody":"\n## MissingInteger.\n\n문제 : <a href=\"https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/\" target=\"_blank\">codilit MissingInteger</a><br>\nN개의 정수로 이루어진 배열 A가 있다. A에 존재하지 않는 가장 작은 양의 정수를 반환하는 함수를 작성하는 문제이다.\n(0보다 큰 양의 정수를 반환해야 한다.)<br>\n예를들어, 배열 A가 [−1, −3]으로 주어졌을때 0보다 큰 1이 반환되어야 한다.\n\n### Solution:\n\n처음 내가 푼 코드는 이렇다.<br>\n배열 A를 순서대로 정렬하고 1부터 A의 가장큰수로 채워진 새로운 배열 arr을 만든다. <br>\n그리고 존재하는 값을 확인하기 위해 Set을 사용하여 arr의 값을 복사한다. (indexOf를 사용하면 시간측정이 길어졌기 때문에 Set을 사용했다.)<br>\nfor문으로 A의 배열을 돌면서 set에 값이 있는지 체크하고 있다면 delete 메소드로 삭제한다. <br>\n\n남아있는 배열의 개수가 0개라면 A = [1,2,3] 처럼 순서대로 채워진 배열이라는 뜻이기 때문에 3보다 큰 4를 리턴하기 위해 배열의 마지막 원소보다 1이 큰 수를 리턴한다. <br>\nA = [1, 3, 6, 4, 1, 2]일때 원소를 삭제하면 5가 남는다. 남아있는 배열의 개수가 이처럼 1개라면 배열의 첫번째 원소를 리턴한다. <br>\n그 외에 A = [-1, -3] 처럼 음의 정수로 이루어진 배열이었다면, arr은 [1,2]로 생성되었기 때문에 첫번째 원소인 1을 리턴한다.\n\n```js\nfunction solution(A) {\n  const N = A.length\n  A.sort((a, b) => a - b)\n  const arr = new Array(N).fill().map((v, i) => i + 1)\n  const set = new Set([...arr])\n\n  for (let i = 0; i < N; i++) {\n    if (set.has(A[i])) set.delete(A[i])\n  }\n\n  if (set.size === 0) return A[N - 1] + 1\n  else return [...set][0]\n}\n```\n\n### Result :\n\n<div style=\"text-align: left;\">\n\n![MissingInteger 결과](img/2021-12-04-codility.jpg)\n\n</div>\n\n#### \\*분석도 결과 : O(N) or O(n log₂ n)\n\n### 다른 사람의 풀이\n\n출처 : <a href=\"https://sustainable-dev.tistory.com/7\" target=\"_blank\">https://sustainable-dev.tistory.com/7</a>\n\n```js\nfunction solution(A) {\n  A.sort((a, b) => a - b)\n  let min = 1\n\n  for (const i in A) {\n    if (A[i] > 0 && A[i] === min) min++\n  }\n  return min\n}\n```\n\n좀 더 효율적인 코드를 검색해보다가 사실 엄청 간단한 문제였다는 걸 깨닫게 된 코드 <br>\n오름차순으로 배열을 정렬하고 변수 min을 가장 작은 값인 1로 선언한다 <br>\n같은 수가 배열안에 있으면 min을 증가시킨다. <br>\n(시간 복잡도는 내 코드와 동일했다.)<br>\n\n문제를 풀 때, 좀 더 효율적인 알고리즘 방법을 생각하는 연습을 해야겠다. 🤣\n"},{"excerpt":"최근 비전공자를 위한 개발자 취업 인강을 듣고 있다. 그곳에서 TIL에 대한 용어를 처음 알게되었다.  TIL ? TIL이란 의 약자로 오늘 내가 배운것이라는 뜻이다. \n한국에서는 개발자들 사이에서 많이 쓰이는 용어이지만 외국에서는 SNS상에서 자주 쓰이는 약어라고 한다. \n개발자들은 자신의 기술 블로그를 운영하기 때문에 TIL을 따로 운영하지는 분들은 …","fields":{"slug":"/2021-12-12-gaysby/"},"frontmatter":{"date":"December 12, 2021","title":"[gatsby] gaysby로 TIL만들기","tags":["gatsby"]},"rawMarkdownBody":"\n최근 비전공자를 위한 개발자 취업 인강을 듣고 있다. 그곳에서 TIL에 대한 용어를 처음 알게되었다. <br>\n\n## TIL ?\n\nTIL이란 `Today I Learned`의 약자로 오늘 내가 배운것이라는 뜻이다. <br>\n한국에서는 개발자들 사이에서 많이 쓰이는 용어이지만 외국에서는 SNS상에서 자주 쓰이는 약어라고 한다. <br>\n개발자들은 자신의 기술 블로그를 운영하기 때문에 TIL을 따로 운영하지는 분들은 많지 않은것 같다.<br>\n(어떻게 생각하면 기술 블로그 = TIL과 비슷한 느낌이랄까.. 🤔) <br>\n\n나는 기술블로그를 운영하지고 있지만 많은 포스팅을 올리지 못하고 있기 때문에 TIL 페이지를 따로 생성할 지 고민을 했다.<br>\nTIL을 <u>자기가 배운 내용을 매일 하나씩 쌓으면서 만드는 나만의 지식 사전</u>으로 생각해 보기로 했다. <br>\n추후에 동일한 문제가 발생하였을때 해결하지 못한다면 자기반성 및 습득하지 못한 지식을 정리하기에 도움이 될 것 같았기 때문에 TIL 페이지를 생성하기로 결정하였다.\n\n**TIL 참고 예시**\n\n- <a href=\"http://milooy.github.io/TIL/\" target=\"_blank\">진유림(milooy)님의 TIL 저장소</a>\n- <a href=\"https://github.com/cheese10yun/TIL\" target=\"_blank\">김남윤(Cheese10Yun)님의 TIL 저장소</a>\n- <a href=\"https://github.com/HomoEfficio/dev-tips\" target=\"_blank\">HomoEfficio님의 문제해결 저장소</a>\n- <a href=\"https://github.com/namjunemy/TIL\" target=\"_blank\"> 김남준(namjunemy)님의 TIL 저장소</a>\n- <a href=\"https://github.com/wayhome25/wayhome25.github.io\" target=\"_blank\"> 초보몽키(wayhome25)의 TIL 저장소</a>\n\n어떻게 만들기 고민하다가 vue 개발자분이 <a href=\"https://vuepress.vuejs.org/\" target=\"_blank\">vuepress</a>를 이용해서 문서화 시킨 페이지가 생각이 났고 나도 그렇게 만들어 보고 싶어 검색을 했다.<br>\nreact에서 vuepress와 비슷한 <a href=\"https://www.docz.site/\" target=\"_blank\">Docz</a> <a href=\"https://docusaurus.io/\" target=\"_blank\">Docusaurus</a>가 검색되었다. 둘다 설치해본 결과 Docusaurus는 블로그 느낌이 강해서 Docz를 선택했다. 하지만 Docz는 페이지를 생성할때 마다 404 에러가 뜨면서 page에 파일이 없다는 에러가 발생했다.\n\n![docz 에러](img/2021-12-12-docz02.png)\n물론 내가 해결을 못하는 거겠지만 Docz 여러 테마를 설치해봤지만 계속 에러가 발생했다. 😭 <br>\n공식사이트에서 설치하란데로 설치하고 파일을 만들었는데 계속 오류가 발생했다. 구글링을 해보았지만 오래전에 포스팅된 내용들만 존재했고 그조차도 제대로 작동하지 않았다. <br>\n공식 페이지의 `npx create-docz-app docz-app-basic`나 `yarn create docz-app docz-app-basic`는 오류가 나면서 설치조차 되지 않았다.<br>\n하루넘게 해결이 되지 않아 다른 방법을 찾기 시작했다. (docz의 공식 github 페이지에서 설치하라고 하는 코드를 입력해도 오류가 나는걸 보면 자체 업데이트 문제인거 같기도 하다.)<br>\n\nvuepress는 vue 기반의 정적 사이트 생성기이다. 그럼 react 기반의 정적 사이트로 유명한건 뭐가있지? <br>\n바로 내가 지금 글을 쓰는 블로그에도 이용되고 있는 `gatsby`이다 !<br>\n\n우선 gatsby가 설치되어 있지 않다면 글로벌로 설치하자.\n\n```js\n// gatsby 글로벌 설치\nnpm install -g gatsby-cli\n```\n\n## gatsby document 설치 (테마 설치)\n\n![gatsby-theme-document 테마](img/2021-12-12-gatsby01.png)\n\n살펴보기 : <a href=\"https://gatsby-theme-document.netlify.app\" target=\"_blank\"> gatsby-theme-document demo</a><br>\n내가 선택한 테마는 <a href=\"https://github.com/codebushi/gatsby-theme-document\" target=\"_blank\">gatsby-theme-document</a> 이다. 문서관련 테마는 많지는 않았고 그나마 깔끔해 보이는 이 테마를 선택했다.\n\n```js\ngatsby new document-site https://github.com/codebushi/gatsby-theme-document-example\ncd document-site\ngatsby develop\n```\n\n## gatsby 파일 생성하기\n\n**\\*기본구조**\n\n```bash\nroot\n└── content\n  ├── index.mdx #homepage \"/\"\n  ├── codeblock.mdx #codeblock \"/codeblock\"\n  └── codeblock\n    └── subpage.mdx #subpage under codeblock \"/codeblock/subpage\"\n    └── subpage-2.mdx #subpage under codeblock \"/codeblock/subpage-2\"\n```\n\n<div style=\"text-align: left; \">\n\n![폴더 구조](img/2021-12-12-gatsby3.png)\n\n</div>\n\ntest 파일을 생성해 보자. <br>\n우선 content안에 test.mdx 파일을 생성한다.<br>\ncontent바로 밑에 파일을 생성하는건 introduction처럼 상위에 나타나는 파일이다.<br>\n\n\\*test.mdx\n\n```md\n---\ntitle: \"Test\"\ndescription: \"test page\"\n---\n\ntest\n```\n\n파일을 생성하면 다음과 같이 생성된다.\n\n<div style=\"text-align: left; \">\n\n![test.mdx파일](img/2021-12-12-gatsby5.png)\n\n</div>\n\n하위에 파일을 생성하고 싶다면 test.mdx와 이름이 같은 `test` 폴더를 생성하면 된다. <br>\n이렇게 하면 자동으로 /test/하위 파일명 으로 url이 생성된다. <br>\n\n\\*test/test-1.mdx\n\n```md\n---\ntitle: \"test-1 Page\"\ndescription: \"This is the meta description for this page\"\n---\n\ntest -1 page\n```\n\ntest 폴더에 test-1.mdx을 추가하였더니 해당 파일의 title로 subpage가 생성되었다.\n\n<div style=\"text-align: left;\">\n\n![폴더 구조](img/2021-12-12-gatsby04.png)\n\n</div>\n\n나는 github페이지로 배포하기위해 gh-pages를 설치했고 배포했다. <br>\n나는 이걸 보고 설정했다. 설명이 자세하다 :) <a href=\"https://dailyco.tech/share/gatsby-blog-deploy/\" target=\"_blank\">https://dailyco.tech/share/gatsby-blog-deploy/</a> <br>\n브랜치를 하나 추가하고 gh-pages를 설치하고 package.json에 \"deploy\" 속성을 추가하면 된다.\n\n나처럼 <a href=\"https://phrygia.github.io\" target=\"_blank\">https://phrygia.github.io</a>를 사용중이라 다른 레포지토리를 쓰고 싶다면 gatsby-config.js에 설정해주면 된다.\n\n```js\npathPrefix: `/phrygia-TIL`, // 레포지토리명\n```\n\n성공적으로 배포가 완료되었다. <a href=\"https://phrygia.github.io/phrygia-TIL/\" target=\"_blank\">phrygia TIL</a> <br>\n1일 1커밋보다 1일 1배움을 실천하자!\n\n---\n\n### 2021.12.16 추가글\n\n결국 어제 vuepress로 전환했다. <br>\n사용하던 테마가 build 할때 css가 안나온다던지 원하는데로 작동하지 않는 등의 문제가 계속 발생했다. <br>\nreact기반이나 gatsby로 작성하고 싶어 며칠을 계속 찾아보고 적용해봤지만 결국 마음에 드는 것도 없고 오류가 발생해서 vuepress로 전환!\n공식문서도 잘 나와있어서 설정하기도 쉽고 폴더화 하기도 좋았다. 특히 config 파일에서 커스텀 css 파일을 추가할 수 있는게 최고!<br>\n제일 마음에 드는 건 기본 검색기능이다. <br>\ngatsby에선 검색기능을 붙이려면 꽤 복잡해서 포기 😂 <br>\nTIL 페이지 만든다고 4일을 완전 날렸다. 검색 → 적용 → 사용 → 오류 → 검색 → 검색 ~~ 의 무한반복 <br>\n결국엔 vuepress를 사용하기로 하고 딱 원하던 boilerplate github 소스를 찾아서 적용했다.<br>\n힘들게 적용한 만큼 열공하자 👊\n"},{"excerpt":"정렬된 배열에서 요소를 찾는 것이 정렬되지 않는 배열에서 찾는 것보다 빠르고 쉽다. \n정렬 알고리즘을 사용해 메모리에서 배열을 정렬하거나 정렬된 배열을 파일에 기록할 수 있다. ArrayList함수를 만들어 정렬/검색 대상 데이터를 저장한다.\n(각 알고리즘에 대한 설명은 검색하면 너무 자세하게 나와있기 때문에 코드 위주의 포스팅을 했다.) 1. 버블정렬 …","fields":{"slug":"/2021-12-07-sorting-algorithm/"},"frontmatter":{"date":"December 07, 2021","title":"[algorithm] 정렬 알고리즘 - 버블, 삽입, 선택, 병합, 퀵","tags":["algorithm","javascript"]},"rawMarkdownBody":"\n정렬된 배열에서 요소를 찾는 것이 정렬되지 않는 배열에서 찾는 것보다 빠르고 쉽다. <br>\n정렬 알고리즘을 사용해 메모리에서 배열을 정렬하거나 정렬된 배열을 파일에 기록할 수 있다.<br>\n\nArrayList함수를 만들어 정렬/검색 대상 데이터를 저장한다.<br>\n(각 알고리즘에 대한 설명은 검색하면 너무 자세하게 나와있기 때문에 코드 위주의 포스팅을 했다.)\n\n```js\nfunction ArrayList() {\n  let array = []\n\n  this.insert = (...item) => {\n    array.push(...item)\n  }\n\n  this.toString = () => {\n    return array.join()\n  }\n\n  // 인덱스를 교환하는 헬퍼 함수\n  const swap = (index1, index2) => {\n    const aux = array[index1]\n    array[index1] = array[index2]\n    array[index2] = aux\n  }\n}\n```\n\n## 1. 버블정렬\n\n가장 간단한 정렬 알고리즘이다. <br>\n버블정렬은 전체 배열을 순회하면서 인접한 두 원소를 비교하고 그 결과에 따라 두 원소의 위치를 서로 바꾼다. <br>\n버블정렬은 모든 값을 비교하기 때문에 정렬 알고리즘들 중에서 가장 최악이라고 할 수 있다.\n\n<div class=\"blockquote\">\n    시간 복잡도 : O(n²) &nbsp;&nbsp;&nbsp;&nbsp; 공간 복잡도 : O(1)\n</div>\n\n<img src=\"https://mblogthumb-phinf.pstatic.net/20140128_282/justant_1390842794487v9kxH_PNG/%B9%F6%BA%ED%C1%A4%B7%C4.png?type=w2\">\n<small class=\"from\">출처 : <a href=\"https://m.blog.naver.com/justant/20204028286F\" target=\"_blank\">https://m.blog.naver.com/justant/20204028286</a></small><br>\n\n```js\n\nfunction ArrayList() {\n  let array = [];\n  ...\n\n  // 버블 정렬\n  this.bubbleSort = () => {\n    const length = array.length;\n    // 첫 번째 요소부터 마지막 원소까지 순회\n    for (let i = 0; i < length; i++) {\n      // 첫 번째 요소부터 끝에서 두 번째 요소까지 순회\n      for (let j = 0; j < length - 1 - i; j++) {\n        // 현재 요소기 다음 원소보다 크다면 서로 위치를 바꾼다.\n        if (array[j] > array[j + 1]) {\n          swap(j, j + 1);\n        }\n      }\n    }\n  };\n}\n\nconst array = new ArrayList();\narray.insert(5, 1, 9, 7, 2, 3);\nconsole.log(array.toString()); // 5,1,9,7,2,3\narray.bubbleSort();\nconsole.log(array.toString()); // 1,2,3,5,7,9\n\n/*\n[ 5, 1, 9, 7, 2, 3 ]\n[ 1, 5, 9, 7, 2, 3 ]\n[ 1, 5, 7, 9, 2, 3 ]\n[ 1, 5, 7, 2, 9, 3 ]\n[ 1, 5, 7, 2, 3, 9 ]\n--------------------\n[ 1, 5, 2, 7, 3, 9 ]\n[ 1, 5, 2, 3, 7, 9 ]\n--------------------\n[ 1, 2, 5, 3, 7, 9 ]\n[ 1, 2, 3, 5, 7, 9 ]\n*/\n```\n\n## 2. 삽입정렬\n\n배열의 모든 요소를 앞에서부터 차례대로 검색하면서 정렬된 요소와 비교한다. <br>\n정렬되지 않은 요소들을 배열의 자신의 위치를 찾아 이동(삽입)시킨다.<br>\n(두번째 요소부터 정렬을 시작한다.)<br>\n\n<div class=\"blockquote\">\n    시간 복잡도 : O(n²) &nbsp;&nbsp;&nbsp;&nbsp; 공간 복잡도 : O(1)\n</div>\n<br>\n<img src=\"https://mblogthumb-phinf.pstatic.net/20140128_138/justant_1390838207680eBQJX_PNG/1.png?type=w2\">\n<small class=\"from\">출처 : <a href=\"https://m.blog.naver.com/justant/20204025251\" target=\"_blank\">https://m.blog.naver.com/justant/20204025251</a></small><br>\n\n```js\n// 삽입정렬\nthis.insertionSort = () => {\n  const length = array.length\n  let j\n  let temp\n\n  // 2번째 요소부터 끝까지 배열을 순회\n  for (let i = 1; i < length; i++) {\n    j = i\n    temp = array[i]\n\n    // j가 0보다 크고 직전 인덱스의 요소가 인덱스 i의 요소보다 크면\n    while (j > 0 && array[j - 1] > temp) {\n      // 직전 인덱스의 원소를 i로 옮기고\n      array[j] = array[j - 1]\n      //j를 1만큼 감소\n      j--\n    }\n    // 제자리를 찾아 원소 삽입\n    array[j] = temp\n  }\n}\nconst array = new ArrayList()\narray.insert(5, 1, 3, 7, 2, 9)\nconsole.log(array.toString()) // 5,1,3,7,2,9\narray.insertionSort()\nconsole.log(array.toString()) // 1, 2, 3, 4, 5\n\n/*\n[ 5, 1, 3, 7, 2, 9 ]\n[ 1, 5, 3, 7, 2, 9 ]\n[ 1, 3, 5, 7, 2, 9 ]\n[ 1, 2, 3, 5, 7, 9 ]\n*/\n```\n\n## 3. 선택정렬\n\n가장 작은 요소를 찾아서(선택해서) 해당 요소를 배열의 현 위치에 삽입하는 방식이다.<br> \\*삽입정렬과 비슷지만 가장 작은 요소를 찾아서 정렬하는것이 다르다.\n\n<div class=\"blockquote\">\n    시간 복잡도 : O(n²) &nbsp;&nbsp;&nbsp;&nbsp; 공간 복잡도 : O(1)\n</div>\n<br>\n<img src=\"https://mblogthumb-phinf.pstatic.net/20140128_73/justant_1390835759169oepXz_PNG/1.png?type=w2\">\n<small class=\"from\">출처 : <a href=\"https://m.blog.naver.com/justant/20203018572\" target=\"_blank\">https://m.blog.naver.com/justant/20203018572</a></small><br>\n\n```js\n// 선택정렬\nthis.selectionSort = () => {\n  const length = array.length\n  // 최솟값을 가진 원소의 인덱스를 담을 변수 선언\n  let indexMin\n\n  // 배열을 순회하면서 i+1번째로 작은 값을 찾는다.\n  for (let i = 0; i < length - 1; i++) {\n    // 최솟값을 가진 원소의 인덱스를 i라고 가정\n    indexMin = i\n    for (let j = i; j < length; j++) {\n      // i에서 length까지 j 인덱스 원소 값을 현재까지의 최솟값과 비교\n      if (array[indexMin] > array[j]) {\n        // 작다면 현재 최솟값을 원소 값으로 갱신\n        indexMin = j\n      }\n    }\n    // 안쪽 for문을 벗어 날때 i+1번째로 작은 값이 결정되며 indexMin와 다르면 원소의 위치를 교환한다.\n    if (i !== indexMin) {\n      swap(i, indexMin)\n    }\n  }\n}\n\nconst array = new ArrayList()\narray.insert(5, 1, 3, 7, 2, 9)\nconsole.log(array.toString()) // 5,2,4,6,1,3,2,6\narray.selectionSort()\nconsole.log(array.toString()) // 1,2,2,3,4,5,6,6\n\n/*\n[ 5, 1, 3, 7, 2, 9 ]\n[ 1, 5, 3, 7, 2, 9 ]\n[ 1, 2, 3, 7, 5, 9 ]\n[ 1, 2, 3, 7, 5, 9 ]\n[ 1, 2, 3, 5, 7, 9 ]\n[ 1, 2, 3, 5, 7, 9 ]\n*/\n```\n\n## 4. 병합정렬\n\n각 하위 배열이 하나의 요소가 존재할 때까지 배열을 하위 배열로 나눈다. <br>\n그 후, 각 하위 배열을 정렬된 순서로 연결(병합)하여 정렬된 하나의 배열을 만든다.\n\n<div class=\"blockquote\">\n    시간 복잡도 : 평균 O(n log₂ n) &nbsp;&nbsp;&nbsp;&nbsp; 공간 복잡도 : O(n))\n</div>\n\n![병합정렬](img/2021-12-07-merge-sort.jpg)<br>\n\n```js\n// 병합정렬\nthis.mergeSort = () => {\n  array = mergeSortRec(array)\n}\n\n// 병합정렬 헬퍼 함수\nconst mergeSortRec = array => {\n  const length = array.length\n\n  // 배열 크기가 1이면 재귀 호출을 중단한다.\n  if (length === 1) return array\n\n  // 크기가 2개 이상이라면, 더 작게 나눈다. -> 중간 지점을 찾아 좌/우측으로 분할 한다.\n  const mid = Math.floor(length / 2)\n  const left = array.slice(0, mid)\n  const right = array.slice(mid, length)\n\n  console.log(left, right)\n\n  /*\n    [ 5, 2, 4, 6 ] [ 1, 3, 2, 6 ]\n    [ 5, 2 ] [ 4, 6 ]\n    [ 5 ] [ 2 ]\n    [ 4 ] [ 6 ]\n    [ 1, 3 ] [ 2, 6 ]\n    [ 1 ] [ 3 ]\n    [ 2 ] [ 6 ]\n  */\n\n  // merge함수를 호출해 잘게 쪼개진 배열들이 최종 정렬된 배열이 될때까지 반복한다.\n  return merge(mergeSortRec(left), mergeSortRec(right))\n}\n\nconst merge = (left, right) => {\n  let result = []\n  let il = 0\n  let ir = 0\n\n  while (il < left.length && ir < right.length) {\n    if (left[il] < right[ir]) {\n      result.push(left[il++])\n    } else {\n      result.push(right[ir++])\n    }\n  }\n\n  while (il < left.length) {\n    result.push(left[il++])\n  }\n\n  while (ir < right.length) {\n    result.push(right[ir++])\n  }\n  console.log(result)\n  /*\n    [ 2, 5 ]\n    [ 4, 6 ]\n    [ 2, 4, 5, 6 ]\n    [ 1, 3 ]\n    [ 2, 6 ]\n    [ 1, 2, 3, 6 ]\n    [ 1, 2, 2, 3, 4, 5, 6, 6 ]\n  */\n\n  return result\n}\n\nconst array = new ArrayList()\narray.insert(5, 2, 4, 6, 1, 3, 2, 6)\nconsole.log(array.toString()) // 5,2,4,6,1,3,2,6\narray.mergeSort()\nconsole.log(array.toString()) // 1,2,2,3,4,5,6,6\n```\n\n## 5. 퀵정렬\n\n기준점을 지정한 다음 해당 기준점을 기준으로 배열을 나눈다. <br>\n모든 요소가 정렬될 때까지 이 나누는 과정을 반복한다. <br>\n기준점은 분할 부분의 첫 번째 요소와 중간, 마지막 요소의 중간 값을 얻어 기준점을 얻는다. <br>\n가장 이상적인 기준점은 가운데 값이다.\n\n<div class=\"blockquote\">\n    시간 복잡도 : 평균 O(n log₂ n), 최악의 경우 O(n²) &nbsp;&nbsp;&nbsp;&nbsp; 공간 복잡도 : O(log₂ n)\n</div>\n\n![퀵정렬](img/2021-12-07-quick-sort.jpg)\n\n```js\n// 퀵정렬\nthis.quickSort = () => {\n  quick(array, 0, array.length - 1)\n}\n\nconst quick = (array, left, right) => {\n  let index\n  if (array.length > 1) {\n    index = partition(array, left, right)\n    if (left < index - 1) {\n      quick(array, left, index - 1)\n    }\n    if (index < right) {\n      quick(array, index, right)\n    }\n  }\n}\n\nconst partition = (array, left, right) => {\n  // 배열의 중간 원소\n  let pivot = array[Math.floor((right + left) / 2)]\n  let i = left\n  let j = right\n\n  while (i <= j) {\n    while (array[i] < pivot) i++\n    while (array[j] > pivot) j--\n    if (i <= j) {\n      swapQuickSort(array, i, j)\n      i++\n      j--\n    }\n  }\n  return i\n}\n\nconst swapQuickSort = (array, index1, index2) => {\n  const aux = array[index1]\n  array[index1] = array[index2]\n  array[index2] = aux\n}\n\nconst array = new ArrayList()\narray.insert(3, 1, 4, 1, 5, 9, 2, 6, 5, 4)\nconsole.log(array.toString()) // 3,1,4,1,5,9,2,6,5,4\narray.quickSort()\nconsole.log(array.toString()) // 1,1,2,3,4,4,5,5,6,9\n```\n\n### 정렬 JS 알고리즘 전체코드\n\n```js\nfunction ArrayList() {\n  let array = []\n\n  this.insert = (...item) => {\n    array.push(...item)\n  }\n\n  this.toString = () => {\n    return array.join()\n  }\n\n  // 프라이빗 헬퍼 함수들\n  // 인덱스를 교환하는 헬퍼 함수\n  const swap = (index1, index2) => {\n    const aux = array[index1]\n    array[index1] = array[index2]\n    array[index2] = aux\n  }\n\n  // 병합정렬 헬퍼 함수\n  const mergeSortRec = array => {\n    const length = array.length\n\n    if (length === 1) return array\n\n    const mid = Math.floor(length / 2)\n    const left = array.slice(0, mid)\n    const right = array.slice(mid, length)\n\n    return merge(mergeSortRec(left), mergeSortRec(right))\n  }\n\n  const merge = (left, right) => {\n    let result = []\n    let il = 0\n    let ir = 0\n\n    while (il < left.length && ir < right.length) {\n      if (left[il] < right[ir]) result.push(left[il++])\n      else result.push(right[ir++])\n    }\n\n    while (il < left.length) {\n      result.push(left[il++])\n    }\n\n    while (ir < right.length) {\n      result.push(right[ir++])\n    }\n\n    return result\n  }\n\n  // 퀵합정렬 헬퍼 함수\n  const quick = (array, left, right) => {\n    let index\n    if (array.length > 1) {\n      index = partition(array, left, right)\n      if (left < index - 1) {\n        quick(array, left, index - 1)\n      }\n      if (index < right) {\n        quick(array, index, right)\n      }\n    }\n  }\n\n  const partition = (array, left, right) => {\n    // 배열의 중간 원소\n    let pivot = array[Math.floor((right + left) / 2)]\n    let i = left\n    let j = right\n\n    while (i <= j) {\n      while (array[i] < pivot) i++\n      while (array[j] > pivot) j--\n      if (i <= j) {\n        swapQuickSort(array, i, j)\n        i++\n        j--\n      }\n    }\n    return i\n  }\n\n  const swapQuickSort = (array, index1, index2) => {\n    const aux = array[index1]\n    array[index1] = array[index2]\n    array[index2] = aux\n  }\n\n  // 버블 정렬\n  this.bubbleSort = () => {\n    const length = array.length\n    for (let i = 0; i < length; i++) {\n      for (let j = 0; j < length - 1 - i; j++) {\n        if (array[j] > array[j + 1]) {\n          swap(j, j + 1)\n        }\n      }\n    }\n  }\n\n  // 삽입정렬\n  this.insertionSort = () => {\n    const length = array.length\n    let j\n    let temp\n\n    for (let i = 1; i < length; i++) {\n      j = i\n      temp = array[i]\n      while (j > 0 && array[j - 1] > temp) {\n        array[j] = array[j - 1]\n        j--\n      }\n      array[j] = temp\n    }\n  }\n\n  // 선택정렬\n  this.selectionSort = () => {\n    const length = array.length\n    let indexMin\n\n    for (let i = 0; i < length - 1; i++) {\n      indexMin = i\n      for (let j = i; j < length; j++) {\n        if (array[indexMin] > array[j]) {\n          indexMin = j\n        }\n      }\n      if (i !== indexMin) {\n        swap(i, indexMin)\n      }\n    }\n  }\n\n  // 병합정렬\n  this.mergeSort = () => {\n    array = mergeSortRec(array)\n  }\n\n  // 퀵정렬\n  this.quickSort = () => {\n    quick(array, 0, array.length - 1)\n  }\n}\n```\n\n<small class=\"from add\">참고 : 자바스크립트로하는 자료 구조와 알고리즘(배세민)<br>\n자바스크립트 자료 구조와 알고리즘(로이아니 그로네)\n</small>\n"},{"excerpt":"알고리즘을 구현하기 전에 알고리즘이 얼마나 효과적인지 분석하는 법을 이해해야 한다.\n알고리즘을 구현할 때 빅오 표기법이 해당 알고리즘이 얼마나 효율적인지를 나타내기 때문에 빅오 표기법은 중요하다.\n효율적인 방법을 고민한다는 것은 시간 복잡도를 고민한다는 것과 같은 말이다. \n Time Complexity (시간 복잡도) 문제를 해결하는데 걸리는 시간과 입…","fields":{"slug":"/2021-12-02-bigO/"},"frontmatter":{"date":"December 02, 2021","title":"[algorithm] 자바스크립트 빅오 표기법 (Big-O)","tags":["algorithm","javascript"]},"rawMarkdownBody":"\n알고리즘을 구현하기 전에 알고리즘이 얼마나 효과적인지 분석하는 법을 이해해야 한다.<br>\n알고리즘을 구현할 때 빅오 표기법이 **해당 알고리즘이 얼마나 효율적인지**를 나타내기 때문에 빅오 표기법은 중요하다.<br>\n효율적인 방법을 고민한다는 것은 시간 복잡도를 고민한다는 것과 같은 말이다. <br>\n`빅오 표기법은 알고리즘의 최악의 경우 복잡도를 측정하며 알고리즘의 효율성을 나타내는 표기법이다.`\n\n## Time Complexity (시간 복잡도)\n\n문제를 해결하는데 걸리는 시간과 입력의 관계를 가리킨다. <br>\n<u>즉, 입력값에 따라 연산을 실행할 때, 연산 횟수에 비해 얼마만큼의 시간이 걸리는가를 의미한다. </u><br>\n시간복잡도를 고민한다는 것은 입력값이 커짐에 따라 증가하는 시간을 최소화한 알고리즘을 만들었다는 의미이기도 한다.<br>\n시간복잡도는 Big-o 표기법을 사용해 나타낼 수 있다.<br>\n\n![/img/2021-12-02-bigO01.jpg](/img/2021-12-02-bigO01.jpg)\n<small class=\"from\">출처 : 자바스크립트로하는 자료 구조와 알고리즘</small><br>\n\n**\\*시간복잡도 순서** : 𝑂(1) < 𝑂(log n) < 𝑂(n) < 𝑂(n log n) < 𝑂(n²) < 𝑂(n³) < 𝑂(2ⁿ) < 𝑂(n!)\n\n**알고리즘 분석 시 가장 자주 등장하는 유형**\n\n<table style=\"width: auto;\">\n    <colgroup>\n        <col style=\"width:180px;\">\n        <col style=\"width:210px;\">\n    </colgroup>\n    <thead>\n        <tr>\n            <th>표기법</th>\n            <th>명칭</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>O(1)</th>\n            <td>상수</td>\n        </tr>\n        <tr>\n            <th>O(n)</th>\n            <td>선형</td>\n        </tr>\n        <tr>\n            <th>O(n²)</th>\n            <td>2차</td>\n        </tr>\n        <tr>\n            <th>O(log₂ n)</th>\n            <td>로그</td>\n        </tr>\n        <tr>\n            <th>O(n log₂ n)</th>\n            <td>다형 로그</td>\n        </tr>\n        <tr>\n            <th>O(n^c)</th>\n            <td>고차</td>\n        </tr>\n        <tr>\n            <th>O(2ⁿ)</th>\n            <td>지수</td>\n        </tr>\n    </tbody>\n</table>\n\n## O 표기법 이해\n\n알고리즘의 효율은 어떻게 측정할 수 있을까? <br>\n보통 CPU(소요 시간), 메모리, 디스크, 네트워크의 사용량을 생각할 수 있는데, 그중 O 표기법은 CPU 사용량을 대상으로 한다.\n\n### 1. O(1)\n\n**입력값이 증가하더라도 시간은 변하지 않는다.** 따라서 O(1)을 상수 시간이라고 부른다. <br>\n입력값의 크기와 관계없이 즉시 출력값을 얻을 수 있다.\n배열의 항목을 인덱스를 사용해 접근하는 경우를 예로 들 수 있다.\n\n```js\n// 예제 1\nfunction O_1(arr, index) {\n  return arr[index]\n}\nconst arr = [\"a\", \"b\", \"c\", \"d\", \"e\"]\nlet index = 3\nconsole.log(O_1(arr, index)) // 'd'\n\n// 예제 2\nfunction increment(num) {\n  return num++\n}\nconsole.log(increment(99)) // 100\n```\n\n- 함수 실행시 걸리는 시간을 X라고 했을 때, 예제 1과에서 arr 배열의 개수가 늘어나거나 index의 값이 바뀌더라도 즉시 출력값을 얻을 수 있다.\n- 예제 2또한 99를 다른 숫자로 바꾸어도 실행 시간은 여전히 X이다.\n- 인자에 상관없이 함수의 성능은 달라지지 않기 때문에 일정한 O(1)의 복잡도를 갖는다.\n\n### 2. O(n)\n\n선형 복잡도라고 부르며, **입력값의 증가도에 따라 시간도 동일한 비율로 증가하는 것**을 의미한다.\n\n```js\n// 예제 3\nfunction sequentialSearch(array, item) {\n  for (let i = o; i < array.length; i++) {\n    if (item === array[i]) {\n      return i\n    }\n  }\n  return -1\n}\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nconst item = 1\n```\n\n- 예제 3에서 배열에서 item의 값과 같으면 그 즉시 함수를 종료한다.\n- 만약 item이 1이라면 첫번째 루프 실행 시 곧바로 종료된다.\n- 루프 반복시 드는 비용 : {1}, item = 10 → 총 {10}의 비용 발생 (1을 찾을때 보다 10배의 비용이 든다.)\n- (최악의 경우 → 값이 없어도 모든 루프를 돌고 -1을 리턴할 것이다.)\n- arr = [1... 1000], item = 1000 일때 드는 비용은 1000이다.<br>\n  최악의 경우일 때, 크기가 1000이면 비용도 1000이 되므로 O(n)의 시간복잡도를 갖게 되는 것이다.\n\n### 3. O(n²)\n\nO(n²)은 2차 복잡도라고 부르며, **입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것**을 의미한다. <br>\n대표적으로 버블 정렬 알고리즘이 있다.\n\n```js\n// 예제 4\nfunction swap(array, index1, index2) {\n  let aux = array[index1]\n  array[index1] = array[index2]\n  array[index2] = aux\n}\n\nfunction bubbleSort(array) {\n  let length = array.length\n  for (let i = 0; i < length; i++) {\n    for (let j = 0; j < length - 1; j++) {\n      if (array[j] > array[j + 1]) {\n        swap(array, j, j + 1)\n      }\n    }\n  }\n}\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nbubbleSort(array)\n```\n\n- 크기가 10인 배열을 넣고 실행하면 총 비용은 100(10²) 이다.\n- 크기가 100인 배열이면 총 비용은 10000(100²)이 된다.\n- 입력값이 커질수록 실행 시간은 기하급수적으로 늘어난다.\n\n**\\* 단일 루프라면 O(n), 중첩 루프면 O(n²), 삼중 루프라면 복잡도는 O(n³)이 된다.**\n\n### 4. O(log₂ n)\n\n- 입력값의 크기가 커질수록 실행 시간이 로그(log: 지수 함수의 역함수) 만큼 짧아지는 알고리즘\n- 예를 들어 데이터가 10배가 되면, 처리 시간은 2배가 된다.\n- 대표적으로는 이진 탐색이 있다.\n- 재귀가 순기능으로 이루어지는 경우도 해당된다.\n\n### 5. O(n log₂ n)\n\n- 데이터가 많아질수록 처리시간이 로그(log) 배만큼 더 늘어나는 알고리즘\n- 예를 들어 데이터가 10배가 되면, 처리 시간은 약 20배가 된다.\n- 대표적으로는 병합 정렬, 퀵 정렬이 있다.\n\n### 6. O(2ⁿ)\n\n- 데이터량이 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즘\n- 대표적으로 피보나치 수열이 있으며, 재귀가 역기능을 할 경우도 해당된다.\n\n## 시간복잡도 줄이는 법\n\n![img/2021-12-02-bigO02.jpg](img/2021-12-02-bigO02.jpg)\n![img/2021-12-02-bigO03.jpg](img/2021-12-02-bigO03.jpg)\n<small class=\"from\">출처 : <a href=\"https://www.bigocheatsheet.com/\" target=\"_blank\">https://www.bigocheatsheet.com/</a></small>\n\n자료구조 및 알고리즘을 적절히 사용하여 시간복잡도를 줄이고 **반복문으로 인해 시간 복잡도가 기하급수적으로 증가 할 수 있으니 반복문 사용에 유의하도록 한다.** <br>\n위의 표를 참고하면 유명한 알고리즘이 어떤 시간 복잡도를 가지고 있는지 알 수 있다. <br>\n위에서 나오는 알고리즘 정도는 열심히 공부해야 겠다.\n\n<small class=\"from add\">참고 : 자바스크립트로하는 자료 구조와 알고리즘(배세민)<br>\n자바스크립트 자료 구조와 알고리즘(로이아니 그로네)<br>\n<a href=\"https://coding-factory.tistory.com/608\" tearget=\"_blank\">https://coding-factory.tistory.com/608</a><br>\n<a href=\"https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/\" tearget=\"_blank\">https://hanamon.kr/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-time-complexity-%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84/</a>\n</small>\n"},{"excerpt":"Word Break. Description: Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. \n문자열s와 단어들로 이루어진 배열 …","fields":{"slug":"/2021-11-28-algorithm/"},"frontmatter":{"date":"November 28, 2021","title":"[algorithm] LeetCode 139. Word Break ","tags":["algorithm","javascript"]},"rawMarkdownBody":"\n## Word Break.\n\n### Description:\n\nGiven a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. <br><br>\n문자열s와 단어들로 이루어진 배열 wordDict가 주어질 때,\nwordDict내의 문자들로 문자열 s를 만들 수 있는지 구하는 문제 (구할 수 있다면 true 반환)<br>\n동일한 단어를 여러번 사용해도 되고 사용하지 않아도 된다.\n\n### Solution:\n\n처음에는 관련 주제를 살펴보지 않고 set을 이용해서 일치하는 단어가 배열에 있다면 문자열 s를 지워나가는 식으로 풀었다. <br>\n이렇게 풀면 wordBreak('cars', [\"car\",\"ca\",\"rs\"])에서 배열의 \"car\"을 먼저 만단 문자열 s는 \"s\"만 남게 되어 false를 리턴했다. <br>\n\"ca\",\"rs\" 를 사용하면 효율적으로 모든 문자열을 제거해 true를 리턴하기 때문에 나의 첫번째 문제 방식은 틀렸다. <br>\n이후 관련 주제를 보고 DP를 사용해 문제를 풀어보기로 했다.\n\n#### \\*Dynamic Programming이란 ?\n\n동적 계획법이라고도 하며 복잡한 문제를 간단한 여러 개의 작은 문제로 나누어 푸는 방법을 말한다.<br>\n작은 문제가 반복해서 일어나고 정답이 같을 때 사용할 수 있다.\n<small class=\"from\"><a href=\"https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95\" target=\"_blank\">동적 계획법 (위키백과)</a></small>\n\n```js\nconst wordBreak = function (s, wordDict) {\n  let dp = Array(s.length + 1).fill(false)\n  dp[0] = true\n  for (let i = 1; i <= s.length; i++) {\n    for (let word of wordDict) {\n      if (i >= word.length && s.slice(i - word.length, i) === word) {\n        dp[i] = dp[i - word.length] || dp[i]\n      }\n    }\n  }\n  return dp[s.length]\n}\n\nconsole.log(wordBreak(\"leetcode\", [\"leet\", \"code\"])) // true\nconsole.log(wordBreak(\"applepenapple\", [\"apple\", \"pen\"])) // true\nconsole.log(wordBreak(\"aaaaaaa\"[(\"aaaa\", \"aaa\")])) // true\nconsole.log(wordBreak(\"cars\", [\"car\", \"ca\", \"rs\"])) // true\nconsole.log(wordBreak(\"catsandog\", [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"])) // false\n```\n\n### Related Topics :\n\nHash Table, String, DP (Dynamic Programming), Trie, Memoization\n\n<small class=\"from add\">참고 : <a href=\"https://leetcode.com/problems/word-break/\" target=\"_blank\">https://leetcode.com/problems/word-break/</a>\n\n</small>\n"},{"excerpt":"얼마전부터 사이드 프로젝트를 시작하였다. 프로젝트 인원은 나포함 프론트엔드 개발자 2명, 백엔드 개발자 1명. 3명 다 디자인과는 거리가 먼 사람들이었다. 사이드 프로젝트의 규모가 큰것도 아니라 디자이너를 구하기가 어려웠다. \n디자인적으로 어떻게 할 지 고민을 하다 필자가 사용해본 material ui의 Template를 보고 라이브러리 적용을 권유했고 …","fields":{"slug":"/2021-11-25-mui-react/"},"frontmatter":{"date":"November 27, 2021","title":"[react] Material ui 템플릿 (Mui) 으로 회원가입 페이지 만들기 ","tags":["react"]},"rawMarkdownBody":"\n![img/mui1.jpg](img/mui1.jpg)\n\n얼마전부터 사이드 프로젝트를 시작하였다. 프로젝트 인원은 나포함 프론트엔드 개발자 2명, 백엔드 개발자 1명. 3명 다 디자인과는 거리가 먼 사람들이었다. 사이드 프로젝트의 규모가 큰것도 아니라 디자이너를 구하기가 어려웠다. <br>\n디자인적으로 어떻게 할 지 고민을 하다 필자가 사용해본 material ui의 Template를 보고 라이브러리 적용을 권유했고 다른 프론트엔드 개발자분이 사용에 OK해 프로젝트에 적용해 보기로 했다.<br>\nPS. Material UI가 v5로 업데이트 되면서 MUI로 이름이 변경되었다. 처음에는 비슷한 사이트인지 알고 당황했으나 이름이 변경됐을 뿐! 😅<br><br>\nMaterial-UI (MUI) 홈페이지 : <a href=\"https://mui.com/\" target=\"_blank\">https://mui.com/</a>\n\n## 1. 설치하기\n\n사용하기 전에 패키지를 설치해야 한다. <br>\nnpm, yarn 을 이용하여 설치 가능하다. (기본설치)\n\n```js\n// with npm\nnpm install @mui/material @emotion/react @emotion/styled\n\n// with yarn\nyarn add @mui/material @emotion/react @emotion/styled\n```\n\n프로젝트에서 styled-components를 사용해서 스타일링 하기로 했다면 styled-components as a styling engine으로 설치한다.\n\n```js\n// with npm\nnpm install @mui/material @mui/styled-engine-sc styled-components\n\n// with yarn\nyarn add @mui/material @mui/styled-engine-sc styled-components\n\n```\n\nMaterial에서는 다양한 svg 아이콘도 제공한다.\n\n![img/mui2.jpg](img/mui2.jpg)\nMaterial icons : <a href=\"https://mui.com/components/material-icons/\" target=\"_blank\">https://mui.com/components/material-icons/</a>\n\n```js\n// with npm\nnpm install @mui/icons-material\n\n// with yarn\nyarn add @mui/icons-material\n\n```\n\n## 2. 기본 사용법\n\n```js\nimport * as React from \"react\"\nimport ReactDOM from \"react-dom\"\nimport Button from \"@mui/material/Button\"\n\nfunction App() {\n  return <Button variant=\"contained\">Hello World</Button>\n}\n\nReactDOM.render(<App />, document.querySelector(\"#app\"))\n```\n\n사용할 컴포넌트를 import 한다. 원한다면 styled-components 등을 이용한 커스터 마이징이 가능하다.\n\n## 3. 템블릿 사용하기\n\n![img/mui3.jpg](img/mui3.jpg)\n필자는 회원가입쪽 개발을 맡았기 때문에 Sign Up 템플릿을 사용하기로 했다. Sign Up 하단의 <a href=\"https://github.com/mui-org/material-ui/tree/master/docs/src/pages/getting-started/templates/sign-up\" target=\"_blank\">SOURCE CODE</a>를 눌러 리액트 코드를 복사한다.\n\n## 4. 회원가입 (커스터 마이징)\n\n![img/mui-4.jpg](img/mui-4.jpg)\n기본 템플릿은 이름(First Name, Last Name), 이메일, 비밀번호로 구성되어 있다. 필자는 이름을 한칸으로 줄이고 비밀번호 재입력을 추가하고 유효성 검사를 통해 회원가입을 만들었다.\n\n**\\*기본틀**\n\n```js\nimport React, { useState } from \"react\"\nimport {\n  Avatar,\n  Button,\n  CssBaseline,\n  TextField,\n  FormControl,\n  FormControlLabel,\n  Checkbox,\n  FormHelperText,\n  Grid,\n  Box,\n  Typography,\n  Container,\n} from \"@mui/material/\"\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\"\n\nconst Register = () => {\n  const theme = createTheme()\n  const [checked, setChecked] = useState(false)\n\n  // 동의 체크\n  const handleAgree = event => {\n    setChecked(event.target.checked)\n  }\n\n  // form 전송\n  const handleSubmit = e => {\n    e.preventDefault()\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <Container component=\"main\" maxWidth=\"xs\">\n        <CssBaseline />\n        <Box\n          sx={{\n            marginTop: 8,\n            display: \"flex\",\n            flexDirection: \"column\",\n            alignItems: \"center\",\n          }}\n        >\n          <Avatar sx={{ m: 1, bgcolor: \"secondary.main\" }} />\n          <Typography component=\"h1\" variant=\"h5\">\n            회원가입\n          </Typography>\n          <Boxs\n            component=\"form\"\n            noValidate\n            onSubmit={handleSubmit}\n            sx={{ mt: 3 }}\n          >\n            <FormControl component=\"fieldset\" variant=\"standard\">\n              <Grid container spacing={2}>\n                <Grid item xs={12}>\n                  <TextField\n                    required\n                    autoFocus\n                    fullWidth\n                    type=\"email\"\n                    id=\"email\"\n                    name=\"email\"\n                    label=\"이메일 주소\"\n                  />\n                </Grid>\n                <Grid item xs={12}>\n                  <TextField\n                    required\n                    fullWidth\n                    type=\"password\"\n                    id=\"password\"\n                    name=\"password\"\n                    label=\"비밀번호 (숫자+영문자+특수문자 8자리 이상)\"\n                  />\n                </Grid>\n                <Grid item xs={12}>\n                  <TextField\n                    required\n                    fullWidth\n                    type=\"password\"\n                    id=\"rePassword\"\n                    name=\"rePassword\"\n                    label=\"비밀번호 재입력\"\n                  />\n                </Grid>\n                <Grid item xs={12}>\n                  <TextField\n                    required\n                    fullWidth\n                    id=\"name\"\n                    name=\"name\"\n                    label=\"이름\"\n                  />\n                </Grid>\n                <Grid item xs={12}>\n                  <FormControlLabel\n                    control={\n                      <Checkbox onChange={handleAgree} color=\"primary\" />\n                    }\n                    label=\"회원가입 약관에 동의합니다.\"\n                  />\n                </Grid>\n              </Grid>\n              <Button\n                type=\"submit\"\n                fullWidth\n                variant=\"contained\"\n                sx={{ mt: 3, mb: 2 }}\n                size=\"large\"\n              >\n                회원가입\n              </Button>\n            </FormControl>\n          </Boxs>\n        </Box>\n      </Container>\n    </ThemeProvider>\n  )\n}\nexport default Register\n```\n\n### 유효성 검사하기\n\n![img/mui5.jpg](img/mui5.jpg)\n\n사실 유효성검사를 어떻게 작성할지 고민을 많이했다. <a href=\"https://react-hook-form.com/\" target=\"_blank\">react hook form</a>을 사용할지 정규식을 활용해서 검사할지에 대해서 고민했다. <br>\nreact hook form은 사용이 쉽고 코드가 깔끔해진다는 장점이 있고, 정규식은 코드양이 많아지고 복잡해지지만 스스로 회원가입 form을 만들었다는 기분을 느낄 수 있을 것 같았다.<br>\n계속 고민을 하다가 실무에서는 코드량이 많아져 이렇게 못할 것 같은 느낌에 한번쯤은 정규식을 사용해서 회원가입을 만들어보고 싶어 정규식을 사용해서 개발하기로 했다. <br>\n\nFormControl이 form으로 작동하는 것 같아 form을 활용하기로 했다. <br>\nnew FormData를 사용해 TextField에서 지정해준 name으로 input값을 받아온다.<br>\n유효성을 검사에 통과하지 못한다면 에러 메시지를 출력해줘야 한다. useState로 메시지를 관리하기로 했다.<br>\n\n```js\n// useState 추가\nconst [emailError, setEmailError] = useState('');\nconst [passwordState, setPasswordState] = useState('');\nconst [passwordError, setPasswordError] = useState('');\nconst [nameError, setNameError] = useState('');\n\n// form 전송\nconst handleSubmit = (e) => {\n  e.preventDefault();\n\n  const data = new FormData(e.currentTarget);\n  const joinData = {\n    email: data.get('email'),\n    name: data.get('name'),\n    password: data.get('password'),\n    rePassword: data.get('rePassword'),\n  };\n  const { email, name, password, rePassword } = joinData;\n\n  // 이메일 유효성 체크\n  const emailRegex = /([\\w-.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([\\w-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$/;\n  if (!emailRegex.test(email)) {\n    setEmailError('올바른 이메일 형식이 아닙니다.');\n  } else {\n    setEmailError('');\n  }\n\n  // 비밀번호 유효성 체크\n  const passwordRegex = /^(?=.*[a-zA-Z])(?=.*[!@#$%^*+=-])(?=.*[0-9]).{8,25}$/;\n  if (!passwordRegex.test(password)) {\n    setPasswordState('숫자+영문자+특수문자 조합으로 8자리 이상 입력해주세요!');\n  } else {\n    setPasswordState('');\n  }\n\n  // 비밀번호 같은지 체크\n  if (password !== rePassword) {\n    setPasswordError('비밀번호가 일치하지 않습니다.');\n  } else {\n    setPasswordError('');\n  }\n\n  // 이름 유효성 검사\n    const nameRegex = /^[가-힣a-zA-Z]+$/;\n    if (!nameRegex.test(name) || name.length < 1) {\n      setNameError('올바른 이름을 입력해주세요.');\n    } else {\n      setNameError('');\n    }\n\n    // 회원가입 동의 체크\n    if (!checked) alert('회원가입 약관에 동의해주세요.');\n  };\n};\n\n```\n\nTextField 밑에 &ltFormHelperTexts>{emailError}&lt/FormHelperTexts>같은 해당 TextField에 맡는 Error코드를 넣는다. <br>\n또한 &ltTextField error={emailError !== '' || false} /> 값을 설정한다.<br>\nerror 속성은 회원가입 버튼을 눌렀을 때 오류가 발생하면 해당 input을 빨갛게 만들어 주는 값이다. <br>\nemailError의 상태가 '올바른 이메일 형식이 아닙니다.' 일때 에러가 발생했고 공백이 아니기 때문에 에러를 발생시킨다는 뜻이다.<br>\n\n```js\n<Grid item xs={12}>\n    <TextField\n        required\n        autoFocus\n        fullWidth\n        type=\"email\"\n        id=\"email\"\n        name=\"email\"\n        label=\"이메일 주소\"\n        error={emailError !== '' || false}\n    />\n</Grid>\n<FormHelperTexts>{emailError}</FormHelperTexts>\n```\n\n### 모든 값이 올바르게 채워졌는지 체크하기\n\n<del>유효성을 검사하기는 하지만 회원가입 버튼을 누르면 자꾸 서버에 post요청을 보냈다. <br>\nreact 코드안에서 if {} else {} 구문에서 return 사용이 까다롭고 생각처럼 작동을 하지 않았다.<br>\n고민하다 useState로 유효성 통과 여부를 체크하기로 하였다. setCheckError가 하나라도 false가 된다면 서버 요청이 되지 않는다. <br></del>\n**--> 위의 방법으로 했다가 마지막 검사에서 true가 되면 서버로 요청이 되버리는걸 발견했다. 결국 끝부분에 유효성에 관련된 조건문을 걸었다. (코드 효율성이 떨어지는것 같기 때문에 더 좋은 방법을 생각해 봐야겠다.)**\n\n```js\n\n// form 전송\nconst handleSubmit = (e) => {\n    ...\n\n    // 이메일 유효성 체크\n    const emailRegex =\n      /([\\w-.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([\\w-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$/;\n    if (!emailRegex.test(email)) {\n      setEmailError('올바른 이메일 형식이 아닙니다.');\n    } else {\n      setEmailError('');\n    }\n\n    ...\n\n    // 모두 통과하면 post되는 코드 실행 (axios나 fecth등)\n    if (\n      emailRegex.test(email) &&\n      passwordRegex.test(password) &&\n      password === rePassword &&\n      nameRegex.test(name) &&\n      checked\n    ) {\n      onhandlePost(joinData);\n    }\n}\n```\n\n## 5. 최종 코드\n\n```js\nimport React, { useState } from \"react\"\nimport { useHistory } from \"react-router-dom\"\nimport axios from \"axios\"\nimport {\n  Avatar,\n  Button,\n  CssBaseline,\n  TextField,\n  FormControl,\n  FormControlLabel,\n  Checkbox,\n  FormHelperText,\n  Grid,\n  Box,\n  Typography,\n  Container,\n} from \"@mui/material/\"\nimport { createTheme, ThemeProvider } from \"@mui/material/styles\"\nimport styled from \"styled-components\"\n\n// mui의 css 우선순위가 높기때문에 important를 설정 - 실무하다 보면 종종 발생 우선순위 문제\nconst FormHelperTexts = styled(FormHelperText)`\n  width: 100%;\n  padding-left: 16px;\n  font-weight: 700 !important;\n  color: #d32f2f !important;\n`\n\nconst Boxs = styled(Box)`\n  padding-bottom: 40px !important;\n`\n\nconst Register = () => {\n  const theme = createTheme()\n  const [checked, setChecked] = useState(false)\n  const [emailError, setEmailError] = useState(\"\")\n  const [passwordState, setPasswordState] = useState(\"\")\n  const [passwordError, setPasswordError] = useState(\"\")\n  const [nameError, setNameError] = useState(\"\")\n  const [registerError, setRegisterError] = useState(\"\")\n  const history = useHistory()\n\n  const handleAgree = event => {\n    setChecked(event.target.checked)\n  }\n\n  const onhandlePost = async data => {\n    const { email, name, password } = data\n    const postData = { email, name, password }\n\n    // post\n    await axios\n      .post(\"/member/join\", postData)\n      .then(function (response) {\n        console.log(response, \"성공\")\n        history.push(\"/login\")\n      })\n      .catch(function (err) {\n        console.log(err)\n        setRegisterError(\"회원가입에 실패하였습니다. 다시한번 확인해 주세요.\")\n      })\n  }\n\n  const handleSubmit = e => {\n    e.preventDefault()\n\n    const data = new FormData(e.currentTarget)\n    const joinData = {\n      email: data.get(\"email\"),\n      name: data.get(\"name\"),\n      password: data.get(\"password\"),\n      rePassword: data.get(\"rePassword\"),\n    }\n    const { age, city, email, name, password, rePassword } = joinData\n\n    // 이메일 유효성 체크\n    const emailRegex =\n      /([\\w-.]+)@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.)|(([\\w-]+\\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\\]?)$/\n    if (!emailRegex.test(email)) setEmailError(\"올바른 이메일 형식이 아닙니다.\")\n    else setEmailError(\"\")\n\n    // 비밀번호 유효성 체크\n    const passwordRegex = /^(?=.*[a-zA-Z])(?=.*[!@#$%^*+=-])(?=.*[0-9]).{8,25}$/\n    if (!passwordRegex.test(password))\n      setPasswordState(\"숫자+영문자+특수문자 조합으로 8자리 이상 입력해주세요!\")\n    else setPasswordState(\"\")\n\n    // 비밀번호 같은지 체크\n    if (password !== rePassword)\n      setPasswordError(\"비밀번호가 일치하지 않습니다.\")\n    else setPasswordError(\"\")\n\n    // 이름 유효성 검사\n    const nameRegex = /^[가-힣a-zA-Z]+$/\n    if (!nameRegex.test(name) || name.length < 1)\n      setNameError(\"올바른 이름을 입력해주세요.\")\n    else setNameError(\"\")\n\n    // 회원가입 동의 체크\n    if (!checked) alert(\"회원가입 약관에 동의해주세요.\")\n\n    if (\n      emailRegex.test(email) &&\n      passwordRegex.test(password) &&\n      password === rePassword &&\n      nameRegex.test(name) &&\n      checked\n    ) {\n      onhandlePost(joinData)\n    }\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <Container component=\"main\" maxWidth=\"xs\">\n        <CssBaseline />\n        <Box\n          sx={{\n            marginTop: 8,\n            display: \"flex\",\n            flexDirection: \"column\",\n            alignItems: \"center\",\n          }}\n        >\n          <Avatar sx={{ m: 1, bgcolor: \"secondary.main\" }} />\n          <Typography component=\"h1\" variant=\"h5\">\n            회원가입\n          </Typography>\n          <Boxs\n            component=\"form\"\n            noValidate\n            onSubmit={handleSubmit}\n            sx={{ mt: 3 }}\n          >\n            <FormControl component=\"fieldset\" variant=\"standard\">\n              <Grid container spacing={2}>\n                <Grid item xs={12}>\n                  <TextField\n                    required\n                    autoFocus\n                    fullWidth\n                    type=\"email\"\n                    id=\"email\"\n                    name=\"email\"\n                    label=\"이메일 주소\"\n                    error={emailError !== \"\" || false}\n                  />\n                </Grid>\n                <FormHelperTexts>{emailError}</FormHelperTexts>\n                <Grid item xs={12}>\n                  <TextField\n                    required\n                    fullWidth\n                    type=\"password\"\n                    id=\"password\"\n                    name=\"password\"\n                    label=\"비밀번호 (숫자+영문자+특수문자 8자리 이상)\"\n                    error={passwordState !== \"\" || false}\n                  />\n                </Grid>\n                <FormHelperTexts>{passwordState}</FormHelperTexts>\n                <Grid item xs={12}>\n                  <TextField\n                    required\n                    fullWidth\n                    type=\"password\"\n                    id=\"rePassword\"\n                    name=\"rePassword\"\n                    label=\"비밀번호 재입력\"\n                    error={passwordError !== \"\" || false}\n                  />\n                </Grid>\n                <FormHelperTexts>{passwordError}</FormHelperTexts>\n                <Grid item xs={12}>\n                  <TextField\n                    required\n                    fullWidth\n                    id=\"name\"\n                    name=\"name\"\n                    label=\"이름\"\n                    error={nameError !== \"\" || false}\n                  />\n                </Grid>\n                <FormHelperTexts>{nameError}</FormHelperTexts>\n                <Grid item xs={12}>\n                  <FormControlLabel\n                    control={\n                      <Checkbox onChange={handleAgree} color=\"primary\" />\n                    }\n                    label=\"회원가입 약관에 동의합니다.\"\n                  />\n                </Grid>\n              </Grid>\n              <Button\n                type=\"submit\"\n                fullWidth\n                variant=\"contained\"\n                sx={{ mt: 3, mb: 2 }}\n                size=\"large\"\n              >\n                회원가입\n              </Button>\n            </FormControl>\n            <FormHelperTexts>{registerError}</FormHelperTexts>\n          </Boxs>\n        </Box>\n      </Container>\n    </ThemeProvider>\n  )\n}\n\nexport default Register\n```\n\n모든 유효성 검사에 통과하면 onhandlePost에 입력값을 넘겨 axios로 서버에 post요청을 보내고 회원가입에 성공하면 로그인 페이지로 이동한다. 요청에 실패하면 registerError를 출력한다.\n\n![img/mui6.jpg](img/mui6.jpg)\n\nuseState와 정규식을 이용해서 유효성 검사를 했기 때문에 코드가 꽤 복잡해진 느낌이 있다. 똑같은 코드를 react-hook-form으로 바꿔보면 어떻게 바뀔지 궁금하다. 여유로울때 한번 도전해 봐야겠다. :)<br>\nmui같은 라이브러리가 있어 디자인적으로 신경을 쓰지 않아도 되서 매우 편리하고 생각보다 깔끔한 디자인이 마음에 든다.\n"},{"excerpt":"프로그래머스에서 자바스크립트 알고리즘 문제를 풀다보면 간간히 접하게 되는 수학관련 문제들이 있다.\n그 중 자연수와 관련된(약수, 소수, 최대공약수, 최소공배수) 문제들이 있었는데 이에 대한 이론을 정리하고 프로그래머스 코딩테스트 연습에 나오는 문제들을 풀어보면서 정확한 개념을 터득하고자 정리해 보았다. \n(문제 - 약수의 합, 약수의 개수와 덧셈, 소수 …","fields":{"slug":"/2021-11-09-algorithm/"},"frontmatter":{"date":"November 09, 2021","title":"[algorithm] 약수, 소수, 최대공약수, 최소공배수","tags":["algorithm","javascript"]},"rawMarkdownBody":"\n프로그래머스에서 자바스크립트 알고리즘 문제를 풀다보면 간간히 접하게 되는 수학관련 문제들이 있다.\n그 중 자연수와 관련된(약수, 소수, 최대공약수, 최소공배수) 문제들이 있었는데 이에 대한 이론을 정리하고 프로그래머스 코딩테스트 연습에 나오는 문제들을 풀어보면서 정확한 개념을 터득하고자 정리해 보았다. <br>\n(문제 - 약수의 합, 약수의 개수와 덧셈, 소수 만들기, 소수 찾기, 최대공약수와 최소공배수, N개의 최소공배수)\n\n## 1. 약수\n\n**약수란 무엇인가?** <br>\n&nbsp;&nbsp;&nbsp;&nbsp;<u>어떤 수를 나머지가 없이 나누어떨어지게 하는 수를 그 수의 약수라고 한다.</u> <br>\n&nbsp;&nbsp;&nbsp;&nbsp;예를 들면 8을 1, 2, 4, 8로 나누면 나머지가 없다. 이때 1, 2, 4, 8을 8의 약수라고 한다.\n\n**1. 약수의 합** <br>\n\n<div style=\"text-align: left; \">\n\n![약수의 합](./img/2021-11-09-algorithm-1.jpg)\n\n</div>\n\n**문제풀이**\n\n```js\nfunction solution(n) {\n  let answer = 0\n\n  for (let i = 0; i <= n; i++) {\n    if (n % i === 0) answer += i\n  }\n\n  return answer\n}\n```\n\n<small class=\"from\">https://programmers.co.kr/learn/courses/30/lessons/12928?language=javascript</small> <br>\n\n**2. 약수의 개수와 덧셈**\n\n<div style=\"text-align: left; \">\n\n![약수의 개수와 덧셈](img/2021-11-09-algorithm-2.jpg)\n\n</div>\n\n**문제풀이**\n\n```js\nfunction solution(left, right) {\n  let answer = 0\n\n  for (let i = left; i <= right; i++) {\n    let count = 0\n    for (let j = 1; j <= i; j++) {\n      if (i % j === 0) count++\n    }\n    if (count % 2) answer -= i\n    else answer += i\n  }\n\n  return answer\n}\n```\n\n<small class=\"from\">https://programmers.co.kr/learn/courses/30/lessons/77884?language=javascript</small>\n\n## 2. 소수\n\n**소수란 무엇인가?** <br>\n&nbsp;&nbsp;&nbsp;&nbsp;<u>소수는 1보다 큰 정수이며, 1과 자기 자신으로만 나누어지는 수다. (나머지가 0인 경우)</u> <br>\n&nbsp;&nbsp;&nbsp;&nbsp;1, 2, 4, 5를 예를 들어보자. 1은 1보다 큰 정수가 아니다. <br>\n&nbsp;&nbsp;&nbsp;&nbsp;2는 1과 2이외의 자연수로 나눌 수 없으므로 소수다. <br>\n&nbsp;&nbsp;&nbsp;&nbsp;4는 1과 4이외에도 2로 나누는 것이 가능하므로 소수가 아니다.<br>\n&nbsp;&nbsp;&nbsp;&nbsp;5는 1과 5 이외의 자연수로 나눌 수 없으므로 소수다.<br><br>\n\n**3. 소수 찾기**\n\n<div style=\"text-align: left; \">\n\n![img/2021-11-09-algorithm-4.jpg](img/2021-11-09-algorithm-4.jpg)\n\n</div>\n\n**문제풀이1**\n\n```js\nfunction solution(n) {\n  let answer = 0\n\n  for (let i = 2; i <= n; i++) {\n    let isPrime = true\n    for (let j = 2; j < i; j++) {\n      if (i % j === 0) isPrime = false\n    }\n    if (isPrime) answer++\n  }\n\n  return answer\n}\n```\n\n으로 풀었으나 타임아웃이 발생했다. <br><br>\n**문제풀이2 - 에라토스네테스의 체**\n\n```js\nfunction solution(n) {\n  let arr = Array(n + 1)\n    .fill(true)\n    .fill(false, 0, 2)\n\n  for (let i = 2; i * i <= n; i++) {\n    if (arr[i]) {\n      for (let j = i * i; j <= n; j += i) {\n        arr[j] = false\n      }\n    }\n  }\n\n  return arr.filter(e => e).length\n}\n```\n\n<small class=\"from\">풀이참고: <a href=\"https://velog.io/@jakeseo_me/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-14-%EC%86%8C%EC%88%98-%EC%B0%BE%EA%B8%B0-%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4\" target=\"_blank\">코딩테스트 #14 소수 찾기 (에라토스테네스의 체)</a></small> <br>\n<a href=\"https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4\" target=\"_blank\">에라토스네테스의 체</a>는 각 수의 배수에 해당하는 수는 소수가 아니므로 지운다. 예를 들어 3, 6, 9가 있다면 6, 9는 3의 배수이므로 제외시키면 소수만 남는다. 체로 걸르듯 배수와 제곱수는 일단 소수가 아니므로 제거하는 작업이다.<br><br>\n\n**문제풀이3 - Set**\n\n```js\nfunction solution(n) {\n  const s = new Set()\n\n  for (let i = 1; i <= n; i += 2) {\n    s.add(i)\n  }\n  s.delete(1)\n  s.add(2)\n\n  for (let j = 3; j < Math.sqrt(n); j++) {\n    if (s.has(j)) {\n      for (let k = j * 2; k <= n; k += j) {\n        s.delete(k)\n      }\n    }\n  }\n\n  return s.size\n}\n```\n\n프로그래머스 해설에서 본 문제풀이로 set을 이용한 풀이다.\n<small class=\"from\">https://programmers.co.kr/learn/courses/30/lessons/12921?language=javascript</small>\n\n**4. 소수 찾기**\n\n<div style=\"text-align: left; \">\n\n![img/2021-11-09-algorithm-5.jpg](img/2021-11-09-algorithm-5.jpg)\n\n</div>\n\n**문제풀이**\n\n```js\nfunction solution(numbers) {\n  let answer = 0\n\n  let n = numbers.split(\"\")\n  let nums = new Set()\n  combi(n, \"\")\n\n  function combi(a, s) {\n    if (s.length > 0) {\n      if (nums.has(Number(s)) === false) {\n        nums.add(Number(s))\n        if (chkPrime(Number(s))) answer++\n      }\n    }\n    if (a.length > 0) {\n      for (var i = 0; i < a.length; i++) {\n        var t = a.slice(0)\n        t.splice(i, 1)\n        combi(t, s + a[i])\n      }\n    }\n  }\n\n  function chkPrime(num) {\n    if (num < 2) return false\n    if (num === 2) return true\n    for (var i = 2; i <= Math.sqrt(num); i++) {\n      if (num % i === 0) return false\n    }\n    return true\n  }\n\n  return answer\n}\n```\n\n<small class=\"from\">https://programmers.co.kr/learn/courses/30/lessons/42839?language=javascript</small>\n\n**5. 소수 만들기**\n\n<div style=\"text-align: left; \">\n\n![img/2021-11-09-algorithm-6.jpg](img/2021-11-09-algorithm-6.jpg)\n\n</div>\n\n**문제풀이**\n\n```js\nfunction solution(nums) {\n  let cnt = 0\n\n  for (let i = 0; i < nums.length - 2; i++) {\n    for (let j = i + 1; j < nums.length - 1; j++) {\n      for (let w = j + 1; w < nums.length; w++) {\n        if (isPrime(nums[i] + nums[j] + nums[w])) cnt++\n      }\n    }\n  }\n\n  return cnt\n}\n\n// 소수 판별 함수\nfunction isPrime(n) {\n  for (var i = 2; i <= Math.sqrt(n); i++) {\n    if (n % i === 0) return false\n  }\n  return true\n}\n```\n\n<small class=\"from\">https://programmers.co.kr/learn/courses/30/lessons/12977?language=javascript</small>\n\n## 3. 최대공약수\n\n**6. 최대공약수와 최소공배수**\n\n<div style=\"text-align: left;\">\n\n![img/2021-11-09-algorithm-7.jpg](img/2021-11-09-algorithm-7.jpg)\n\n</div>\n\n**문제풀이1 - 프로그래머스(유클리드 호제법)**\n\n```js\nfunction solution(n, m) {\n  let answer = []\n\n  const greatest = (a, b) => {\n    if (b === 0) return a\n    return greatest(b, a % b)\n  }\n\n  const least = (a, b) => (a * b) / greatest(a, b)\n\n  return [greatest(n, m), least(n, m)]\n}\n```\n\n**문제풀이2 - 프로그래머스**\n\n```js\nfunction greatestCommonDivisor(a, b) {\n  return b ? greatestCommonDivisor(b, a % b) : Math.abs(a)\n}\nfunction leastCommonMultipleOfTwo(a, b) {\n  return (a * b) / greatestCommonDivisor(a, b)\n}\nfunction gcdlcm(a, b) {\n  return [greatestCommonDivisor(a, b), leastCommonMultipleOfTwo(a, b)]\n}\n```\n\n**문제풀이3 - 프로그래머스**\n\n```js\nfunction gcdlcm(a, b) {\n  let r\n  for (let ab = a * b; (r = a % b); a = b, b = r) {}\n  return [b, ab / b]\n}\n```\n\n<small class=\"from\">https://programmers.co.kr/learn/courses/30/lessons/12940?language=javascript</small>\n\n## 4. 최소공배수\n\n**7. N개의 최소공배수**\n\n<div style=\"text-align: left;\">\n\n![img/2021-11-09-algorithm-3.jpg](img/2021-11-09-algorithm-3.jpg)\n\n</div>\n\n**문제풀이1 - 프로그래머스**\n\n```js\nfunction nlcm(num) {\n  return num.reduce((a, b) => (a * b) / gcd(a, b))\n}\n\nfunction gcd(a, b) {\n  return a % b ? gcd(b, a % b) : b\n}\n```\n\n**문제풀이2 - 프로그래머스**\n\n```js\nfunction nlcm(num) {\n  let answer = 0\n\n  function gcd(a, b) {\n    if (!b) return a\n    return gcd(b, a % b)\n  }\n\n  function lcm(a, b) {\n    return (a * b) / gcd(a, b)\n  }\n\n  answer = num.reduce(function (a, b) {\n    let min = Math.min(a, b)\n    let max = Math.max(a, b)\n    return lcm(min, max)\n  })\n\n  return answer\n}\n```\n\n<small class=\"from\">https://programmers.co.kr/learn/courses/30/lessons/12953?language=javascript</small>\n"},{"excerpt":"var 선언한 변수의 문제점 ES6의 let과 const가 생기기 전에 변수를 선언할 수 있는 유일한 방법은 var를 사용하는 것이었다. var로 선언된 변수는 다른 언어와는 구별되는 독특한 특징을 가지고 있다. 1. 변수 중복 선언 허용 var 키워드로 선언한 변수는 중복 선언이 가능하다. 예제 1 var로 선언한 변수는 중복 선언이 가능하지만, 초기화…","fields":{"slug":"/2021-10-30-var-let-const/"},"frontmatter":{"date":"October 31, 2021","title":"[javascript] var, let, const","tags":["javascript"]},"rawMarkdownBody":"\n![](img/jsDeepDive.jpg)\n\n## var 선언한 변수의 문제점\n\nES6의 let과 const가 생기기 전에 변수를 선언할 수 있는 유일한 방법은 var를 사용하는 것이었다. var로 선언된 변수는 다른 언어와는 구별되는 독특한 특징을 가지고 있다.\n\n### 1. 변수 중복 선언 허용\n\nvar 키워드로 선언한 변수는 중복 선언이 가능하다.<br>\n\n**예제 1**\n\n```js\nvar a = 1\nvar b = 1\n\n// 초기화문이 없는 변수 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.\n// 초기화문 : 변수 선언과 동시에 초기값을 할당하는 문\nvar a = 100\nvar b // 초기화문이 없는 선언문은 무시된다.\n\nconsole.log(a) // 100\nconsole.log(b) // 1\n```\n\nvar로 선언한 변수는 중복 선언이 가능하지만, 초기화문 유뮤에 따라 다르게 동작한다. 초기화문이 있는 변수 선언문은 기존 변수에 값을 재할당 하지만 초기화문이 없는 변수 선언문은 무시되고 에러가 발생하지 않는다.\n(여러명이 개발할때 다른 개발자가 동일한 이름의 변수를 초기화문으로 선언한다면 의도치않게 값이 변경될 수 있다.)\n\n### 2. 함수 레벨 스코프\n\nvar 키워드로 선언한 변수는 함수내에서만 지역 스코프로 인정한다. 함수 밖에서 선언한 var 변수는 모두 전역 변수가 된다.<br>\n\n**예제 2**\n\n```js\nvar a = 1\nif (true) {\n  // a가 이미 함수 외부에서 선언됐기 때문에 전역변수가 된다.\n  var a = 10\n}\ncosnole.log(a) // 10\n\nvar i = 10\nfor (var i = 0; i < 5; i++) {\n  // for문에서 선언한 i는 전역변수고 위에서 선언한 i가 있으므로 값이 변경된다.\n  console.log(i) // 0 1 2 3 4\n}\nconsole.log(i) // 5\n```\n\n위의 예제에서 변수 a와 i가 중복 선언되어 변수의 값이 의도치않게 변경되는 부작용이 발생했다.\n\n### 3. 변수 호이스팅\n\nvar 키워드로 변수를 선언하면 호이스팅이 발생한다. 호이스팅에 의해 변수 선언문 이전에 값을 참조할 수 있다. (값을 할당하기 이전에 변수를 참조하면 값은 undefined를 반환한다.)<br>\n\n**예제 3**\n\n```js\n// 1. 호이스팅에 의해 foo 변수가 선언되었다.\n// 2. 변수 foo는 undefined\nconsole.log(foo) // undefined\n\n// 3. 변수에 값을 할당\nfoo = 123\nconsole.log(foo) // 123\n\n// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행\nvar foo\n```\n\n변수 선언문 이전에 변수를 참조하는 것은 호이스팅에 의해 에러가 발생하지는 않지만 가독성이 떨어지고 좋은 코드는 아니기 때문에 사용을 지양한다.\n\n## let 키워드\n\n### 1. 변수 중복 선언 금지\n\n위에서 살펴본 것 처럼 var는 동일한 이름의 변수를 선언해도 아무런 에러가 발생하지 않았지만 값이 바뀔 수 있는 부작용이 발생한다. <br>하지만 let으로 이름이 같은 변수를 중복 선언하면 문법 에러(Syntax Error)가 발생한다.<br>\n\n**예제 4**\n\n```js\n// 중복 선언되어 변수의 값이 변한다.\nvar a = 123\nvar a = 456\n\n// 중복 선언을 허용하지 않는다.\nlet b = 123\nlet b = 456 // SyntaxError: Identifier 'b' has already been declared\n```\n\n### 2.블록 레벨 스코프\n\n- `함수 레벨 스코프` : var 키워드로 선언한 변수는 함수 내부에서만 선언한 변수는 지역 스코프로 인정한다. <br>\n- `블록 레벨 스코프` : let 키워드로 선언한 변수는 모든 코드 블록 (함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정한다.\n\n**예제 5**\n\n```js\n// 전역 변수\nlet a = 1\n\n{\n  // 지역 변수\n  let a = 2\n  let b = 3\n}\n\nconsole.log(a) // 1\nconsole.log(b) // ReferenceError: b is not defined\n```\n\n전역에서 선언된 a 변수와 코드 블록 내에서 선언된 a는 다른 변수다. 코드 블록 내에서 선언한 a와 b는 지역 변수다. 따라서 전역에서는 b를 참조할 수 없기때문에 참조에러 (ReferenceError)가 뜬다.\n\n### 3. 변수 호이스팅\n\nlet으로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다. (실제론 동작함)\n\n**예제 6**\n\n```js\nconsole.log(foo) // ReferenceError: foo is not defined\nlet foo\n```\n\nlet으로 선언한 변수를 선언문 이전에 참조하면 참조 에러가 발생한다.<br>\nvar로 선언한 변수는\n\n1. 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 **선언과 초기화가 함께 진행**\n2. 초기화 단계에서 **변수에 접근하면 undefined를 반환**\n3. 변수 선언문제 도달했을때 값이 할당\n4. 변수에 접근하면 할당값 반환\n\nlet으로 선언한 변수는\n\n1. **선언과 초기화가 분리되어 진행**\n2. 자바스크립트 엔진에 의해 암묵적으로 선언 단계 실행\n3. **변수에 접근하면 참조에러(ReferenceError) 반환**\n4. 초기화는 변수 선언문에 도달했을때 실행\n5. 이후 변수에 접근 가능\n\n### 4. 전역 객체와 let\n\nvar로 선언한 변수의 암묵적 전역은 전역객체 window의 프로퍼티가 된다.\n\n**예제 7**\n\n```js\nvar a = 1\nfunction b() {}\n\n// var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티다.\nconsole.log(window.a) // 1\n// window의 프로퍼티는 전역 변수처럼 사용할 수 있다.\nconsole.log(a) // 1\n\n// 함수 선언문으로 정의한 전역 함수는 전역 객체 window의 프로퍼티다.\nconsole.log(window.b) // f foo() {}\n// window의 프로퍼티는 전역 변수처럼 사용할 수 있다.\nconsole.log(b) // f foo() {}\n\nlet x = 1\n\n// let, const 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다.\nconsole.log(window.x) // undefined\nconsole.log(x) // 1\n```\n\nlet으로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. window.변수명과 같이 접근할 수 없다.\n\n## const 키워드\n\nconst는 상수(constant)를 선언하기 위해 사용한다. let 키워드와 비슷하다. <br>\n**상수? 재할당이 금지된 변수**\n\n### 1. 선언과 초기화\n\nconst 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.\n\n**예제 8**\n\n```js\nconst a = 1;\n\n// 초기화를 하지 않는다면 에러가 발생\nconst b; // SyntaxError: Missing initializer in const declaration\n```\n\nconst 키워드로 선언한 변수는 let과 마찬가지로 `블록 레벨 스코프`를 가지며, 호이스팅이 발생하지 않는 것처럼 동작한다.\n\n### 2. 재할당 금지\n\nvar나 let으로 선언한 변수를 재할당이 가능하나 **const로 선언한 변수는 재할당이 금지된다.**\n\n**예제 9**\n\n```js\nconst a = 1\na = 2 // TypeError: Assignment to constant variable.\n```\n\n### 3. 상수\n\n상수는 재할당이 금지되며 상수의 상태 유지와 가독성, 유지보수를 위해 적극적으로 사용하기를 권장한다.\n\n**예제 10**\n\n```js\n/* let을 사용했을 때 */\n// 세전 가격\nlet preTaxPrice = 100\n// 세후 가격\nlet afterTaxPrice = preTaxPrice + preTaxPrice * 0.1\n\nconsole.log(afterTaxPrice) // 110\n\n/* const를 사용했을 때 */\nconst TAX_RATE = 0.1 // 세율을 의미하는 0.1은 변경할 수 없다.\nlet preTaxPrice = 100\nlet afterTaxPrice = preTaxPrice + preTaxPrice * TAX_RATE\n\nconsole.log(afterTaxPrice) // 100\n```\n\nlet을 사용한 코드는\n\n- 0.1은 어떤 의미로 사용했는지 명확히 알기 어렵기 때문에 가독성이 좋지 않다. <br>\n- 세율을 의미하는 0.1은 쉽게 바뀌지 않는 값이다. → 고정된 값\n\nconst를 사용한 코드로 바꾸면\n\n- 세율을 의미하는 TAX_RATE변수는 변경할 수 없는 값으로 할당된 값을 변경할 수 없다.\n- 프로그램 전체에서 공통적으로 사용 → 나중에 세율이 변경되면 값만 바꾼다 → **유지보수성 향상**\n\n### 4. const 키워드와 객체\n\nconst로 선언된 변수에 값을 변경할 수 없다. 하지만 const로 선언된 변수에 객체가 할당된 경우에는 값을 변경할 수 있다. <br>\n(변경 가능한 값인 객체는 재할당 없이도 직접 변경이 가능하기 때문에)\n\n**예제 11**\n\n```js\nconst person = {\n  age: 33,\n}\nperson.age = 32\n\nconsole.log(person) // {age: 32}\n```\n\n**const는 재할당은 금지할 뿐 `불변`을 의미하지 않는다.** 새로운 값을 재할당 하는것은 불가능 하지만 프로퍼티 동적 생성, 삭제, 값의 변경 등을 토해 객체를 변경하는 것은 가능하다.\n\n## var, let, const\n\n- ES6를 사용한다면 var는 사용하지 않는다.\n- 재할당이 필요한 경우 let을 사용한다. (스코프는 최대한 좁게)\n- 값이 변경되지 않을 경우 const를 사용한다.\n- **되도록 const를 사용한다.**\n\n<table>\n    <thead>\n        <tr>\n            <th></th>\n            <th>var</th>\n            <th>let</th>\n            <th>const</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>변수 재할당</th>\n            <td>O</td>\n            <td>O</td>\n            <td>X</td>\n        </tr>\n        <tr>\n          <th>스코프</th>\n            <td>함수 레벨 스코프</td>\n            <td>블록 레벨 스코프</td>\n            <td>블록 레벨 스코프</td>\n        </tr>\n        <tr>\n          <th>호이스팅</th>\n            <td>O</td>\n            <td>O (발생하지 않는것처럼 동작)</td>\n            <td>O (발생하지 않는것처럼 동작)</td>\n        </tr>\n        <tr>\n          <th>전역객체 프로퍼티 여부</th>\n            <td>O</td>\n            <td>X</td>\n            <td>X</td>\n        </tr>\n    </tbody>\n</table>\n"},{"excerpt":"개인 포트폴리오 프로젝트 중 하나를 firebase를 이용하여 채팅앱을 만들었다. firebase를 이용하여 만들었으니 배포까지 해보자. google firebase에서 프로젝트를 만들어 앱에 연결된 상태이고 build까지 완료된 상태다. 1. CLI 설치 및 firebase 로그인 터미널 창에서 위 코드를 입력하고 로그인을 하면 가 뜨면 Y를 입력하고 …","fields":{"slug":"/2021-10-27-react-firebase/"},"frontmatter":{"date":"October 27, 2021","title":"[react] firebase 프로젝트 배포하기","tags":["react","firebase"]},"rawMarkdownBody":"\n개인 포트폴리오 프로젝트 중 하나를 firebase를 이용하여 채팅앱을 만들었다. firebase를 이용하여 만들었으니 배포까지 해보자. <a href=\"https://firebase.google.com/\" target=\"_blank\">google firebase</a>에서 프로젝트를 만들어 앱에 연결된 상태이고 **build까지 완료**된 상태다.\n\n## 1. CLI 설치 및 firebase 로그인\n\n```js\n// CLI 설치\nnpm install -g firebase-tools\nyarn add firebase-tools\n\n// firebase 로그인\nfirebase login\n```\n\n터미널 창에서 위 코드를 입력하고 로그인을 하면 `Allow Firebase to collect CLI usage and error reporting information?`가 뜨면 Y를 입력하고 구글 계정을 선택하여 로그인한다.\n\n![](img/firebase1.png)\n\n로그인이 완료되면 Success! 문구가 뜬다.\n![](img/firebase2.png)\n\n## 2. firebase 설정하기\n\n```js\nfirebase init\n```\n\n설정에서 Hosting을 선택하고 **스페이스** 누르고 엔터(선택)\n\n![](img/firebase2.jpg)\n\n이미 프로젝트를 생성했기 때문에 `Use an existing project`를 선택했다.\n\n![](img/firebase4.jpg)\n\n`What do you want to use as your public directory?` <br>\n&nbsp; → 미리 build한 폴더의 index.html파일을 사용하기 위해 **build**를 입력한다.<br>\n\n`Configure as a single-page app (rewrite all urls to /index.html)?` <br>\n&nbsp; → SPA일 경우 모든 url을 index.html으로 다시 작성하겠냐는 질문같은데 나는 리액트를 이용했기 때문에 **Y**를 입력했다.<br>\n\n`Set up automatic builds and deploys with Github?` <br>\n&nbsp; → 자동적으로 Github을 배포할거냐는 질문같은데 나는 N를 입력했다.<br>\n\n`File build/index.html already exists. Overwrite?` <br>\n&nbsp; → 이미 있는 index.html을 덮어쓰겠냐는 질문인데 나는 Y를 입력했다. <br><br>\n\n자신의 상황에 맞게 설정하면 된다. firebase 설치완료가 뜨고 firebase.json파일과 .firebaserc 생성됐다면 설정이 완료된 것이다.\n\n![](img/firebase5.jpg)\n\n## 3. firebase 배포하기\n\n```js\nfirebase deploy\n```\n\nDeploy complete가 완료되면 자신의 firebase URL이 나타난다.\n\n![](img/firebase6.jpg)\n\n접속하면 정상적으로 작동한다.\n![](img/firebase7.jpg)\n\n## \\*Firebase Hosting Setup Complete이 뜬다면?\n\n![](img/firebase9.jpg)\n난 처음에 Firebase Hosting Setup Complete이 계속 떴었는데 `What do you want to use as your public directory?`에서 public을 입력하라는 글을 보고 따라했던게 원인인 것 같다. build로 입력하고 배포하니 정상적으로 작동했다.\n\n**\\*알 수 없는 오류발생** <br>\n로컬 파일에서는 채팅을 보내면 정상적으로 작동하는데 배포한 프로젝트에서는 저부분에 오류가 발생했다.\n\n![로컬 화면 - 정상작동](img/firebase8-1.jpg)\n\n![프로젝트 화면 - 오류발생](img/firebase8-2.jpg)\n\n구글 콘솔에서 뜨는 URL(<a href=\"https://reactjs.org/docs/error-decoder.html/?invariant=152&args[]=Component\" target=\"_blank\">Error Decoder</a>)을 살펴봐도 왜 오류가 뜨는지 알수가 없어 저부분은 해결하지 못하고 있다. 😭 (제일 중요한 페이지인데) 혹시 원인을 아신다면 댓글 부탁드립니다. 😭😭\n"},{"excerpt":"최근 jekyll로 사용하던 블로그를 gatsby로 바꾸었다. \n처음에 jekyll을 선택했었던 이유를 github으로 시작할 생각이었고 테마가 다양했던 jekyll을 선택했었다. Jeykll에서 Gatsby로 이전한 이유는? 가장 큰 이유는 Jeykll은 Ruby로 만들어졌기 때문에 JS를 주언어로 사용하는 필자에게 어려우면서 생소했다. 프론트엔드 개발…","fields":{"slug":"/2021-10-26-gaysby/"},"frontmatter":{"date":"October 26, 2021","title":"[gatsby] Google Search Console과 Analytics 추가하기","tags":["gatsby"]},"rawMarkdownBody":"\n최근 jekyll로 사용하던 블로그를 gatsby로 바꾸었다. <br>\n처음에 jekyll을 선택했었던 이유를 github으로 시작할 생각이었고 테마가 다양했던 jekyll을 선택했었다.\n\n## Jeykll에서 Gatsby로 이전한 이유는?\n\n가장 큰 이유는 Jeykll은 Ruby로 만들어졌기 때문에 JS를 주언어로 사용하는 필자에게 어려우면서 생소했다. 프론트엔드 개발자가 많이 쓰는 gatsby는 react를 사용하는 나에게 쉬우면서도 재밌게 다가왔고 npm 플러그인을 쉽게 추가할 수 있어 다양한 기능을 다루기 수월했기 때문에 블로그 이전을 감행했다. (또한 전보다 많아진 테마도 마음에 들었다.)\n\n나는 zoomkoding님의 <a href=\"https://github.com/zoomKoding/zoomkoding-gatsby-blog\" target=\"_blank\">zoomkoding-gatsby-blog</a>테마를 사용하여 블로그를 개설했다. <br>\n깃허브 테마는 심플한 테마가 많지만 zoomkoding님의 테마는 블랙/화이트 모드 선택 및 과하지 않게 동적인 요소들이 마음에 들어 이 테마로 블로그를 개설했다.\n\n## Google Search Console에 gatsby 블로그 등록하기\n\n1. <a href=\"https://search.google.com/search-console/about\" target=\"_blank\">google search console </a> 사이트에 접속한다.\n2. 속성 추가 → URL 접두어 → 소유권 확인 (HTML 태그 : react-helmet을 이용해 meta 등록 )\n   <br><br>\n   ![](img/search.png)\n   <br>\n3. gatsby-plugin-sitemap 설치\n\n```js\nnpm i gatsby-plugin-sitemap\nyarn add gatsby-plugin-sitemap\n```\n\n내가 설치한 테마의 gatsby 버전이 낮은편이라 yarn add gatsby-plugin-sitemap을 입력했을때 높은버전의 플러그인이 설치되었기 때문에 warning 경고가 떴었다. 자신의 gatsby와 호환되는 버전의 플러그인을 설치하자!\n\n![](img/package.png)\n\n4. gatsby-config.js 파일에 `gatsby-plugin-sitemap`추가한다.\n\n![](img/serach4.png)\n\n5. build (build를 해야 sitemap.xml 파일이 생성된다.)\n\n```js\nyarn build (or gatsby build)\n```\n\n6. build가 끝나면 로컬 서버를 실행한다.\n\n```js\nyarn develop (or gatsby develop)\n```\n\nlocalhost:8000/sitemap.xml에 접속하면 다음 화면과 같이 xml파일이 생성된 걸 확인할 수 있다.\n\n![](img/search2.png)\n\n7. 사이트맵 추가\n\n```js\nyarn deploy (or gatsby deploy)\n```\n\ngatsby 변경사항을 사이트에 업로드 한다. github 페이지에서 sitemap.xml이 제대로 보여진다고 Google Search Console에서 새 sitemap.xml을 제출한다.\n\n![](img/search3.png)\n\n## gatsby 블로그에 Google Analytics 추적코드 심기\n\n1. <a href=\"https://analytics.google.com/\" target=\"_blank\">구글 애널리틱스</a> 계정 만들기\n2. 속성에 내 블로그 정보 추가하기\n3. gatsby-plugin-gtag 설치\n\n```js\nnpm i gatsby-plugin-gtag\nyarn add gatsby-plugin-gtag\n```\n\n4. gatsby-config.js 파일에 `gatsby-plugin-gtag` 옵션을 추가한다.\n\n![](img/analytics1.png)\n\n<a href=\"https://janeljs.github.io/blog/google-analytics/\" target=\"_blank\">jane's PS님의 블로그</a>를 확인해 보면 추적이 되지 않을 때 gatsby-plugin-gtag를 플러그인 최상단에 배치하라고 되어있어 처음부터 최상단에 위치시켜 놓으면 편한다..\n\n```js\n{\n   resolve: `gatsby-plugin-gtag`,\n      options: {\n         trackingId: `G-XXXXXXXXXX`, // 측정 ID\n         head: false, // head에 트래킹스크립트 넣고 싶다면 true로 설정\n         anonymize: true,\n      }\n   },\n},\n```\n\n5. 동작 확인하기\n\n```js\nyarn build (or gatsby build)\nyarn deploy (or gatsby deploy)\n```\n\ngatsby 변경사항을 사이트에 업로드 한 뒤 제대로 작동하는 지 확인한다.\n\n![](img/analytics2.png)\n\n**블로그를 이전하면서 애널리틱스가 작동하지 않고 sitemap.xml이 제대로 생성되지 않아 한동안 방문자 추적이 전혀되지 않았다. 앞으로 미리미리 구글링 하면서 문제를 해결해야 겠다. 한달정도 방치해놨던 과거의 나야 반성하자**\n"},{"excerpt":"클로저(closure)는 자바스크립트 고유의 개념이 아니라 함수형 프로그래밍 언어에서 등장하는 보편적인 특성이다. 개념이 아니기 때문에 ECMAScript 명세서에도 클로저의 정의를 다루지 않고 있어 클로저에 대한 다양한 정의와 설명이 존재한다.  - 더글라스 크록포드 (자바스크립트 핵심 가이드)  - 에딘 브라운 (러닝 자바스크립트)  - 존 레식 (자…","fields":{"slug":"/2021-09-21-closure/"},"frontmatter":{"date":"September 21, 2021","title":"[javascript] closure (클로저)","tags":["javascript"]},"rawMarkdownBody":"\n<img src=\"https://i.pinimg.com/originals/f5/69/ae/f569aef9a09bec7ca74f0dcd228a5343.jpg\" alt=\"\">\n<small class=\"from\" style=\"text-align:right;\">사진 출처 : <a href=\"https://www.pinterest.co.kr/pin/439734351121493066/\" target=\"_blank\">https://www.pinterest.co.kr/pin/439734351121493066/</a></small><br>\n\n클로저(closure)는 자바스크립트 고유의 개념이 아니라 함수형 프로그래밍 언어에서 등장하는 보편적인 특성이다. 개념이 아니기 때문에 ECMAScript 명세서에도 클로저의 정의를 다루지 않고 있어 클로저에 대한 다양한 정의와 설명이 존재한다.<br>\n\n> _`자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수` - 더글라스 크록포드 (자바스크립트 핵심 가이드) <br>`함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것` - 에딘 브라운 (러닝 자바스크립트)<br> `함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수` - 존 레식 (자바스크립트 닌자 비급)<br> `이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수` - 송형주 고형준 (인사이드 자바스크립트)<br> `자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합` - 에릭 프리먼 (Head First Javascript programming)<br> `로컬 변수를 참조하고 있는 함수 내의 함수` - 야마다 요시히로 (자바스크립트 마스터북)<br> `자신이 생성되 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 대 사용할 변수들만을 기억하여 유지시키는 함수` - 유인동 (함수형 자바스크립트 프로그래밍)<br> `클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다` - MDN_ <br>\n\n이처럼 많은 설명과 정의가 존재하지만 막상 그 의미를 이해하기는 쉽지않다. MDN에서는\n\n<div class=\"blockquote\">\n    \"A closure is the combination of a function and the lexical enviroment within which that function was declared\" <br>\n</div>\n<p>라고 소개한다. 직역하면 \"클로저는 함수와 그 함수가 선언될 당시의 lexical enviroment의 상호관계에 따른 현상\" 정도가 된다.</p>\n\n![](img/closure.png)\n\n그림에서처럼 Outer내부에서 선언된 내부함수 Inner의 실행 컨텍스트가 활성화된 시점에는 Inner의 outerEnvironmentReference가 참조하는 대상인 Outer의 LexicalEnviroment에 접근이 가능하다. Outer함수에서는 Inner함수에 선언한 변수에 접근할 수 없지만 Inner함수에서는 Outer에서 선언한 변수에 접근이 가능하다. (스코프 체인) Inner함수에서 Outer함수의 변수를 참조하는 경우에 한해서 LexicalEnviroment의 상호관계에 의미가 생긴다.\n\n**예제 1**\n\n```js\n    var outer = function() {\n        var a = 1;\n        var inner = function() {\n            console.log(++a;)\n        };\n        inner();\n    }\n    outer();   //  2\n```\n\n<p>위의 예제에서 outer함수에서 변수 a를 선언했고, outer함수의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력한다. </p>\n\n1. inner 함수 내부에서는 변수 a를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못한다.\n2. inner 함수의 outerEnvironmentReference에 지정된 상위 컨텍스트의 outer의 LexicalEnviroment에 접근해서 a를 찾는다.\n3. console.log(++a)가 실행되면서 2가 출력된다.\n4. outer 함수의 실행컨텍스트가 종료되면 LexicalEnviroment에 저장된 식별자들 (a, inner)에 대한 참조를 지운다.\n5. 자신을 참조하는 변수가 하나도 없게 되면서 가비지 컬렉터의 수집 대상이 된다.\n\n**예제 2**\n\n```js\nvar outer = function () {\n  var a = 1\n  var inner = function () {\n    return ++a\n  }\n  return inner\n}\nvar outer2 = outer()\nconsole.log(outer2()) //  2\nconsole.log(outer2()) //  3\n```\n\n예제2는 예제1과 다르게 inner 함수 자체를 반환했다.\n\n1. outer 함수의 실행 컨텍스트가 종료될 때 outer2 변수는 outer의 실행 결과의 inner 함수를 참조한다.\n2. console.log(outer2())를 호출하면 반환된 함수인 inner가 실행된다.\n3. inner 함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없다. (실행종료 상태이기 때문에)\n4. inner 함수는 내부 함수이기 때문에 outer-EnvironmentReference에는 inner 함수가 선언된 위치의 LexicalEnviroment가(outer 함수의 LexicalEnviroment가) 참조복사 된다.\n5. 스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 값인 2를 반환하고, inner 함수의 실행 컨텍스트가 종료된다.\n6. 다시 console.log(outer2())를 호출하면 a의 값을 증가시킨 값인 3을 반환한다.\n\n\\*inner 함수의 실행 시점에는 outer 함수는 이미 실행 종료된 상태이지만 outer함수의 LexicalEnviroment에 접근이 가능하다. 그 이유는 가비지 컬렉터가 어떤 값을 참조하는 변수가 있다면 수집 대상에 포함하지 않기 때문이다.\n\n종합해보면 **클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상**을 말한다. (가비지 컬렉팅되지 않기 때문에)\n\n## 클로저와 메모리 관리\n\n'메모리 누수'라는 표현은 어떤 값의 참조 카운트가 0이 되지 않아 가비지 컬렉터의 수거 대상이 되지 않는 경우에 발생한다. 클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수가 메모리를 소모하도록 함으로써 발생한다. 그 필요성이 사라진 시점에 참조 카운트를 0으로 만들어 주면 가비지 컬렉터가 수거하고 메모리 누수를 막을 수 있다. (참조 카운트를 0으로 만드는 방법은 식별자에 기본형 데이터(null, undefined)를 할당하면 된다.)\n\n```js\n// setInterval에 의한 클로저의 메모리 해제\n;(function () {\n  var a = 0\n  var intervalId = null\n  var inner = function () {\n    if (++a >= 10) {\n      clearInterval(intervalId)\n      inner = null // inner 식별자의 함수 참조를 끊음\n    }\n    console.log(a)\n  }\n  intervalId = setInterval(inner, 1000)\n})()\n```\n\n## 클로저 활용방법\n\n1. 콜백 함수 내부에서 외부 데이터를 사용하고자 할 때\n2. 접근 권한 제어(정보은닉)\n3. 부분 적용 함수\n4. 커링 함수\n\n<small class=\"from add\">참고 : 코어 자바스크립트(정재남)</small><br>\n"},{"excerpt":"호이스팅(hoisting)이란 '끌어올리다'라는 의미의 hoist + ing를 붙여 만들어졌으며 의미 그대로 끌어올리는 행위로 작동한다. 주로 var로 선언된 변수의 선언문을 코드의 최상단으로 끌어올인다. (변수 정보를 수집하는 과정을 이해하기 쉬운 방법으로 대체한 가상의 개념으로, 자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간…","fields":{"slug":"/2021-09-21-hoisting/"},"frontmatter":{"date":"September 21, 2021","title":"[javascript] hoisting (호이스팅)","tags":["javascript"]},"rawMarkdownBody":"\n호이스팅(hoisting)이란 '끌어올리다'라는 의미의 hoist + ing를 붙여 만들어졌으며 의미 그대로 끌어올리는 행위로 작동한다. 주로 var로 선언된 변수의 선언문을 코드의 최상단으로 끌어올인다. (변수 정보를 수집하는 과정을 이해하기 쉬운 방법으로 대체한 가상의 개념으로, 자바스크립트 엔진이 실제로 끌어올리지는 않지만 편의상 끌어올린 것으로 간주된다.)\n\n## 호이스팅\n\n실행컨텍스트에 담기는 LexicalEnvironment의 내부는 environmenRecord와 outer-EnvironmenReference로 구성되는데 environmenRecord는 호이스팅과 관련이 있다.\n\n- **environmenRecord**: 현재 컨텍스트와 관련된 코드의 식별자 정보를 <u>순서대로</u> 저장<br>\n  (식별자: 컨텍스트를 구성하는 함수에 지정된 매개변수, 함수자체, var로 선언된 변수의 식별자 등)\n\n식별자 정보를 수집하는 과정을 마쳐도 코드가 실행되기 전이기 때문에 실행컨텍스트가 관여한 코드들은 실행되기 전의 상태이다. (실행전이지만 수집과정을 거쳤기 때문에 해당 환경의 변수명을 모두 알고 있다.)\n\n1. 실행컨텍스트의 LexicalEnvironment의 내부 environmenRecord가 처음부터 끝까지 순서대로 식별자를 수집한다.\n2. 코드가 실행되기 전이지만 1의 수집과정을 거쳤기 때문에 자바스크립트 엔진은 해당 환경의 변수명을 모두 알고 있다. <br>(= 식별자들을 최상단으로 끌어올려놓은 다음 코드를 실행한다고 간주)\n\n## 호이스팅 규칙\n\n**\\*변수명**과 **함수 전체의 정보**를 위로 끌어올리고 할당과정은 원래 자리에 남겨둔다.\n\n```js\nfunction a() {\n  console.log(b) // ƒ b() { }\n  var b = 111 // ← 수집대상 1\n  console.log(b) // 111\n  function b() {\n    // ← 수집대상 2\n    console.log(b) // 111\n  }\n}\na()\n```\n\na함수를 실행하는 순간 a 함수의 실행 컨텍스트가 생성된다. (변수명과 함수가 위로 끌어올려진다.) <br>\n위의 코드에서는 수집대상 1과 2를 순서대로 끌어올리고 다음과 같은 형태로 동작한다.\n\n```js\n// 호이스팅 완료 (실제 변환과정이 아닌 쉽게 이해하기 위한 예시 코드)\nfunction a() {\n  var b\n  function b() {}\n\n  console.log(b) //  ƒ b() { }\n  b = 111\n  console.log(b) //  111\n  console.log(b) //  111\n}\na()\n```\n\n1. 수집대상 1의 변수명 b와 함수 b를 위로 끌어올려 선언한다.\n2. 다시 변수 b를 선언하고 함수 b를 선언된 변수 b에 할당한다.\n3. 첫번째 console은 변수 b에 할당된 함수 b를 출력한다. (\\*나중에 선언된 111이 아닌 함수 b가 처음 출력된다)\n4. b에 숫자 111을 할당한다.\n5. 두번째, 세번째 console은 마지막으로 할당된 숫자 111을 출력한다.\n\n## 함수선언문과 함수 표현식 호이스팅\n\n`함수 선언문(function declaration)`은 function 정의부만 존재하고 별도의 할당 명령이 없는 것을 의미하고, `함수 표현식(function expression)`은 정의한 function을 별도의 변수에 할당하는 것을 말한다.\n\n```js\nconsole.log(sum(1, 2)) //  3\nconsole.log(multiply(3, 4)) //  Uncaught TypeError: multiply is not a function\n// 1. 함수 선언문\nfunction sum(a, b) {\n  return a + b\n}\n// 2. 함수 표현식\nvar multiply = function (a, b) {\n  return a * b\n}\n```\n\n함수가 선언된 후에야 호출 할 수 있기 때문에 예시에서 함수 표현식으로 정의된 multiply(3, 4)를 호출하면 'Uncaught TypeError' 에러가 뜬다. 호이스팅 된 상황을 아래의 코드로 재현해보면,\n\n```js\n// 호이스팅 완료\n\n/* 함수 선언문 전체가 끌어올려진다.*/\nfunction sum(a, b) {\n  return a + b\n}\n/* 함수 표현식의 변수만 끌어올려진다. */\nvar multiply\nconsole.log(sum(1, 2)) //  3\n\n/* 변수 multiply만 선언되었기 때문에 TypeError가 발생한다. */\nconsole.log(multiply(3, 4)) //  Uncaught TypeError: multiply is not a function\n\nmultiply = function (a, b) {\n  return a * b\n}\n```\n\n**\\*다수의 개발자들이 협업할 때, 각각의 개발자가 함수 선언문을 이용해서 동일한 함수명으로 개발하였다면 호이스팅으로 인한 문제가 발생한다. (코드가 덮어씌워지는 문제가 발생한다.) 따라서 여러명이 협업할 때 함수는 함수 표현식을 이용하여 개발하도록 해야한다.** <br><br>\n\n<small class=\"from add\">참고 : 코어 자바스크립트(정재남)</small>\n"},{"excerpt":"1. 실행 컨텍스트 실행 컨텍스트(execution context)는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체로 호이스팅, this 바인딩 등의 정보가 담긴다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보(Lexical Environmen)를 구성하고, this 값을 설정하는 등…","fields":{"slug":"/2021-09-21-scope/"},"frontmatter":{"date":"September 21, 2021","title":"[javascript] execution context, scope (실행 컨텍스트, 스코프)","tags":["javascript"]},"rawMarkdownBody":"\n## 1. 실행 컨텍스트\n\n실행 컨텍스트(execution context)는 **실행할 코드에 제공할 환경 정보들을 모아놓은 객체**로 호이스팅, this 바인딩 등의 정보가 담긴다. 자바스크립트는 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올리고(호이스팅), 외부 환경 정보(Lexical Environmen)를 구성하고, this 값을 설정하는 등의 동작을 수행한다.\n\n- 동일한 환경의 코드 실행 시 필요한 환경 정보를 모아 컨텍스트를 구성\n- 콜 스택(call stack)에 쌓아올림 - 스택구조\n- 컨텍스트와 관련있는 가장 위의 코드를 실행 (순서 보장)\n\n<img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/300px-Data_stack.svg.png\">\n<small class=\"from\">이미지 출처 : <a href=\"https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D\" target=\"_blank\">위키백과</a></small>\n\n<br>흔히 실행 컨텍스트를 생성하는 방법은 함수를 실행하는 방법이다. (= **함수가 실행될 때** 실행 컨텍스트가 만들어진다.)\n\n```js\nvar a = 1\nfunction outer() {\n  function inner() {\n    console.log(a) // undefined\n    var a = 3\n  }\n  inner()\n  console.log(a) // 1\n}\nouter()\nconsole.log(a) // 1\n```\n\n![이미지 출처 : 코어 자바스크립트(정재남)](img/scope.jpg)\n\n1. 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화 되며 콜스택에 담긴다.\n2. outer() 함수가 호출되면 자바스크립트 엔진이 outer에 대한 환경 정보를 수집해서 outer 실행 컨텍스트를 생성하고 콜스택에 담는다.\n3. outer의 실행컨텍스트가 콜스택에서 최상단에 위치해 있으며 전역 컨텍스트에 관련된 실행은 일시 중지된다.\n4. outer 실행 컨텍스트와 관련된 코드 내부 코드들이 순차적으로 실행된다.\n5. outer내부의 inner()로 inner함수가 실행되면서 inner함수의 실행 컨텍스트가 콜스택의 가장 위에 담긴다.\n6. outer 컨텍스트에 관련된 실행은 일시 중지된다.\n7. inner 함수 내부의 코드들이 순차적으로 실행된다.\n8. inner 내부의 console.log(a)를 출력하고 나면 inner 함수의 실행이 종료되면서 inner 실행 컨텍스트가 콜 스택에서 제거된다.\n9. outer의 컨텍스트가 중단된 다음 줄부터 이어서 실행된다.\n10. outer의 console.log(a)를 출력하고 나면 outer 함수의 실행이 종료되면서 outer 실행 컨텍스트가 콜 스택에서 제거된다.\n11. 전역 컨텍스트의 console.log(a)출력하고 나면 전역 공간에는 실행할 코드가 없기때문에 전역 컨텍스트가 제거된다.\n12. 콜스택에는 아무것도 남지 않으며 종료된다.\n    <br><br>\n\n**\\*한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점이다. 실행 컨텍스트에 담기는 객체는 개발자가 코드를 통해 확인 할 수 없으며 다음과 같은 정보들이 담긴다.**\n\n1. **VariableEnvironment** : 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음\n2. **LexicalEnvironment** : 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨 - `호이스팅`\n3. **ThisBinding** : this 식별자가 바라봐야 할 대상 객체\n   <br><br>\n\n## 2. 스코프\n\n스코프(scope)는 사전적 의미로 `범위`라는 뜻을 가지고 있다. 의미 그대로 식별자에 대한 유효범위를 뜻한다. 자바스크립트는 **전역 스코프(global scope)**와 **지역 스코프(local scope)** 2가지 타입을 가지고 있다.\n\n```js\n/* 예제 1 */\nvar a = 1\nfunction scope() {\n  // 함수 스코프\n  var b = 2\n  console.log(a) // 1\n  console.log(b) // 2\n}\nconsole.log(a) // 1\nconsole.log(b) // b is not defined\n```\n\nscope함수의 외부에서 선언한 전역변수 a는 scope함수의 외부뿐 아니라 함수 내부에서도 접근이 가능하다. scope함수의 내부에서 선언한 변수 b는 오직 scope함수의 내부에서만 접근할 수 있다. 변수 a를 <u>전역 스코프(global scope)</u>, b를 <u>지역 스코프(local scope)</u>라고 한다.<br>\n위의 예시처럼 전역 스코프는 어느곳에서 호출해도 해당 변수에 접근이 가능하지만, 지역 스코프는 선언된 함수의 내부에서만 접근이 가능하다.\n\n```js\n/* 예제 2 */\nvar a = 1\nvar truth = true\nif (truth) {\n  var b = 2\n  console.log(a) // 1\n  console.log(b) // 2\n}\nconsole.log(a) // 1\nconsole.log(b) // 2    ← ???\n```\n\n그런데 예제1과 다르게 예제 2에서는 if문 안에서 정의한 변수b가 외부에서 접근이 가능하다. 위의 예제와의 차이점은 뭘까? <br>\n그건 예제 1은 **함수 스코프 (function scope)**이고 예제 2는 **블록 스코프 (block scope)**라는 점이다. ES5까지의 자바스크립트는 전역공간을 제외하면 오직 <u>함수에 의해서</u> 스코프가 생성된다. 블록 스코프인 if문에서는 변수를 선언하면 전역변수가 되기 때문에 예제 2에서의 변수 b는 전역 스코프라고 할 수 있다. 즉 스코프는 **함수가 정의될 때** 결정된다.\n\n**\\*ES6부터는 블록에 의한 스코프가 가능해졌다. 블록스코프 내부에서 var가 아닌 let, const변수를 사용하거나 strict 모드를 이용하면 블록 스코프 사용이 가능하다.**\n이러한 '변수의 유효범위'를 안에서부터 바깥으로 차례로 검색해나가는 것을 `스코프 체인(scope chain)`이라고 한다.\n\n## 3. 스코프 체인\n\n스코프가 [[scope]] 프로퍼티로 각 함수 내에서 연결리스트 형식으로 관리되는데 이 스코프간의 상하관계를 **스코프 체인**이라고 한다. LexicalEnvironment의 두 번째 수집 자료인 outerEnvironmentReference는 현재 호출된 함수가 선언될 당시(과거)의 LexicalEnvironment를 참조한다.\n\n```js\nvar a = 1\nfunction one() {\n  var b = 2\n  function two() {\n    var c = 3\n    function three() {\n      console.log(a) // 1\n      console.log(b) // 2\n      console.log(c) // 3\n    }\n    three()\n  }\n  two()\n}\none()\n```\n\none함수 내부에 two함수를 선언하고 또 그 내부에 three함수를 선언한 경우,\n\n1. three함수의 outerEnvironmentReference는 two함수의 LexicalEnvironment를 참조한다.\n2. two함수의 outerEnvironmentReference는 one함수의 LexicalEnvironment를 참조한다.\n3. one함수의 outerEnvironmentReference는 전역 컨텍스트의 LexicalEnvironment를 참조한다.\n\n이처럼 outerEnvironmentReference는 연결리스트 형태를 띄며 '선언 시점의 LexicalEnvironment'를 계속 찾아 올라간다. 세 함수의 outerEnvironmentReference는 오직 자신이 선언된 시점의 LexicalEnvironment만 참조하고 있기 때문에 가장 가까운 요소부터 위로 차례대로만 접근할 수 있다. <br>\n이런 구조적 특성 덕분에 여러 스코프에서 동일한 식별자를 선언한 경우에는 **무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능**하다.\n\n```js\nvar a = 1\nfunction outer() {\n  var b = 2\n  function inner() {\n    console.log(b) // 2\n    console.dir(inner)\n  }\n  inner()\n}\nouter()\n```\n\n크롬 브라우저에서 스코프 체인 중 현재 실행 컨텍스트를 제외한 상위 스코프 정보들을 개발자 도구 console을 통해 간단하게 확인할 수 있다. <br>\n위의 예제에서 console.dir(inner)로 출력한 결과물은 다음과 같다.\n\n![](img/scope2.jpg) <br>\n\ninner함수의 상위 스코프 정보들을 확인할 수 있다. inner함수에는 outer함수의 LexicalEnvironment가 담겨있는데 outer함수에는 LexicalEnvironment가 담겨있다. 때문에 체인을 통해 inner함수에서 전역 컨텍스트까지 접근할 수 있는것을 확인 할 수 있다.<br>\n\n<small class=\"from add\">참고 : 코어 자바스크립트(정재남), <a href=\"https://developer.mozilla.org/ko/\" target=\"_blank\">MDN</a></small><br>\n"},{"excerpt":"1. assign() 앞서 설명했듯이 target에 pet1이 지정되어 있기때문에 target객체인 pet1에 변화가 생겼다. \n재귀적인 결합을 지원하지 않기때문에 description이 통째로 교체된다(birth → food)는 점에 주의한다.\n만약, sources객체들에 영향을 끼치고 싶지 않다면, 다음과 같이 target에 {}를 지정해주면 빈 객체…","fields":{"slug":"/2021-09-21-object/"},"frontmatter":{"date":"September 21, 2021","title":"[javascript] Object.assign() & Object.create()","tags":["javascript"]},"rawMarkdownBody":"\n<table>\n    <thead>\n        <tr>\n            <th>메서드 이름</th>\n            <th>설명</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>Object.assign()</th>\n            <td>하나 이상의 객체를 결합하여 지정한 객체에 복사한다.</td>\n        </tr>\n        <tr>\n            <th>Object.create()</th>\n            <td>지정한 속성을 갖는 새로운 객체를 생성한다. </td>\n        </tr>\n    </tbody>\n</table>\n\n## 1. assign()\n\n<div class=\"blockquote\">\n    Object.assign(target, sources, ...)\n</div>  \n<p>-&nbsp;target: 대상객체 &nbsp;-&nbsp;sources: 복사할 원본 <br>\nsources...로 지정된 객체의 멤버를 target에 복사되어 결합 후의 객체를 반환된다. (target에도 영향을 미친다)<br>\n동일 명칭의 프로퍼티는 나중에 정의된 값으로 덮어 쓰여진다.</p>\n\n```js\nlet pet1 = {\n  type: \"cat\",\n  name: \"coco\",\n  description: {\n    birth: \"2020-08-17\",\n  },\n}\nlet pet2 = {\n  name: \"chuchu\",\n  color: \"black\",\n  description: {\n    food: \"feed\",\n  },\n}\nlet pet3 = {\n  weight: 5,\n  age: 2,\n}\nObject.assign(pet1, pet2, pet3)\n/* \n    pet1 = {\n        age: 2,\n        color: 'black',\n        description: {  \n            food: 'feed' \n        }\n        name: 'chuchu',\n        type: 'cat',\n        weight: 5,\n    }\n*/\n```\n\n앞서 설명했듯이 target에 pet1이 지정되어 있기때문에 target객체인 pet1에 변화가 생겼다. <br>\n재귀적인 결합을 지원하지 않기때문에 description이 통째로 교체된다(birth → food)는 점에 주의한다.<br><br>\n만약, sources객체들에 영향을 끼치고 싶지 않다면, 다음과 같이 target에 {}를 지정해주면 빈 객체에 sources객체를 결합한 값들을 반환한다.\n\n```js\nObject.assign({}, pet1, pet2, pet3)\n/*\n{\n    \"type\": \"cat\",\n    \"name\": \"chuchu\",\n    \"description\": {\n        \"food\": \"feed\"\n    },\n    \"color\": \"black\",\n    \"weight\": 5,\n    \"age\": 2\n}\n*/\n```\n\n## 2. create()\n\n<div class=\"blockquote\">\n    Object.create(proto[, props])\n</div>  \n-&nbsp;proto: 생성할 객체의 원본 객체 &nbsp;-&nbsp;props: 프로퍼티 정보 (ex - {프로퍼티명 : { 속성명: 값, ... }, ... }) <br><br>\n객체를 생성하는 수단에는 여러가지 방법이 있다.\n\n```js\n// 1 - 객체 리터럴\nconst obj = { a: 1, b: 2, b: 3 }\n\n// 2 - new 연산자 이용\nconst obj2 = new Object()\n\n// 3 - Object.create()이용\n```\n\n1, 2의 방법으로 생성된 객체는 Object의 인스턴스로써 Object의 기본 메서드를 계승하고 있다. (toString, valueOf등) Object.create메서드의 proto 인수에 null을 전달하면 Object의 프로토타입을 계승하지 않는 완전한 빈 객체를 만들 수 있다. (null이 전달되어 만들어진 객체는 toString, valueOf등의 메서드를 사용할 수 없다.)\n\n```js\n// Object 프로토타입이 계승되지 않은 완전히 빈 객체 생성\nObject.create(null)\n```\n\n<p>Object.create로 빈 객체를 만들 수도 있지만 다양한 속성을 이용하여 커스텀도 가능하다. Object.create의 props에는 다음과 같은 프로퍼티 속성을 가질 수 있다.</p> <br>\n\n<table>\n    <thead>\n        <tr>\n            <th>프로퍼티 속성</th>\n            <th>개요</th>\n            <th>기본값</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>configurable</th>\n            <td>프로퍼티를 변경할 수 있는지 정하는 속성</td>\n            <td>false</td>\n        </tr>\n        <tr>\n            <th>enumerable</th>\n            <td>프로퍼티가 열거 가능한지 정하는 속성</td>\n            <td>false</td>\n        </tr>\n        <tr>\n            <th>value</th>\n            <td>프로퍼티의 값 저장</td>\n            <td>-</td>\n        </tr>\n        <tr>\n            <th>writable\n            </th>\n            <td>프로퍼티에 값을 저장할 수 있는지 정하는 속성</td>\n            <td>false</td>\n        </tr>\n        <tr>\n            <th>get\n            </th>\n            <td></td>\n            <td>-</td>\n        </tr>\n        <tr>\n            <th>set\n            </th>\n            <td></td>\n            <td>-</td>\n        </tr>\n    </tbody>\n</table>\n\n```js\n// Object.create를 이용하여 Object 프로토타입을 계승한 새로운 객체 생성\nlet coffee = Object.create(Object.prototype, {\n  name: {\n    value: \"Americano\",\n    writable: true,\n    configurable: true,\n    enumerable: true,\n  },\n  price: {\n    value: 4100,\n    writable: true,\n    configurable: true,\n    enumerable: true,\n  },\n  get: {\n    value: function () {\n      return this.name\n    },\n  },\n  set: {\n    value: function (name) {\n      this.name = name\n    },\n  },\n})\nconsole.log(coffee.name) // 'Americano'\nconsole.log(coffee.price) // 4100\nconsole.log(coffee.get()) // 'Americano'\ncoffee.set(\"cafe latte\")\nconsole.log(coffee.get()) // 'cafe latte'\n```\n\n위의 예제에서 configurable의 속성값을 true로 설정하였기 때문에 coffee.set()으로 name의 value값을 변경할 수 있었다. 위의 속성을 적절하게 사용하면 Object.create로 생성된 객체를 수정/복사 하여 활용할 수 있을 것이다.\n\n## 3. Object.create() vs new Constructor()\n\nObject.create를 다루는 자료들을 찾아보면 new Constructor()와 비교하는 글이 꽤 많았다. Object.create를 이용하는 것과 new키워드를 이용해 객체를 생성하는 것과의 공통점과 차이점은 뭘까?\n\n```js\nfunction Coffee() {\n  this.name = \"Americano\"\n}\nCoffee.prototype.price = 4100\nlet drink1 = new Coffee() // 생성자를 이용한 객체 생성\nlet drink2 = Object.create(Coffee.prototype)\n\nconsole.log(drink1.name) // 'Americano'\nconsole.log(drink1.price) // 4100\nconsole.log(drink2.name) // undefined\nconsole.log(drink2.price) // 4100\n```\n\n위의 예제를 보면 drink1.price와 drink2.price가 정상적으로 출력되었으며 price 프로토타입이 정상적으로 계승되었다는 것은 확인할 수 있다. 문제는 Coffee함수 내부에 선언된 name프로퍼티에 접근할 때 발생하였다. <br>\n생성자를 이용하여 선언한 drink1는 문제없이 name프로퍼티에 접근이 가능했지만 Object.create로 선언한 drink2변수는 name프로퍼티에 접근 시 undefined를 출력하였다. 즉 Object.create는 Constructor의 this.name에 접근할 수 없다.\n\n**- 왜 접근할 수 없는데?** <br>\nCoffee함수의 프로토타입을 상속받는 **생성자 객체** drink1를 만들면, Coffee는 drink1 객체의 this를 해당 객체에 바인딩 시킨다. Object.create로 만든 drink2는 단순히 Coffee함수의 프로토타입을 상속받아 객체를 생성했을 뿐이다. 따라서 프로토타입을 사용할 순 있지만, 생성자 함수의 내부 프로퍼티에 접근 할 수 없다. <br>\n\n**공통점**\n\n- 객체리터럴을 이용하기 때문에 새로운 객체를 만든다.\n- Constructor (위에서는 Coffee함수)의 프토로타입을 상속받는다.\n\n**차이점**\n\n- new 키워드로 생성한 객체(위에서는 drink1)는 Constructor 함수를 실행한다.\n- Object.create()로 생성한 객체(위에서는 drink2)는 Constructor 함수를 실행하지 않는다.\n\n<small class=\"from add\">참고 : 모던 자바스크립트 입문(이소 히로시), <a href=\"https://developer.mozilla.org/ko/\" target=\"_blank\">MDN</a></small>\n"},{"excerpt":"마케팅이 활성화 되면서 원페이지 및 랜딩페이지의 수가 급증했다. 옛날의 웹페이지라고 하면 복잡하고 전문적인 느낌이었지만 최근에는 일반사용자도 쉽게 만들 수 있는 플랫폼이 많이 생기면서 그 수는 계속 증가하고 있다. 한페이지에 많은 내용들을 담다보면 스크롤이 길어지면서 집중력이 떨어지고 이탈률이 높아진다. 이탈률을 낮춰주는데 도움이 되는 기능 중 한가지가 …","fields":{"slug":"/2021-09-21-scroll/"},"frontmatter":{"date":"September 21, 2021","title":"[html] 특정 영역으로 스크롤 이동 - 앵커기능(anchor) vs data 속성","tags":["html"]},"rawMarkdownBody":"\n마케팅이 활성화 되면서 원페이지 및 랜딩페이지의 수가 급증했다. 옛날의 웹페이지라고 하면 복잡하고 전문적인 느낌이었지만 최근에는 일반사용자도 쉽게 만들 수 있는 플랫폼이 많이 생기면서 그 수는 계속 증가하고 있다. 한페이지에 많은 내용들을 담다보면 스크롤이 길어지면서 집중력이 떨어지고 이탈률이 높아진다. 이탈률을 낮춰주는데 도움이 되는 기능 중 한가지가 바로 특정영역으로 스크롤을 이동시켜 원하는 부분에 집중할 수 있도록 해주는 것이다. 이 기능을 구현하는 대표적인 두 가지 방법은 a태그가 가지고 있는 anchor기능과 html 속성인 data를 활용하는 방법이다.\n\n## a- anchor\n\nanchor란 사전적 의미로 `배의 닻`을 뜻한다. 웹에서는 **사용자가 지정한 부분에 닻을내려 특정 영역의 링크를 만드는 기능**이라고 생각하면 쉬우며 주로 목차로 많이 사용한다. <br>\nhtml태그만으로 쉽게 작성이 가능하다는 점에서 사용성이 좋다.\n\n<div class=\"blockquote\">\n    &lt;a <b>href</b>=\"#아이디명\"&gt;&lt;/a&gt;\n</div>\n\n```html\n<!-- a href anchor -->\n<nav>\n  <ul>\n    <li><a href=\"#header\">header</a></li>\n    <li><a href=\"#main\">main</a></li>\n    <li><a href=\"#footer\">footer</a></li>\n  </ul>\n</nav>\n\n<!-- element id -->\n<section>\n  <header id=\"header\"></header>\n  <main id=\"main\"></main>\n  <footer id=\"footer\"></footer>\n</section>\n```\n\n<br>\n<p>a태그의 href 속성에 #id만 입력해주면 쉽게 사용할 수 있지만 단점이 있다. 첫번째는 해당영역으로 바로 이동되어 부드러운 스크롤 효과가 없다는 점이다.</p>\n\n![](img/scroll-move.jpg)\n\n두번째는 url 주소에 #id명의 해쉬가 생성되는데 자바스크립트 history.back()이나 history.go(-1)를 이용하여 뒤로가기를 구현했다면 해쉬로 인해 2번 클릭해야 한다는 문제가 발생한다. 하지만 해쉬를 이용해 history를 조작할 수 있다는 점에서도 해쉬는 장점이 될 수 있기 때문에 적절한 순간에 사용하면 매우 유용한 기능이다.\n\n## data-\\*\n\nHTML5 특정 요소와 연관되어 있지만 확정된 의미는 갖지 않는 데이터에 대한 확장 가능성을 염두에 두고 디자인되었다고 한다.\n데이터를 표기하는 표준이 없어 표준으로 사용할 수 있도록 개선되었으며 자바스크립트에서 dataset이나 getAttribute 메서드로 쉽게 접근할 수 있기때문에 매우 유용한 기능이다. 어느 엘리멘트에나 data-로 시작하는 속성은 무엇이든 사용할 수 있다. (div, button, a등 모든 태그)\n\n<div class=\"blockquote\">\n    &lt;button <b>data-target</b>=\"#아이디명\"&gt;&lt;/button&gt;\n</div>\n\n```html\n<!-- button에 data-target을 선언하여 -->\n<nav>\n  <ul>\n    <li><button data-target=\"#header\">header</button></li>\n    <li><button data-target=\"#main\">main</button></li>\n    <li><button data-target=\"#footer\">footer</button></li>\n  </ul>\n</nav>\n\n<!-- element id -->\n<section>\n  <header id=\"header\"></header>\n  <main id=\"main\"></main>\n  <footer id=\"footer\"></footer>\n</section>\n```\n\n<br>\n\n```js\n//button에 click 이벤트 - 모든 버튼에 이벤트를 걸어야 하기 때문에 for loop이용\nconst buttons = document.querySelectorAll(\"button\")\nfor (const button of button) {\n  button.addEventListener(\"click\", function () {\n    //선택된 button의 dataset.target명의 offsetTop을 구하는 변수를 선언한다.\n    const scrollPosition = document.querySelector(this.dataset.target).offsetTop\n\n    //scroll을 offsetTop으로 이동시킨다.\n    window.scrollTo({ top: scrollPosition, behavior: \"smooth\" })\n  })\n}\n```\n\n<p>한가지 버튼에 이벤트를 건다면 querySelector로 바로 이벤트를 걸면 되지만 button들에 이벤트를 걸기위해 querySelectorAll과 for loop를 이용하여 버튼들에 이벤트를 걸었다. data는 js에서 dataset.target으로 접근 가능하기 때문에 쉽게 구현이 가능하다.</p>\n\n<div class=\"blockquote\">\n    window.scrollTo({top: '', behavior: 'smooth'});\n</div>\n<p>scrollTo는 화면의 스크롤을 이동시켜주는 js메서드로, 위치는 top/left를 사용할 수 있다.\nbehavior은 스크롤 효과를 지정하는 속성으로 auto/instant/smooth를 사용할 수 있다. (defefault: auto)</p>\n\n**앵커기능은 js코드없이 html만으로 사용성이 쉽지만 url에 해쉬 붙는다는 장단점이 있다. data속성을 활용한 방법은 js코드로 구현해야 하지만 dataset으로 쉽게 접근 가능하다는 장단점이 있다. 상황에 따라 다르겠지만 나라면 해쉬를 이용하여 히스토리 조작할때만 빼고 data속성을 사용하여 구현할 것 같다. 부드럽게 이동하고 url적으로 깔끔하기 때문에 (a도 스크립트를 쓰면 가능은하다.)**\n\n<small class=\"from add\">참고 : <a href=\"https://developer.mozilla.org/ko/docs/Learn/HTML/Howto/%EB%8D%B0%EC%9D%B4%ED%84%B0_%EC%86%8D%EC%84%B1_%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" target=\"_blank\">MDN</a></small>\n"},{"excerpt":"자바스크립트는 원시타입(기본타입)과 참조타입으로 나뉜다. · 원시타입  Number  String  Boolean  undefined  null 원시타입을 제외한 모든값은 객체다.(즉, 참조타입은 객체다) 참조타입에는 원시타입을 제외한 모든타입, 배열, 함수, 정규표현식 등이 있다. 함수도 객체이기 때문에 값을 처리할 수 있으며 프로퍼티와 메서드도 가지고…","fields":{"slug":"/2021-09-21-function-prototype/"},"frontmatter":{"date":"September 21, 2021","title":"[javascript] 함수의 call, apply, bind 메서드","tags":["javascript"]},"rawMarkdownBody":"\n자바스크립트는 원시타입(기본타입)과 참조타입으로 나뉜다.\n\n**· 원시타입**\n\n1. &nbsp;Number\n2. &nbsp;String\n3. &nbsp;Boolean\n4. &nbsp;undefined\n5. &nbsp;null\n\n원시타입을 제외한 모든값은 객체다.(즉, 참조타입은 객체다) 참조타입에는 원시타입을 제외한 모든타입, 배열, 함수, 정규표현식 등이 있다. 함수도 객체이기 때문에 값을 처리할 수 있으며 프로퍼티와 메서드도 가지고 있다.\n\n## 함수는 객체\n\n자바스크립트의 함수는 Function 객체이다. 함수가 객체라서 가지는 특징은 다음과 같으며 이러한 작업이 가능한 객체를 **일급객체**라고 한다.\n\n- 함수는 변수나 프로퍼티나 배열 요소에 대입할 수 있다.\n- 함수는 함수의 인수로 사용할 수 있다.\n- 함수는 함수의 반환값으로 사용할 수 있다.\n- 함수는 프로퍼티와 메서드를 가질 수 있다.\n- 함수는 이름 없는 리터럴로 표현할 수 있다(익명함수).\n- 함수는 동적으로 생성할 수 있다.\n\n일급 객체인 함수는 **일급함수**라고도 한다.\n\n## 함수의 프로퍼티(메서드)\n\n함수는 Function 생성자의 prototype 객체의 프로퍼티를 상속받아서 사용한다.\n\n### 1. call()\n\n<div class=\"blockquote\">\n    func.call([thisArg[, arg1, arg2, ...argN]])\n</div>  \n-&nbsp;thisArg: func 호출에 제공되는 this의 값.<br>\n이미 할당되어있는 다른 객체의 함수/메소드를 호출하는 해당 객체에 재할당할때 사용된다. 함수의 call 메서드를 호출할 때 인자로 객체를 전달하면 그 객체를 함수의 this에 할당하고 함수를 호출한다.<br><br>\n\n```js\nfunction say(grettings, honorifics) {\n  console.log(grettings + \" \" + honorifics + \" \" + this.name)\n}\n\nvar phrygia = { name: \"phrygia\" }\nvar penny = { name: \"penny\" }\n\n// \"Nice to meet you I\"m phrygia\"\nsay.call(phrygia, \"Nice to meet you\", 'I\"m')\n\n// \"Hello Are you penny\"\nsay.call(penny, \"Hello\", \"Are you\")\n```\n\n위의 예제에서 say.call을 사용할때 사용된 인자의 객체가 this로 할당되어 각 객체의 name에 해당하는 value값이 호출되었다.\n\n### 2. apply()\n\n<div class=\"blockquote\">\n    func.apply(thisArg, [argsArray])\n</div> \n-&nbsp;thisArg: func를 호출하는데 제공될 this 의 값 <br>\n-&nbsp;argsArray: func가 호출되어야 하는 인수를 지정하는 유사 배열 객체<br>\n*apply와 거의 동일하지만 call은 인수를 쉼표(,)로 구분한 값으로 전달받고 apply는 배열로 받는다는 차이점이 있다. <br><br>\n\n```js\nfunction say(grettings, honorifics) {\n  console.log(grettings + \" \" + honorifics + \" \" + this.name)\n}\n\nvar phrygia = { name: \"phrygia\" }\nvar penny = { name: \"penny\" }\n\n// \"Nice to meet you I\"m phrygia\"\nsay.apply(phrygia, [\"Nice to meet you\", 'I\"m'])\n\n// \"Hello Are you penny\"\nsay.apply(penny, [\"Hello\", \"Are you\"])\n```\n\n### 3. bind()\n\n<div class=\"blockquote\">\n    func.bind(thisArg[, arg1[, arg2[, ...]]])\n</div> \n-&nbsp;thisArg: 바인딩 함수가 대상 함수(target function)의 this에 전달하는 값<br>\nFunction 객체의 bind 메서드는 객체에 함수를 바인드(묶다, 속박하다)한다. bind 메서드가 호출되면 새로운 함수를 생성하며 첫번째 인자의 value로는 this 키워드를 설정하고 뒤의 인자들은 바인드된 함수의 인수에 할당된 함수를 반환한다. 간단하게 말하자면 function에 인자로 넘긴 this가 바인딩 된 새로운 함수를 반환한다고 생각하면 된다.<br>\n*call, apply와의 차이점은 call, apply는 실행결과로 함수가 호출이지만 bind는 새로운 함수를 리턴한다는 점이다. <br><br>\n\n```js\nfunction say(grettings, honorifics) {\n  console.log(grettings + \" \" + honorifics + \" \" + this.name)\n}\n\nvar phrygia = { name: \"phrygia\" }\nvar sayToPhrygia = say.bind(phrygia)\n\n// Nice to meet you I'm phrygia\nsayToPhrygia(\"Nice to meet you\", 'I\"m')\n```\n\n위 코드에서 sayToPhrygia 함수를 호출하면 항상 this가 객체 phrygia를 가리킨다.\n<br>\n\n위의 3가지 프로퍼티들은 this값과 인수를 사용하여 실행하며 this를 지정하는데 유용한 메소드들이다.\nthis는 메서드 내부의 객체에 접근 할 수 있기도 하고 실행컨텍스트에 따라 this의 값이 다르기 때문에 꼭 알아둬야 할 중요한 개념이다. 다음번엔 this에 대한 정리를 해봐야 겠다.\n\n<small class=\"from add\">참고 : 모던 자바스크립트 입문(이소 히로시), <a href=\"https://developer.mozilla.org/ko/\" target=\"_blank\">MDN</a></small>\n"},{"excerpt":"프로젝트를 진행할 때마다 모달창을 마주치는 일이 많다. 프론트엔드 프레임워크나 라이브러리를 사용하면 편리성이나 시간을 아낄 수 있기때문에 npm에 등록된 모듈을 사용하곤 했지만, 만들어진 모듈이 아닌 직접 만들어 재사용해 보기로 했다. 어떻게 만들까?  재사용성 고려하기  Redux없이 만들기  함수형/클래스형 컴포넌트로 각각 만들기 1. 함수형으로 컴포…","fields":{"slug":"/2021-09-21-react-modal/"},"frontmatter":{"date":"September 21, 2021","title":"[react] 모달 팝업창 만들기 (react modal)","tags":["react"]},"rawMarkdownBody":"\n프로젝트를 진행할 때마다 모달창을 마주치는 일이 많다. 프론트엔드 프레임워크나 라이브러리를 사용하면 편리성이나 시간을 아낄 수 있기때문에 npm에 등록된 모듈을 사용하곤 했지만, 만들어진 모듈이 아닌 직접 만들어 재사용해 보기로 했다.\n\n- **어떻게 만들까?**\n\n1. &nbsp;재사용성 고려하기\n2. &nbsp;Redux없이 만들기\n3. &nbsp;함수형/클래스형 컴포넌트로 각각 만들기\n\n## 1. 함수형으로 컴포넌트 만들기\n\n![-완성된 모습-](img/modal-2.gif)\n\n**\\*파일구조** <br>\n\n![](img/modal-1.jpg)\n\n재사용할 컴포넌트로 Modal.js 파일을 만들고, App.js에서 불러오도록 했다.\n\n**- CSS (함수형/클래스형 공통)**\n\n```css\n.modal {\n  display: none;\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 99;\n  background-color: rgba(0, 0, 0, 0.6);\n}\n.modal button {\n  outline: none;\n  cursor: pointer;\n  border: 0;\n}\n.modal > section {\n  width: 90%;\n  max-width: 450px;\n  margin: 0 auto;\n  border-radius: 0.3rem;\n  background-color: #fff;\n  /* 팝업이 열릴때 스르륵 열리는 효과 */\n  animation: modal-show 0.3s;\n  overflow: hidden;\n}\n.modal > section > header {\n  position: relative;\n  padding: 16px 64px 16px 16px;\n  background-color: #f1f1f1;\n  font-weight: 700;\n}\n.modal > section > header button {\n  position: absolute;\n  top: 15px;\n  right: 15px;\n  width: 30px;\n  font-size: 21px;\n  font-weight: 700;\n  text-align: center;\n  color: #999;\n  background-color: transparent;\n}\n.modal > section > main {\n  padding: 16px;\n  border-bottom: 1px solid #dee2e6;\n  border-top: 1px solid #dee2e6;\n}\n.modal > section > footer {\n  padding: 12px 16px;\n  text-align: right;\n}\n.modal > section > footer button {\n  padding: 6px 12px;\n  color: #fff;\n  background-color: #6c757d;\n  border-radius: 5px;\n  font-size: 13px;\n}\n.modal.openModal {\n  display: flex;\n  align-items: center;\n  /* 팝업이 열릴때 스르륵 열리는 효과 */\n  animation: modal-bg-show 0.3s;\n}\n@keyframes modal-show {\n  from {\n    opacity: 0;\n    margin-top: -50px;\n  }\n  to {\n    opacity: 1;\n    margin-top: 0;\n  }\n}\n@keyframes modal-bg-show {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n```\n\n**- Modal.js**\n\n```js\nimport React from \"react\"\nimport \"../../../assets/css/modal.css\"\n\nconst Modal = props => {\n  // 열기, 닫기, 모달 헤더 텍스트를 부모로부터 받아옴\n  const { open, close, header } = props\n\n  return (\n    // 모달이 열릴때 openModal 클래스가 생성된다.\n    <div className={open ? \"openModal modal\" : \"modal\"}>\n      {open ? (\n        <section>\n          <header>\n            {header}\n            <button className=\"close\" onClick={close}>\n              &times;\n            </button>\n          </header>\n          <main>{props.children}</main>\n          <footer>\n            <button className=\"close\" onClick={close}>\n              close\n            </button>\n          </footer>\n        </section>\n      ) : null}\n    </div>\n  )\n}\n```\n\n**- App.js**\n\n```js\nimport React, { useState } from \"react\"\nimport Modal from \"./commons/components/Modals/Modal\"\n\nfunction App() {\n  // useState를 사용하여 open상태를 변경한다. (open일때 true로 만들어 열리는 방식)\n  const [modalOpen, setModalOpen] = useState(false)\n\n  const openModal = () => {\n    setModalOpen(true)\n  }\n  const closeModal = () => {\n    setModalOpen(false)\n  }\n\n  return (\n    <React.Fragment>\n      <button onClick={openModal}>모달팝업</button>\n      //header 부분에 텍스트를 입력한다.\n      <Modal open={modalOpen} close={closeModal} header=\"Modal heading\">\n        // Modal.js <main> {props.children} </main>에 내용이 입력된다. 리액트\n        함수형 모달 팝업창입니다. 쉽게 만들 수 있어요. 같이 만들어봐요!\n      </Modal>\n    </React.Fragment>\n  )\n}\n\nexport default App\n```\n\n## 2. 클래스형으로 컴포넌트 만들기\n\n**- Modal.js (재사용 컴포넌트 - 자식)**\n\n```js\nimport React, { useState } from \"react\"\nimport Modal from \"../../../commons/components/Modals/Modal\"\n\nexport class Modal extends Component {\n  render() {\n    // 열기, 닫기, 모달 헤더 텍스트를 부모로부터 받아옴\n    const { open, close, header } = this.props\n\n    return (\n      <div className={open ? \"openModal modal\" : \"modal\"}>\n        {open ? (\n          <section>\n            <header>\n              {header}\n              <button className=\"close\" onClick={close}>\n                &times;\n              </button>\n            </header>\n            <main>{this.props.children}</main>\n            <footer>\n              <button className=\"close\" onClick={close}>\n                close\n              </button>\n            </footer>\n          </section>\n        ) : null}\n      </div>\n    )\n  }\n}\n```\n\n**- App.js (부모 컴포넌트)**\n\n```js\nimport React, { Component } from 'react';\nimport Modal from './commons/components/Modals/Modal';\n\nexport class ChatRooms extends App {\n    this.state = {\n        modalOpen: false,\n    }\n\n    openModal = () => {\n        this.setState({ modalOpen: true })\n    }\n    closeModal = () => {\n        this.setState({ modalOpen: false })\n    }\n    render() {\n        return (\n            <React.Fragment>\n                <button onClick={ this.openModal }> 모달팝업</button>\n                <Modal open={ this.state.modalOpen } close={ this.closeModal } title=\"Create a chat room\">\n                    // Modal.js <main> { this.props.children } </main>에 내용이 입력된다.\n                    리액트 클래스형 모달 팝업창입니다.\n                    쉽게 만들 수 있어요.\n                    같이 만들어봐요!\n                </Modal>\n            </React.Fragment>\n        )\n    }\n}\nexport default App\n```\n\n이로써 어디서든 Modal 컴포넌트를 가지고 와서 재사용할 수 있게 되었다. 모달은 워낙 기본적이고 중요한 부분은 아니라 만들어진 모듈을 사용할때가 많은데, 못만들어서 모듈을 이용하는 것과 만들줄 알지만 너무 할일이 많아서 모듈을 이용하는 건 매우 다르다고 생각되었다. 나는 어느쪽인가 생각해 보다가 만들어 보기로 했고, 생각보다 어렵지 않게 만들 수 있었다. 처음에는 함수형으로 만들었지만 클래스형 컴포넌트의 사용률이 더 높기 때문에 클래스형도 함께 만들어 봤다. 앞으로 작은 프로젝트이거나 커스텀이 필요해서 원하는 모듈이 없을때는 모달창을 직접 만들어 사용할 수 있을 것 같다.\n"},{"excerpt":"퍼블리싱 프리랜서일을 할때면 자주 등장하는 용어가 바로 이란 단어다. 반응형이란 단어와 함께 언급되는 이란 단어도 있으며, 이 두 단어가 나올때마다 '도대체 무슨 차이지?' 라는 의문도 따라온다. 퍼블리싱을 3년동안 했지만 반응형과 적응형의 차이에 대해 명확하게 설명하지 못하고 명확한 차이를 모른다고 생각됐기 때문에 이 두가지는 어떻게 다른지에 대해 알아…","fields":{"slug":"/2021-09-21-rwd-awd/"},"frontmatter":{"date":"September 21, 2021","title":"[web] 반응형(RWD)웹과 적응형(AWD)웹","tags":["web"]},"rawMarkdownBody":"\n퍼블리싱 프리랜서일을 할때면 자주 등장하는 용어가 바로 `반응형`이란 단어다. 반응형이란 단어와 함께 언급되는 `적응형`이란 단어도 있으며, 이 두 단어가 나올때마다 '도대체 무슨 차이지?' 라는 의문도 따라온다. 퍼블리싱을 3년동안 했지만 반응형과 적응형의 차이에 대해 명확하게 설명하지 못하고 명확한 차이를 모른다고 생각됐기 때문에 이 두가지는 어떻게 다른지에 대해 알아보고자 조사하게 되었다.\n\n## 반응형 vs 적응형\n\n![사진 출처 : https://uxplanet.org/](img/rwd-awd.png)\n\n## 1. 반응형: RWD(Responsive Web Design)\n\n**\\*웹의 해상도, 레이아웃 등이 디바이스에 따라 반응하여 유동적으로 변환되는 웹페이지** <br>\n과거의 웹을 사용하는 주요기기는 컴퓨터였으며, 모니터에 맞춰 화면의 크기와 레이아웃이 구성되었다. 2007년 애플사에서 아이폰을 출시하면서 스마트폰의 시대가 열렸고, 어디서든 손쉽게 웹사이트에 접근할 수 있게 되었다. 하지만 아래의 사진처럼 문제가 발생하였다.\n![](img/steveJobsIPhone.jpg)\n\n바로 손바닥만한 기기에서 큰 모니터에서만 보던 화면으로 웹사이트를 봐야한다는 문제였다. 웹사이트의 모든 내용을 담기에는 글자가 너무 작아져서 읽을 수조차 없었으며 읽기위해서는 손가락으로 화면을 일일히 확대해서 봐야하는 번거로움이 있었다. <br>\n이러한 문제점으로 인해 같은 페이지라 할지라도 어떤 장치로 접속하느냐에 따라 다른 종류의 화면을 보여줘야 할 필요성이 대두되기 시작했다. 하지만 같은 페이지를 pc용 스마트폰 용으로 나누어 만드는 건 시간적·비용적으로 매우 비효율적이었다. (한 사이트의 페이지가 100개라면? pc용 스마트폰 용 200개를 만들어야 하며, 아이패드 출시이후 태블릿용 사이즈까지 포함하여 최대 300개를 만들어야 한다.) 이를 해결하기 위한 방법으로 반응형 웹 기술이 주목받게 되었다. <br>\n반응형 웹의 기술 요소로는 캐스케이딩 스타일 시트3(Cascading Style Sheets3; CSS3) 미디어 쿼리, 유동형 그리드(Fluid Grid), 유동형 이미지(Flexible Images) 등이 있다.\n이 3가지 기술은 2010년 에단 마코트(Ethan Marcotte)가 `Responsive Web Design`이란 글에서 유동적인 웹페이지를 개발하는 방법을 소개하면서 알려졌다.\n\n<table>\n    <thead>\n        <tr>\n            <th>기술 요소</th>\n            <th>설명</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <th>CSS3 미디어 쿼리(Media Query)</th>\n            <td>디스플레이의 폭, 높이 등의 정보들을 이용하여 단말기 브라우저 창의 특정 지점을 기준으로 각 해상도에 최적화되도록 레이아웃 스타일을 바꿀 수 있다. (웹, 프린터, 음성 합성 장치 등의 상황에 맞는 미디어유형을 설정할 수 있다.) </td>\n        </tr>\n        <tr>\n            <th>유동형 그리드(Fluid Grid)</th>\n            <td>디스플레이 너비에 따라 가변단위(%등)로 값을 설정하여 화면을 가변적으로 구성할 수 있다.</td>\n        </tr>\n        <tr>\n            <th>유동형 이미지(Flexible Images)</th>\n            <td>디스플레이 너비에 따라 적절한 크기로 이미지의 형태가 늘어나고 줄어들게 설정 할 수 있다.</td>\n        </tr>\n    </tbody>\n</table>\n\n반응형 홈페이지는 위의 3가지 기술이 어우러져 스스로 환경에 반응하여 실시간으로 적용되는 방식이며, 디바이스의 가로너비와 %단위를 사용하여 창의 너비가 변할때 레이아웃이 변경된다. 주로 데스크탑/태블릿/모바일 3가지로 분류한 뒤 널리 통용되는 width사이즈를 기준으로 CSS3 미디어 쿼리(Media Query)를 작성하여 웹사이트를 제작한다. (태블릿과 데스크탑을 하나로 취급하여 제작하는 경우도 많다.)\n\n```css\n/* Desktop */\n@media only screen and (min-width: 1021px) {\n}\n\n/* Tablet */\n@media only screen and (min-width: 768px) and (max-width: 1020px) {\n}\n\n/* Mobile */\n@media only screen and (max-width: 767px) {\n}\n```\n\n![](img/rwd.png) <br>\n<small>필자가 코딩한 반응형 사이트 : 데스크탑 + 모바일 2가지로 진행하였다.</small>\n\n## 2. 적응형: AWD(Adaptive Web Design)\n\n**\\*서버나 클라이언트에서 웹에 접근한 디바이스를 체크하여 그 디바이스에 최적화된 미리 정해 놓은 각 디바이스의 디스플레이에 맞는 웹을 보여주는 디자인** <br>\n데스크탑의 경우 데스크탑용 템플릿을 모바일은 모바일용 템플릿을 제공한다. (ex: 카페24) 기기별로 다른 템플릿을 제작해야하기 때문에 작업시간과 비용이 많이 들며, 유지보수가 어렵고 복잡해진다는 단점이 있다. 반응형웹은 모든 기기의 템플릿과 CSS를 다운로드하기 때문에 데이터 낭비와 로딩속도가 느려질수 있지만, 적응형웹은 사용자 기기에 맞는 템플릿과 CSS만을 다운로드하기 때문에 속도가 더 빠를 수 있다.\n\n<small class=\"from add\">참고 : <a href=\"https://terms.naver.com/entry.nhn?docId=3609911&cid=58598&categoryId=59316\" target=\"_blank\">https://terms.naver.com/entry.nhn?docId=3609911&cid=58598&categoryId=59316</a><br>\n<a href=\"https://terms.naver.com/entry.nhn?docId=3350028&cid=40942&categoryId=32828\" target=\"_blank\">https://terms.naver.com/entry.nhn?docId=3350028&cid=40942&categoryId=32828</a><br>\n<a href=\"https://ko.wikipedia.org/wiki/%EC%A0%81%EC%9D%91%ED%98%95_%EC%9B%B9_%EB%94%94%EC%9E%90%EC%9D%B8\" target=\"_blank\">https://ko.wikipedia.org/wiki/%EC%A0%81%EC%9D%91%ED%98%95*%EC%9B%B9*%EB%94%94%EC%9E%90%EC%9D%B8</a>\n</small>\n"},{"excerpt":"는 블록 스코프이며, 변수의 재선언 및 재할당이 모두 불가능하다.\n흔히 여기서 오는 오해 중 하나가 const로 정의하면 객체 속성값도 수정할 수 없다고 생각하지만, const로 정의해도 객체의 내부 속성값은 수정이 가능하다. (객체를 참조하는 변수를 수정하는 것은 불가능 하다.) - JS 객체에서 이미 존재하는 속성값을 수정하거나 새로운 값을 추가하는 …","fields":{"slug":"/2021-09-21-javascript-object/"},"frontmatter":{"date":"September 21, 2021","title":"[javascript] 객체 수정 제어 : preventExtensions(), seal(), freeze()","tags":["javascript"]},"rawMarkdownBody":"\n`const`는 블록 스코프이며, 변수의 재선언 및 재할당이 모두 불가능하다.<br>\n흔히 여기서 오는 오해 중 하나가 const로 정의하면 객체 속성값도 수정할 수 없다고 생각하지만, const로 정의해도 객체의 내부 속성값은 수정이 가능하다. (객체를 참조하는 변수를 수정하는 것은 불가능 하다.)\n\n**- JS**\n\n```js\nconst fruit = { name: \"banana\" }\nfruit.name = \"apple\"\nfruit.color = \"red\"\nconsole.log(fruit) // { name: 'apple', color: 'red' };\n\n//배열도 객체의 일종이기 때문에 속성값을 수정할 수 있다.\nconst array = [1, 2]\narray[0] = 10\narray.push(30)\nconsole.log(array) // [10, 2, 30];\n\n// const로 정의된 변수에 재할당은 불가능하다.\nconst fruit = { name: \"banana\" }\nfruit = { color: \"apple\" } // 에러\n```\n\n객체에서 이미 존재하는 속성값을 수정하거나 새로운 값을 추가하는 것은 모두 가능하다. 객체의 내부 속성값을 수정하지 못하게 하고 싶다면 유명한 불변성 패키지인 immer.js, immutable.js 등을 사용하면 된다. (immer.js는 리액트에서도 많이이 쓰이기 때문에 알아두면 좋다.) 이러한 패키지들은 기존 객체를 수정하지 않고 새롭게 객체를 생성한다.\n\n다음의 JS내장 함수는 불변성 외부 패키지에서 새롭게 객체를 생성하는 편의성은 필요 없고 수정만 할 수 없도록 만들고 싶을 때 사용하면 유용하다.\n\n- Object.preventExtensions\n- Object.seal\n- Object.freeze\n\n## 1. Object.preventExtensions\n\n&nbsp;&nbsp;&nbsp;새로운 속성을 객체에 추가되는 것을 방지한다. (**확장 금지**) 값의 추가만 금지되고 삭제, 속성 변경, 프로퍼티에 값을 할당하는 작업은 가능하다.<br>\n\n<div class=\"blockquote\">\nObject.preventExtensions(obj)&nbsp;&nbsp;  // obj : 확장을 방지할 대상 객체.\n</div>\n\n```js\nconst object1 = { prop1: \"work?\" }\nconsole.log(object1) //Object { prop1: \"work?\" }\n\n// 객체가 확장 가능한지 여부 판별\nconsole.log(Object.isExtensible(object1)) //true\n\n// 확장 금지\nObject.preventExtensions(object1)\nconsole.log(Object.isExtensible(object1)) //false\n\n// 값을 추가해도 추가되지 않는다.\nobject1.prop2 = \"add\"\nconsole.log(object1) //Object { prop1: \"work?\" }\n\n// 프로퍼티에 값을 할당하는 작업은 가능하다.\nobject1.prop1 = \"change!\"\nconsole.log(object1) //Object { prop1: \"change!\" }\n\n// 프로퍼티의 값을 삭제하는 것도 가능하다.\ndelete object1.prop1\nconsole.log(object1) //Object {  }\n```\n\n## 2. Object.seal\n\n객체를 **봉인**해서 새로운 속성을 추가하거나 제거하지 못하게 한다. 기존 프로퍼티를 변경하는 것은 불가능 하지만 쓰기 가능한 속성(writable)의 값은 변경할 수 있다. <br>\n\n<div class=\"blockquote\">\nObject.seal(obj)&nbsp;&nbsp;  // obj : 봉인할 객체.\n</div>\n\n```js\nconst object1 = {\n  foo: \"foo\",\n  bar: function () {\n    return \"bar\"\n  },\n}\n\n// 객체 봉인\nObject.seal(object1)\n\n// 객체가 봉인됐는지 여부 판별\nconsole.log(Object.isSealed(object1)) //true\n\n// 객체 추가 불가능\nobject1.addFoo = \"addFoo\"\n\n// 기본적으로 프로퍼티의 writable은 true로 설정되어 있기 때문에 수정 불가능하게 만들고 싶다면 false로 수정한다.\nobject1.foo = \"change !\"\nObject.defineProperty(object1, \"foo\", {\n  writable: false,\n})\nobject1.foo = \"change !!\"\n\n// writable을 false로 선언하기 전에 바꾼 속성값으로 적용되어 있다.\nconsole.log(object1) // Object { foo: \"change !\", bar: function () { return \"bar\"; } }\n\n// 객체 삭제 불가능\ndelete object1.foo\nconsole.log(object1) // Object { foo: \"change !\", bar: function () { return \"bar\"; } }\n```\n\n## 3. Object.freeze\n\n이 메서드는 객체를 **동결** 시키며, 다음과 같은 작업이 불가능해진다. 동결은 소개하는 3가지 메서드중 가장 높은 단계의 불변성을 적용한다.\n\n- 새로운 속성(메서드, 프로퍼티) 추가 금지\n- 존재하는 속성 제거 금지\n- 존재하는 속성의 불변성, 설정 가능성(configurability), 작성 가능성 변경 금지\n- 존재하는 속성의 값 변경 금지\n- 프로포타입 변경 금지\n\n<div class=\"blockquote\">\nObject.freeze(obj)&nbsp;&nbsp;  // obj : 동결할 객체.\n</div>\n\n```js\nconst object1 = {\n  prop1: 42,\n}\n\nObject.freeze(object1)\n\n// 객체가 동결됐는지 여부 판별\nconsole.log(Object.isFrozen(object1)) // true\n\n// 객체 추가 불가능\nobject1.prop2 = \"add\"\nconsole.log(object1) // Object { prop1: 42 }\n\n// 객체 수정 불가능\nobject1.prop1 = 33 // strict모드 에서는 Error 출력\nconsole.log(object1.prop1) // 42\n\n// 객체 삭제 불가능\ndelete object1.prop1\nconsole.log(object1) // Object { prop1: 42 }\n```\n\n- \"use strict\" 모드를 사용\n- \\*위의 메서드가 적용되어진 객체가 참조하는 다른 객체까지 수정 제어하는 것이 아니기 때문에 얕은 불변성만 지원한다. 더욱 엄격하게 객체를 제어하고 싶다면 외부 패키지를 이용하면 더 좋을 것 같다.\n\n<small class=\"from add\">참고 : 실전리액트 프로그래밍 - 이재승<br>\n\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\" target=\"_blank\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions</a><br>\n\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\" target=\"_blank\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/seal</a><br>\n\n<a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\" target=\"_blank\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze</a>\n</small>\n"},{"excerpt":"\"HTML is the World Wide Web's core markup language. Originally, HTML was primarily designed as a language for semantically describing scientific documents.\"  > - \"HTML은 World Wide Web의 핵심 markup 언어이다…","fields":{"slug":"/2021-09-21-sematic-tag/"},"frontmatter":{"date":"September 21, 2021","title":"[html] Semantic Tag Layout (시맨틱 태그)","tags":["web"]},"rawMarkdownBody":"\n> \"HTML is the World Wide Web's core markup language. Originally, HTML was primarily designed as a language for semantically describing scientific documents.\" <br><br> > <i>- \"HTML은 World Wide Web의 핵심 markup 언어이다. 원래 HTML은 과학적인 문서를 `의미를 담아 기술하는 언어`로 설계되었다.\"</i> <br><br>\n> \"Elements, attributes, and attribute values in HTML are defined (by this specification) to have certain meanings (semantics)\"<br><br> > <i>- \"HTML의 요소와 속성 및 속성 값은 `특정한 의미를 가지도록 정의`되었다.\"</i>\n\n<small class=\"from\">출처 : <a href=\"https://www.w3.org/TR/2016/REC-html51-20161101/introduction.html\" target=\"_blank\">W3C Recommendation</a></small>\n\n## Semantic Tag\n\n### 시맨틱 태그란?\n\n흔히들 HTML5 시대에서 가장 큰 변화는 시맨틱 태그라고 말한다. semantic은 사전적인 의미로 '의미의, 의미론적인'라는 의미를 가지고 있다.\nHTML5 이전의 웹사이트는 거의 모든 태그를 `<div>`를 사용하여 코딩하였다. &#60;div&#62;로 작성된 사이트는 문서의 구조와 의미를 알아보기 힘들었고 검색 엔진이 태그의 기능을 분별할 수 없어 자료를 수집하기에 효율적인 사이트가 되지 못했다.<br>\n마케팅 및 다양한 분야에서 중요해진 검색엔진에 대응하고 검색 결과가 상위에 노출되기 위해서 검색 엔진 최적화(SEO: Search Engine Optimization)가 중요해졌다. 검색엔진의 로봇(Robot)이 전세계의 웹사이트에 방문하여 웹사이트 정보를 수집하여, 검색 키워드에 대응하는 인덱싱을 만든다. 이때의 인덱싱은 웹사이트의 Hml코드로 만들어 지며, 효율적인 검색 키워드를 만들기 위해서는 웹사이트 구조를 시맨틱하게 작성하는 것이 중요하다.\n<br>\n`<div> <span>`등의 태그는 컨텐츠가 아무 의미를 가지고 있지 않으며 의미가 없는 태그이다. 이를 **Non-Semantic elements**라고 하며, 컨텐츠의 의미를 명확하게 정의하는 `<form> <table> <img>` 등의 태그를 **Semantic elements**라고 한다.\n\n### HTML5에 추가된 시맨틱 태그\n\n![](img/semantic-tag.jpg)\n\n- `<header>` : 머리말을 나타내는 요소이다.\n- `<nav>` : 메뉴 영역(네비게이션)을 나타내는 요소이다.\n- `<aside>` : 좌우측의 사이드 영역을 나타내는 요소이다.\n- `<section>` : 제목별로 나눌 수 있는 문서의 콘텐츠 영역을 구성하는 요소이다.\n- `<article>` : 콘텐츠 영역에서 개별 콘텐츠를 나타내는 요소이다.\n- `<footer>` : 꼬리말을 나타내는 요소이다.\n\n이 외에도 &#60;figure&#62; &#60;main&#62; &#60;mark&#62; &#60;details&#62; 등의 태그가 있다.\n\n## 시맨틱 태그의 장점\n\n**<span style=\"color:#6868ac\">Non-Semantic elements</span> - Naver**<br><br>\n![](img/naver-markup.jpg)\n\n**<span style=\"color:#6868ac\">Semantic elements</span> - 레진 코믹스**<br><br>\n![](img/lezhin-markup.jpg)\n\n위의 두 사이트를 보면,\n\n```html\n<!-- Naver -->\n<div id=\"header\">\n  <div id=\"gnb\">...</div>\n</div>\n\n<!-- 레진 코믹스 -->\n<header id=\"main-header\">\n  <nav id=\"gnb\">...</nav>\n</header>\n```\n\n로 코딩되어 있는 것을 확인 할 수 있다. 위의 코드는 같은 결과물을 출력하지만 아무 의미를 가지고 있지 않는 &#60;div&#62; 태그를 사용하는 것보다 \"header\"라는 컨텐츠의 의미를 담고있는 &#60;header&#62; 태그를 사용함으로써 컨텐츠를 더욱 명확하게 파악 할 수 있다.\n\n1. **코드의 가독성을 높이고 의미를 명확하게 해준다.**\n2. **코드 관리가 쉽다. (협업 및 유지보수 등에서 유용하다.)**\n3. **검색 엔진 최적화(SEO)에 유리하다.**\n\n<br>\n<small class=\"from add\">참고 : <a href=\"https://www.w3schools.com/html/html5_semantic_elements.asp\" target=\"_blank\">https://www.w3schools.com/html/html5_semantic_elements.asp</a>\n</div>\n"},{"excerpt":"새로운 vue 프로젝트 사전미팅에서 장바구니에 담기는 액션을 부탁받았었다.\n\n출처 : react clap button 이런 방식으로 장바구니에 담기는 액션을 부탁받았는데, 아직 vue가 미숙한 나는 어떻게 코딩해야 할지 큰 고민에 빠졌었다. 어떻게 만들까? 1. npm에서 타인이 만든걸 사용할까? npm에서 clap button을 검색하여 위의 박수치는 …","fields":{"slug":"/2021-09-21-vue-clap-button/"},"frontmatter":{"date":"September 21, 2021","title":"[vue] 박수치기 버튼 만들기 (vue clap button)","tags":["vue"]},"rawMarkdownBody":"\n새로운 vue 프로젝트 사전미팅에서 장바구니에 담기는 액션을 부탁받았었다.\n<img src=\"https://raw.githubusercontent.com/kikobeats/react-clap-button/HEAD/demo.gif\" alt=\"\">\n<small class=\"from\">출처 : <a href=\"https://www.npmjs.com/package/react-clap-button\" target=\"_blank\">react clap button</a></small>\n\n이런 방식으로 장바구니에 담기는 액션을 부탁받았는데, 아직 vue가 미숙한 나는 어떻게 코딩해야 할지 큰 고민에 빠졌었다.\n\n- **어떻게 만들까?**\n<ol style=\"list-style-type: upper-greek;\">\n    <li>&nbsp;npm에서 타인이 만든걸 사용할까?</li>\n    <li>&nbsp;없다면 내가 직접 작성할까?</li>\n    <li>&nbsp;작성한다면 클릭할때와 카운트될때의 액션을 제외하고 css로 처리가 가능할까?</li>\n</ol>\n\n## 1. npm에서 타인이 만든걸 사용할까?\n\nnpm에서 clap button을 검색하여 위의 박수치는 액션을 찾았다. 정말 딱 내가 원하던 액션이었고 클라이언트가 보여준 액션과도 거의 흡사했다. 'Wow! 딱 원하던거야! 역시 npm 최고! 내가 생각하는건 이미 남이 만들어 놨을줄 알았다니까? 가만히 보자... 어라? 그런데 이건 react잖아? 😥 아니야! 실망하긴 이르지!! react가 있으면 vue도 있을거야!' 라는 생각으로 바로 npm 검색을 했고 <a href=\"https://www.npmjs.com/package/vue-clap-button\" target=\"_blank\">vue clap button</a>을 찾았다.\n\n<img src=\"https://raw.githubusercontent.com/AJLoveChina/vue-clap-button/HEAD/demo.gif\" alt=\"\">\n<small class=\"from\">출처 : <a href=\"https://www.npmjs.com/package/vue-clap-button\" target=\"_blank\">vue clap button</a></small>\n<br><br>\n\n'역시! react가 있으면 vue도 있었어!' 흡족한 마음으로 테스트용 프로젝트에 모듈을 설치해보았다.\n그런데 내가 원하던 액션이 아니었다. react clap button은 버튼을 누르면 초록색 동그라미안에 숫자가 카운트 되면서 위로 사라지지만 vue clap button은 버튼에 마우스가 hover된 상태에서만 카운트되는 숫자가 보이는 치명적인 단점이 있었다.\n![](img/clap-vue.gif)\n\ncss를 수정으로 작동이 되는지 확인해 보았지만 css문제는 아닌것으로 보여 npm 모듈이용을 포기하기로 했다.<br><br>\n\n## 2. npm에 없다면 내가 직접 작성할까?\n\n내가 생각한 2번째 방법은 직접 자바스크립트 코드를 작성하면 되잖아 였다. 엄청난 고난이도 작업은 아니지만 버튼을 연속으로 누르면 위로가던 숫자 카운터가 밑에서 다시 카운트되어야 하는 귀찮은 작업이기는 했다. 하지만, 이 액션만 사용하려고 npm 모듈을 설치하는 것보다는 낫다고 생각되어 직접 만들기에 도전했다.\n<br><br> -**완성된 모습**-\n\n![img/clap-vue2.gif](img/clap-vue2.gif)\n<br>vue 프로젝트젝트를 생성한 후 코드를 작성해 보자.<br>\n\n**- HTML**\n\n```html\n<div id=\"vue\" class=\"clap_btn_wrapper\">\n  <!-- 박수 버튼 (실제로 클릭되는 버튼) -->\n  <button ref=\"clap\" class=\"clap_button\" @click=\"clapClick()\">\n    <img src=\"clap.png\" alt=\"clap_icon\" />\n  </button>\n  <!-- 카운트 되는 태그 -->\n  <div ref=\"clicker\" class=\"clap_counter\" />\n</div>\n```\n\n**- CSS**\n\n```css\n.clap_btn_wrapper {\n  position: relative;\n  width: 80px;\n  height: 80px;\n}\n.clap_btn_wrapper .clap_button {\n  height: 100%;\n  width: 100%;\n}\n.clap_btn_wrapper .clap_counter {\n  position: absolute;\n  top: -30px;\n  font-weight: 700;\n  opacity: 0;\n}\n.clap_btn_wrapper .clap_counter.act {\n  opacity: 1;\n}\n```\n\n**- JS**\n\n```js\nnew Vue({\n  el: \"#vue\",\n  data: {\n    counter: 0, // 카운터 되는 data\n  },\n  methods: {\n    // 클릭했을 때\n    clapClick() {\n      const clickCounter = this.$refs.clicker\n\n      // 박수 친 횟수 올리기 (counter)\n      clickCounter.textContent = `+ ${++this.counter}`\n\n      // 숨겨진 clap_counter를 노출시킨다.\n      clickCounter.classList.add(\"act\")\n    },\n  },\n})\n```\n\n클릭했을 때 박수횟수를 증가시키는 clapClick함수를 작성하였다. 클릭했을 때, 박수 횟수가 증가한다.\n![](img/clap-vue3.gif)\n\n## 3. 직접 코드를 작성한다면 클릭할때와 카운트될때의 액션을 제외하고 css로 처리가 가능할까?\n\n클릭했을 때 박수횟수를 증가시키는 함수는 완성되었다.\n이제 클릭했을때 clap_counter가 위로 사라지고, 클릭하면 다시 나타나는 css를 구현해 보기로 했다.\n클릭했을 때 박수횟수를 증가시키는 counter 증가함수와, 클릭했을때 바로바로 애니메이션을 줄 수 있도록 element의 클래스명을 체크하는 함수로 나누어 코드를 작성하였다.\n숫자를 표시하는 clap_counter의 animation 코드에 css의 tranaslateY와 scale을 이용해 위로 사라지고 커졌다 작아지는 효과를 주었다.\n\n**- CSS**\n\n```css\n.clap_btn_wrapper .clap_counter.first {\n  animation: first-bump 1s forwards;\n}\n.clap_btn_wrapper .clap_counter.act {\n  animation: bump 1s forwards;\n}\n\n/* 처음 실행 됐을때 clap_counter를 표시한다. -> 높이(translateY) 조절 가능 */\n@keyframes first-bump {\n  0% {\n    transform: translateY(-10px);\n    opacity: 1;\n  }\n  50% {\n    transform: translateY(-20px);\n    opacity: 1;\n  }\n  100% {\n    transform: translateY(-30px);\n    opacity: 0;\n  }\n}\n\n/* 버튼이 클릭될때마다 튕기듯이 커지고 처음 위치에 표시할 수 있게 해주는 애니메이션 \n-> 원하는 크기(scale)와 높이(translateY)는 조절 가능 */\n@keyframes bump {\n  0% {\n    transform: translateY(-10px) scale(0.9);\n    opacity: 1;\n  }\n  50% {\n    transform: translateY(-10px) scale(1);\n    opacity: 1;\n  }\n  100% {\n    transform: translateY(-25px) scale(1);\n    opacity: 0;\n  }\n}\n```\n\n**- JS**\n\n```js\nmethods: {\n  // 클릭했을 때\n  clapClick() {\n    const clickCounter = this.$refs.clicker\n    clickCounter.textContent = `+ ${++this.counter}`\n\n    // 처음 실행 됐을때 clap_counter를 표시하기 위해 class에 'first' 클래스가 있는지 체크 -> x: first 클래스 추가, o: act클래스 추가\n    if (clickCounter.classList.contains('first')) {\n      this.runAnimation(clickCounter, 'act')\n    } else {\n      this.runAnimation(clickCounter, 'first')\n    }\n    this.runAnimation(this.$refs.clap, 'scale')\n\n    // 박수 친 횟수 올리기 (counter)\n    clickCounter.textContent = `+ ${++this.counter}`\n\n    // 숨겨진 clap_counter를 노출시킨다.\n    clickCounter.classList.add('act')\n  },\n  // element의 클래스명 존재여부 체크 -> x: 클래스추가, o: 클래스 삭제\n  runAnimation(element, className) {\n    if (element && !element.classList.contains(className)) {\n      element.classList.add(className)\n    } else {\n      element.classList.remove(className)\n      element.style.width = element.offsetWidth\n      element.classList.add(className)\n      /*\n      클래스를 삭제했다가 바로 추가가 되는 코드는 원하는 대로 작동하지 않기때문에 둘 사이에 하나의 이벤트를 걸어줘야 한다.\n      처음에는 setTimeout으로 시간차를 두었는데 clap_counter가 부자연스럽게 움직이는 현상이 있어\n      element.style.width = element.offsetWidth 라는 의미없는 코드를 두었다.\n      이는 다른 방법을 찾으면 보강해야 되겠다.\n      setTimeout(() => {\n        element.classList.add(className)\n      }, 0)\n      */\n    }\n  }\n}\n```\n\n![](img/clap-vue4.gif)\n\n## 4. CSS 보강 및 최종 완성 코드\n\n못생긴 버튼에 CSS코드를 추가하여 예쁘게 보강하기로 했다.\n\n**- HTML**\n\n```html\n<div id=\"vue\" class=\"clap_btn_wrapper\">\n  <button ref=\"clap\" class=\"clap_button\" @click=\"clapClick()\">\n    <img src=\"clap.png\" alt=\"clap_icon\" />\n  </button>\n  <div ref=\"clicker\" class=\"clap_counter\" />\n</div>\n```\n\n**- CSS**\n\n```css\n.clap_btn_wrapper {\n  position: relative;\n  width: 80px;\n  height: 80px;\n}\n.clap_btn_wrapper .clap_button {\n  height: 100%;\n  width: 100%;\n  outline: none;\n  cursor: pointer;\n  background-color: #fff;\n  border: 2px solid green;\n  border-radius: 100%;\n}\n/* 버튼을 클릭했을때 튕기듯이 커지는 애니메이션 효과를 주는 class */\n.clap_btn_wrapper .clap_button.scale {\n  animation: scale 0.7s forwards;\n}\n.clap_btn_wrapper .clap_counter {\n  position: absolute;\n  left: 50%;\n  top: -30px;\n  width: 30px;\n  height: 30px;\n  line-height: 30px;\n  margin-left: -15px;\n  background-color: green;\n  border-radius: 100%;\n  color: #fff;\n  opacity: 0;\n  font-size: 12px;\n  text-align: center;\n}\n.clap_btn_wrapper .clap_counter.first {\n  animation: first-bump 1s forwards;\n}\n.clap_btn_wrapper .clap_counter.act {\n  animation: bump 1s forwards;\n}\n/* 튕기듯이 커지는 애니메이션 */\n@keyframes scale {\n  0% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(1.05); /* 클릭됐을때 좀더 큰 효과를 원한다면 scale 조절 */\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n@keyframes first-bump {\n  0% {\n    transform: translateY(-10px);\n    opacity: 1;\n  }\n  50% {\n    transform: translateY(-20px);\n    opacity: 1;\n  }\n  100% {\n    transform: translateY(-30px);\n    opacity: 0;\n  }\n}\n@keyframes bump {\n  0% {\n    transform: translateY(-10px) scale(0.9);\n    opacity: 1;\n  }\n  50% {\n    transform: translateY(-10px) scale(1);\n    opacity: 1;\n  }\n  100% {\n    transform: translateY(-25px) scale(1);\n    opacity: 0;\n  }\n}\n```\n\n**- JS**\n\n```js\nnew Vue({\n  el: \"#vue\",\n  data: {\n    counter: 0,\n  },\n  methods: {\n    clapClick() {\n      const clickCounter = this.$refs.clicker\n      clickCounter.textContent = `+ ${++this.counter}`\n      if (clickCounter.classList.contains(\"first\")) {\n        this.runAnimation(clickCounter, \"act\")\n      } else {\n        this.runAnimation(clickCounter, \"first\")\n      }\n      this.runAnimation(this.$refs.clap, \"scale\")\n    },\n    runAnimation(element, className) {\n      if (element && !element.classList.contains(className)) {\n        element.classList.add(className)\n      } else {\n        element.classList.remove(className)\n        element.style.width = element.offsetWidth\n        element.classList.add(className)\n      }\n    },\n  },\n})\n```\n\n<p class=\"codepen\" data-height=\"500\" data-theme-id=\"dark\" data-default-tab=\"css,result\" data-user=\"dmsgp62\" data-slug-hash=\"WNxBRQy\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;\" data-pen-title=\"vue clap button\">\n  <span>See the Pen <a href=\"https://codepen.io/dmsgp62/pen/WNxBRQy\">\n  vue clap button</a> by chaeyeon (<a href=\"https://codepen.io/dmsgp62\">@dmsgp62</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n\n## 포스팅을 마치며..\n\nvue에서 ref 사용을 권장하지 않는 걸로 알고 있는데 부득이하게 element를 지정하기 위해 사용하게 되었다. 아직 vue에 대한 공부가 부족하다고 생각된다. 사실 react를 더 좋아하지만 프리랜서 프로젝트에서는 vue를 다루기 때문에 vue를 사용해야 한다. vue 프론트엔드 개발자처럼 깊게 공부한적도 깊게 생각한 적도 없었는데, 장바구니 버튼을 만들면서 여러가지를 알게 되었다.\n사실 처음에는 mounted() 안에 vanila js코드로 입력했다가 다른 페이지에서 에러가 발생해 method로 변경하였는데, 이때, vue의 life cycle이 중요하다는 사실을 알았다.\n기술 블로그는 예전부터 시작하고 싶었고 실제로 만들어놨었지만 어떤 주제를 다뤄야 할지와 시간이 없다는 핑계로 요리조리 피해 다녔는데, 나는 코딩을 할 때 동일한 기능의 코드들도 대충대충 복사해서 쓴다는 사실을 깨닫고, 블로그에 정리하면서 이런 코딩스타일을 고치고 멋진 프론트엔드 개발자가 되고 싶어서 겨우겨우 시작하게 되었다.\n첫 포스팅은 프로젝트에서 제일 깊이 고민했던 버튼 클릭시 count되는 액션이 보이는 clap-button으로 시작했다. 내 코드가 미숙하거나 이상할 수도 있고 부끄럽기도 하지만, 많은 사람들과 공유하고 싶었다.\n앞으로 수많은 코딩을 통해 더 멋진 코드를 작성하고 싶다.\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}