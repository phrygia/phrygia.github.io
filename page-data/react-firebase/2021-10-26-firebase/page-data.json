{"componentChunkName":"component---src-templates-blog-template-js","path":"/react-firebase/2021-10-26-firebase/","result":{"data":{"cur":{"id":"1c2a8a1d-dcc2-5441-9c32-bbcc2dc24742","html":"","excerpt":"","frontmatter":{"date":"September 26, 2021","title":"[react] firebase 프로젝트 배포하기","categories":"js react","author":"phrygia","emoji":"📓"},"fields":{"slug":"/react-firebase/2021-10-26-firebase/"}},"next":{"id":"1729f0ee-f37b-50ff-a706-4e0566ebc60b","html":"<p><img src=\"https://i.pinimg.com/originals/f5/69/ae/f569aef9a09bec7ca74f0dcd228a5343.jpg\" alt=\"\"><br>\n<small class=\"from\" style=\"text-align:right;\">사진 출처 : <a href=\"https://www.pinterest.co.kr/pin/439734351121493066/\" target=\"_blank\">https://www.pinterest.co.kr/pin/439734351121493066/</a></small><br></p>\n<p>클로저(closure)는 자바스크립트 고유의 개념이 아니라 함수형 프로그래밍 언어에서 등장하는 보편적인 특성이다. 개념이 아니기 때문에 ECMAScript 명세서에도 클로저의 정의를 다루지 않고 있어 클로저에 대한 다양한 정의와 설명이 존재한다.<br><br></p>\n<blockquote>\n<p><em><code class=\"language-text\">자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수</code> - 더글라스 크록포드 (자바스크립트 핵심 가이드) <br>\n<code class=\"language-text\">함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것</code> - 에딘 브라운 (러닝 자바스크립트)<br>\n<code class=\"language-text\">함수를 선언할 때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수</code> - 존 레식 (자바스크립트 닌자 비급)<br>\n<code class=\"language-text\">이미 생명 주기상 끝난 외부 함수의 변수를 참조하는 함수</code> - 송형주 고형준 (인사이드 자바스크립트)<br>\n<code class=\"language-text\">자유변수가 있는 함수와 자유변수를 알 수 있는 환경의 결합</code> - 에릭 프리먼 (Head First Javascript programming)<br>\n<code class=\"language-text\">로컬 변수를 참조하고 있는 함수 내의 함수</code> - 야마다 요시히로 (자바스크립트 마스터북)<br>\n<code class=\"language-text\">자신이 생성되 때의 스코프에서 알 수 있었던 변수들 중 언젠가 자신이 실행될 대 사용할 변수들만을 기억하여 유지시키는 함수</code> - 유인동 (함수형 자바스크립트 프로그래밍)<br>\n<code class=\"language-text\">클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다</code> - MDN</em>\n<br></p>\n</blockquote>\n<p>이처럼 많은 설명과 정의가 존재하지만 막상 그 의미를 이해하기는 쉽지않다. MDN에서는 </p>\n<div class=\"blockquote\">\n    \"A closure is the combination of a function and the lexical enviroment within which that function was declared\" <br>\n</div>\n<p>라고 소개한다. 직역하면 \"클로저는 함수와 그 함수가 선언될 당시의 lexical enviroment의 상호관계에 따른 현상\" 정도가 된다.</p> <br>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABHUlEQVQoz6WSa3LCMAyEcw+wJdlKyLsJ3ICh9z/SVjIB0mmZ/uiPb+SHZrXepNK6hqqCmMEsVv8Do2r7EeM44hAZUdTI3yAn2cC0rZ/7HY8zq1WIEbUKPuYJmm29w/dMBLIeIlv7K2wfY0AIx4LflR67K4IiglPNUJuQ7OKBMKFRq8JIKcH7jiGYMGEYBqzrivP5jNoioyIoL0F3cmgTQpdxHBSHLkG7FsN8QtM1uN0+cb1ecblcME0Tcs4Fz95dR3/BXvBUm+0sELUnGV4l2Xnj7u4OXcDdeO37HsuyYJ7nMqRtW0TiknPlX7ZRyyz9pPEMecvQiBs+QJ8uM5LIK0OSZOqCyL9A738Pd/SAHNPZBPP9l3iH/MG+xwZ9AWIn+4QUbCKfAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"closure.png\"\n        title=\"closure.png\"\n        src=\"/static/b193b6ba790a5946bc3596d8448891e7/37523/closure.png\"\n        srcset=\"/static/b193b6ba790a5946bc3596d8448891e7/e9ff0/closure.png 180w,\n/static/b193b6ba790a5946bc3596d8448891e7/f21e7/closure.png 360w,\n/static/b193b6ba790a5946bc3596d8448891e7/37523/closure.png 720w,\n/static/b193b6ba790a5946bc3596d8448891e7/302a4/closure.png 1080w,\n/static/b193b6ba790a5946bc3596d8448891e7/07a9c/closure.png 1440w,\n/static/b193b6ba790a5946bc3596d8448891e7/ac25d/closure.png 2342w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>그림에서처럼 Outer내부에서 선언된 내부함수 Inner의 실행 컨텍스트가 활성화된 시점에는 Inner의 outerEnvironmentReference가 참조하는 대상인 Outer의 LexicalEnviroment에 접근이 가능하다. Outer함수에서는 Inner함수에 선언한 변수에 접근할 수 없지만 Inner함수에서는 Outer에서 선언한 변수에 접근이 가능하다. (스코프 체인) Inner함수에서 Outer함수의 변수를 참조하는 경우에 한해서 LexicalEnviroment의 상호관계에 의미가 생긴다.<br><br></p>\n<p><strong>예제 1</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">outer</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">inner</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>a<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">inner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//  2</span></code></pre></div>\n<br>\n<p>위의 예제에서 outer함수에서 변수 a를 선언했고, outer함수의 내부함수인 inner 함수에서 a의 값을 1만큼 증가시킨 다음 출력한다. </p>\n<ol>\n<li>inner 함수 내부에서는 변수 a를 선언하지 않았기 때문에 environmentRecord에서 값을 찾지 못한다.</li>\n<li>inner 함수의 outerEnvironmentReference에 지정된 상위 컨텍스트의 outer의 LexicalEnviroment에 접근해서 a를 찾는다.</li>\n<li>console.log(++a)가 실행되면서 2가 출력된다.</li>\n<li>outer 함수의 실행컨텍스트가 종료되면 LexicalEnviroment에 저장된 식별자들 (a, inner)에 대한 참조를 지운다.</li>\n<li>자신을 참조하는 변수가 하나도 없게 되면서 가비지 컬렉터의 수집 대상이 된다.\n<br><br></li>\n</ol>\n<p><strong>예제 2</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">outer</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">inner</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token operator\">++</span>a<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> inner<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">var</span> outer2 <span class=\"token operator\">=</span> <span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">outer2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//  2</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">outer2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//  3</span></code></pre></div>\n<br>\n<p>예제2는 예제1과 다르게 inner 함수 자체를 반환했다. </p>\n<ol>\n<li>outer 함수의 실행 컨텍스트가 종료될 때 outer2 변수는 outer의 실행 결과의 inner 함수를 참조한다.</li>\n<li>console.log(outer2())를 호출하면 반환된 함수인 inner가 실행된다.</li>\n<li>inner 함수의 실행 컨텍스트의 environmentRecord에는 수집할 정보가 없다. (실행종료 상태이기 때문에)</li>\n<li>inner 함수는 내부 함수이기 때문에 outer-EnvironmentReference에는 inner 함수가 선언된 위치의 LexicalEnviroment가(outer 함수의 LexicalEnviroment가) 참조복사 된다.</li>\n<li>스코프 체이닝에 따라 outer에서 선언한 변수 a에 접근해서 1만큼 증가시킨 값인 2를 반환하고, inner 함수의 실행 컨텍스트가 종료된다.</li>\n<li>다시 console.log(outer2())를 호출하면 a의 값을 증가시킨 값인 3을 반환한다.</li>\n</ol>\n<br>\n*inner 함수의 실행 시점에는 outer 함수는 이미 실행 종료된 상태이지만 outer함수의 LexicalEnviroment에 접근이 가능하다. 그 이유는 가비지 컬렉터가 어떤 값을 참조하는 변수가 있다면 수집 대상에 포함하지 않기 때문이다.\n<p>종합해보면 <strong>클로저란 어떤 함수 A에서 선언한 변수 a를 참조하는 내부함수 B를 외부로 전달할 경우 A의 실행 컨텍스트가 종료된 이후에도 변수 a가 사라지지 않는 현상</strong>을 말한다. (가비지 컬렉팅되지 않기 때문에)\n<br><br><br></p>\n<h2 id=\"클로저와-메모리-관리\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\" aria-label=\"클로저와 메모리 관리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저와 메모리 관리</h2>\n<p>‘메모리 누수’라는 표현은 어떤 값의 참조 카운트가 0이 되지 않아 가비지 컬렉터의 수거 대상이 되지 않는 경우에 발생한다. 클로저는 어떤 필요에 의해 의도적으로 함수의 지역변수가 메모리를 소모하도록 함으로써 발생한다. 그 필요성이 사라진 시점에 참조 카운트를 0으로 만들어 주면 가비지 컬렉터가 수거하고 메모리 누수를 막을 수 있다. (참조 카운트를 0으로 만드는 방법은 식별자에 기본형 데이터(null, undefined)를 할당하면 된다.)<br><br></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// setInterval에 의한 클로저의 메모리 해제</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> intervalId <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> <span class=\"token function-variable function\">inner</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>a <span class=\"token operator\">>=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>intervalId<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            inner <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// inner 식별자의 함수 참조를 끊음</span>\n        <span class=\"token punctuation\">}</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    intervalId <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>inner<span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><br><br></p>\n<h2 id=\"클로저-활용방법\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80-%ED%99%9C%EC%9A%A9%EB%B0%A9%EB%B2%95\" aria-label=\"클로저 활용방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저 활용방법</h2>\n<ol>\n<li>콜백 함수 내부에서 외부 데이터를 사용하고자 할 때</li>\n<li>접근 권한 제어(정보은닉) </li>\n<li>부분 적용 함수</li>\n<li>커링 함수</li>\n</ol>\n<br>\n<p><small class=\"from add\">참고 : 코어 자바스크립트(정재남)</small></p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC\">클로저와 메모리 관리</a></li>\n<li><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80-%ED%99%9C%EC%9A%A9%EB%B0%A9%EB%B2%95\">클로저 활용방법</a></li>\n</ul>\n</div>","frontmatter":{"date":"September 21, 2021","title":"[javascript] closure (클로저)","categories":"js","author":"phrygia","emoji":"📓"},"fields":{"slug":"/closure/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://phrygia.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/react-firebase/2021-10-26-firebase/","nextSlug":"/closure/","prevSlug":""}},"staticQueryHashes":["1073350324","2938748437"]}